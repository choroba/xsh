<article>
  <title>XSH2 Reference</title>
  <section id="intro">
    <title>XSH2 Language</title>
  
      <para>
	XSH2 acts as a command interpreter. Individual commands must
	be separated with a semicolon. 
	In the interactive shell, backslash may be used at the end of a line to
	indicate that a command continues on the next line.
	Output redirection can be used to pipe output of some XSH <link linkend="command">command</link> to some external program, or to capture the output
	to a variable. See <link linkend="Redirection">Redirection</link> for more info.
      </para>
      <para>
	XSH2 command <link linkend="help_command">help</link> provides a complete
	reference, instantly from the command-line:
      </para>
      <para>
	<literal moreinfo="none">help command</literal>
	gives a list of all XSH2 <link linkend="command">commands</link>.
      </para>
      <para>
	<literal moreinfo="none">help type</literal> gives a
	list of all argument types.
      </para>
      <para>
	<literal moreinfo="none">help topic</literal> followed by
	documentation chapter gives more information on a given topic.
      </para>
      <para>
	<literal moreinfo="none">help toc</literal> displays the table of contents.
      </para>
    <section id="Documents">
      <title>Files/Documents</title>
      <para>
	XSH2 is designed as an environment for querying and manipulating XML and
	HTML documents. Use <link linkend="open_command">open</link> or <link linkend="create_command">create</link> commands to load an XML or HTML
	document from a local file, external URL (such as http:// or ftp://),
	string or pipe. XSH2 can optionally validate the document during parse
	process (see <link linkend="validation">validation</link> and
	<link linkend="load_ext_dtd">load-ext-dtd</link>). Parsed documents are stored in memory
	as <ulink url="http://www.w3.org/DOM/">DOM</ulink> trees, that can be
	<link linkend="Navigation">navigated</link> and <link linkend="Manipulation">manipulated</link> with XSH2 commands and XPath
	language, whose names and syntax make working with
	the DOM tree a flavor of working in a UNIX filesystem.
      </para>
      <para>
	A parsed document is usually stored in a variable. 
	XSH2 shares variables
	with the XPath engine, so if e.g. <literal moreinfo="none">$doc</literal> is a XSH2
	variable holding a document (or, more generally any node-set), then
	<literal moreinfo="none">$doc//section/title</literal> is an
	XPath expression selecting all <literal moreinfo="none">title</literal> 
	subelements of all
	<literal moreinfo="none">section</literal> elements within the (sub)tree of $doc.
      </para>
      <para>
	Although XSH2 is able to parse remote documents via
	<literal moreinfo="none">http://</literal> or <literal moreinfo="none">ftp://</literal>, it is only
	able to save them locally.  To upload a document to a remote server
	(e.g. using FTP) or to store it into a database, use <link linkend="save_command">save</link> command with a <literal moreinfo="none">--pipe</literal>
	parameter, in connection with an external program able to store
	its standard input (XML) to the desired location. 
	You can also use similar
	parameter with <link linkend="open_command">open</link> in order to parse
	documents from standard output of some external program.
      </para>
      <example>
	<title>Store a XSH2 document 
	  on a remote machine using the Secure Shell</title>
	<programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">save --pipe "ssh my.remote.org 'cat &gt; test.xml'" $doc</userinput></programlisting>
      </example>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="23">    <varlistentry>
      <term><link linkend="backups">backups</link></term>
      <listitem><para>turn on backup file creation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="catalog_command">catalog</link></term>
      <listitem><para>use a catalog file during all parsing processes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="cdonopen">switch-to-new-documents</link></term>
      <listitem><para>set on/off changing current document to newly
	  open/created files</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="clone_command">clone</link></term>
      <listitem><para>clone a given document</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="close_command">close</link></term>
      <listitem><para>close document (without saving)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="create_command">create</link></term>
      <listitem><para>make a new document from a given XML fragment</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="document">document</link></term>
      <listitem><para>specifying documents</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="filename">filename</link></term>
      <listitem><para>specifying filenames</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="files_command">documents</link></term>
      <listitem><para>display a list of open documents</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="index_command">index</link></term>
      <listitem><para>index a static document for faster XPath lookup</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nobackups">nobackups</link></term>
      <listitem><para>turn off backup file creation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nodename">nodename</link></term>
      <listitem><para>specifying names of DOM nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="open_command">open</link></term>
      <listitem><para>load an XML, HTML, or Docbook SGML document from a
	file, pipe or URI</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="process_xinclude_command">process-xinclude</link></term>
      <listitem><para>load and insert XInclude sections</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="save_command">save</link></term>
      <listitem><para>save a document as XML or HTML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_filename_command">set_filename</link></term>
      <listitem><para>change filename or URL associated with a document</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="stream_process_command">stream</link></term>
      <listitem><para>process selected elements from an XML stream (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="subname">subroutine</link></term>
      <listitem><para>name of a sub-routine</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="varname">$variable</link></term>
      <listitem><para></para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Navigation">
      <title>Tree navigation</title>
      <para>
	With XSH2, it is possible to browse a <link linkend="Documents">document tree</link> 
	(XML data represented as a DOM-tree) as if it was a local
        filesystem, except that <link linkend="xpath">XPath</link> 
	expressions are used instead of ordinary directory paths.
      </para> 
      <para>
	To mimic the filesystem navigation as closely as
	possible, XSH2 contains several commands named by analogy of
	UNIX filesystem commands, such as <link linkend="chxpath_command">cd</link>, <link linkend="list_command">ls</link> and
	<link linkend="pwd_command">pwd</link>.	
      </para>
      <para>The current position in the document tree
	is called the <emphasis>current node</emphasis>. Current node's XPath
	may be queried with <link linkend="pwd_command">pwd</link> command.  In the interactive shell, current
	node is also displayed in the command line prompt. 
	(Since there may be
	multiple document trees open at the same time, XSH2 tries to locate a
	variable holding the current document and use it to fully qualify
	current node's XPath in the XSH2 prompt.) Remember, that beside <link linkend="chxpath_command">cd</link> command, current node (and document) is
	also silently changed by <link linkend="open_command">open</link> command, <link linkend="create_command">create</link> command and temporarily also by the
	node-list variant of the <link linkend="foreach">foreach</link> loop without
	a loop variable.
      </para>
      <para>XPath expressions are always evaluated in context
	of the current node. Different documents can be accessed
	through variables: <literal moreinfo="none">$doc/foo[1]/bar</literal>.</para>
      <example>
	<title>XSH2 shell</title>
	<programlisting format="linespecific">$scratch:/&gt; <userinput moreinfo="none">$docA := open "testA.xml"</userinput>
$docA/&gt; <userinput moreinfo="none">$docB := open "testB.xml"</userinput>
$docB/&gt; <userinput moreinfo="none">pwd</userinput>
/
$docB/&gt; <userinput moreinfo="none">cd $docA/article/chapter[title='Conclusion']</userinput>
$docA/article/chapter[5]&gt; <userinput moreinfo="none">pwd</userinput>
/article/chapter[5]
$docA/article/chapter[5]&gt; <userinput moreinfo="none">cd previous-sibling::chapter</userinput>
$docA/article/chapter[4]&gt; <userinput moreinfo="none">cd ..</userinput>
$docA/article&gt; <userinput moreinfo="none">cd $docB</userinput>
$docB:/&gt; <userinput moreinfo="none">ls</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;article&gt;...&lt;/article&gt;
</programlisting>
      </example>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="19">    <varlistentry>
      <term><link linkend="c14n_command">canonical</link></term>
      <listitem><para>serialize nodes as to canonical XML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="chxpath_command">cd</link></term>
      <listitem><para>change current context node</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="fold_command">fold</link></term>
      <listitem><para>mark elements to be folded by list
	command</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="list_command">ls</link></term>
      <listitem><para>list a given part of a document as XML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="locate_command">locate</link></term>
      <listitem><para>show a given node location (as a canonical XPath)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="pwd_command">pwd</link></term>
      <listitem><para>show current context node location (as a canonical XPath)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerfunc_command">register-function</link></term>
      <listitem><para>define XPath extension function (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unfold_command">unfold</link></term>
      <listitem><para>unfold elements folded with fold command</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unregisterfunc_command">unregister-function</link></term>
      <listitem><para>undefine extension function (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath">xpath</link></term>
      <listitem><para>XPath expression</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Manipulation">
      <title>Tree modification</title>
      <para>
	XSH2 not only provides ways to browse and inspect the DOM tree but also
	many commands to modify its content by various operations,
	such as copying,
	moving, and deleting its nodes as well as creating completely new nodes
	or XML fragments and attaching them to it. It is quite easy to learn
	these commands since their names or aliases mimic their well-known
	filesystem analogies.  On the other hand, many of these commands have
	two versions one of which is prefixed with a letter "x". This
	"x" stands for "cross", thus e.g. <link linkend="xcopy_command">xcopy</link> should be read as "cross copy".
	Let's explain the difference on the example of <link linkend="xcopy_command">xcopy</link>.</para>
      <para>
	In a copy operation, you have to specify what nodes are to be
	copied and where to, in other words, you have to specify the
	<emphasis>source</emphasis> and the
	<emphasis>target</emphasis>.  XSH2 is very much XPath-based so,
	XPath is used here to specify both of them. However, there
	might be more than one node that satisfies an XPath expression. So,
	the rule of thumb is that the "cross" variant of a
	command places <emphasis>one and every</emphasis> of the source nodes
	to the location of <emphasis>one and every</emphasis> destination
	node, while the plain variant works one-by-one, placing the
	first source node to the first destination, the second source
	node to the second destination, and so on (as long as there
	are both source nodes and destinations left).
      </para>
      <informalexample>
	<programlisting format="linespecific">$scratch/&gt; <userinput moreinfo="none">$a := create "&lt;X&gt;&lt;A/&gt;&lt;Y/&gt;&lt;A/&gt;&lt;/X&gt;";</userinput>
$a/&gt; <userinput moreinfo="none">$b := create "&lt;X&gt;&lt;B/&gt;&lt;C/&gt;&lt;B/&gt;&lt;C/&gt;&lt;B/&gt;&lt;/X&gt;";</userinput>
$b/&gt; <userinput moreinfo="none">xcopy $a//A replace $b//B;</userinput>
$b/&gt; <userinput moreinfo="none">copy $b//C before $a//A;</userinput>
$b/&gt; <userinput moreinfo="none">ls $a;</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;X&gt;&lt;C/&gt;&lt;A/&gt;&lt;Y/&gt;&lt;C/&gt;&lt;A/&gt;&lt;/X&gt;

$b/&gt; <userinput moreinfo="none">ls $b;</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;X&gt;&lt;A/&gt;&lt;A/&gt;&lt;C/&gt;&lt;A/&gt;&lt;A/&gt;&lt;C/&gt;&lt;A/&gt;&lt;A/&gt;&lt;/X&gt;
</programlisting>
      </informalexample>
      <para>
	As already indicated by the example, another issue of tree modification
	is the way in which the destination node determines the target
	location. Should the source node be placed before, after, or somewhere
	among the children of the resulting node? Or maybe, should it replace
	it completely? This information has to be given in the
	<link linkend="loc">location</link> argument that usually precedes the destination
	XPath.
      </para>
      <para>
	Now, what happens if source and destination nodes are of
	incompatible types? XSH2 tries to avoid this by implicitly
	converting between node types when necessary.  For example, if
	a text, comment, and attribute node is copied into, before or
	after an attribute node, the original value of the
	attribute is replaced, prepended or appended respectively with
	the textual content of the source node. Note however, that
	<emphasis>element nodes are never converted</emphasis> into
	text, attribute or any other textual node.  There
	are many combinations here, so try yourself and see the
	results.
      </para>
      <para>You may even use some more sophisticated way to convert
	between node types, as shown in the following example, where
	an element is first commented out and than again uncommented.
	Note, that the particular approach used for resurrecting the
	commented XML material works only for well-balanced chunks of
	XML.
      </para>
      <example>
	<title>Using string variables to convert between different
	  types of nodes</title>
	<programlisting format="linespecific"><userinput moreinfo="none">$doc := create &lt;&lt;EOF;
&lt;?xml version='1.0'?&gt;
&lt;book&gt;
  &lt;chapter&gt;
    &lt;title&gt;Intro&lt;/title&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Rest&lt;/title&gt;
  &lt;/chapter&gt;
&lt;/book&gt;
EOF
</userinput>

# comment out the first chapter
<userinput moreinfo="none">ls //chapter[1] |&gt; $chapter_xml;</userinput>
<userinput moreinfo="none">insert comment $chapter_xml replace //chapter[1];</userinput>
<userinput moreinfo="none">ls / 0;</userinput>
# OUTPUT:
&lt;?xml version="1.0"?&gt;
&lt;book&gt;
&lt;!--  &lt;chapter&gt;
    &lt;title&gt;Intro&lt;/title&gt;
  &lt;/chapter&gt;
--&gt;
  &lt;chapter&gt;
    &lt;title&gt;Rest&lt;/title&gt;
  &lt;/chapter&gt;
&lt;/book&gt;


# un-comment the chapter
<userinput moreinfo="none">$comment = string(//comment()[1]);</userinput>
<userinput moreinfo="none">insert chunk $comment replace //comment()[1];</userinput>
<userinput moreinfo="none">ls / 0;</userinput>
# OUTPUT:
&lt;?xml version="1.0"?&gt;
&lt;book&gt;
  &lt;chapter&gt;
    &lt;title&gt;Intro&lt;/title&gt;
  &lt;/chapter&gt;

  &lt;chapter&gt;
    &lt;title&gt;Rest&lt;/title&gt;
  &lt;/chapter&gt;
&lt;/book&gt;
</programlisting>
      </example>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="16">    <varlistentry>
      <term><link linkend="change_namespace_prefix_command">change-ns-prefix</link></term>
      <listitem><para>change namespace prefix (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="change_namespace_uri_command">change-ns-uri</link></term>
      <listitem><para>change namespace URI (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="clone_command">clone</link></term>
      <listitem><para>clone a given document</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="copy_command">copy</link></term>
      <listitem><para>copy nodes (in the one-to-one mode)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="declare_namespace_command">declare-ns</link></term>
      <listitem><para>create a special attribute declaring an XML namespace (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="edit_command">edit</link></term>
      <listitem><para>Edit parts of a XML document in a text editor.</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="edit_string_command">edit-string</link></term>
      <listitem><para>Edit a string or variable in a text editor.</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exp">expression</link></term>
      <listitem><para>expression argument type</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="hash_command">hash</link></term>
      <listitem><para>index selected nodes by some key value</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="insert_command">insert</link></term>
      <listitem><para>create a node in on a given target location</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="loc">location</link></term>
      <listitem><para>relative destination specification (such as after, before, etc.)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="map_command">map</link></term>
      <listitem><para>transform node value/data using Perl or XPath expression</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="move_command">move</link></term>
      <listitem><para>move nodes (in the one-to-one mode)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nodetype">node-type</link></term>
      <listitem><para>node type specification (such as element, attribute, etc.)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="normalize_command">normalize</link></term>
      <listitem><para>normalizes adjacent textnodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="process_xinclude_command">process-xinclude</link></term>
      <listitem><para>load and insert XInclude sections</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="prune_command">remove</link></term>
      <listitem><para>remove given nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="rename_command">rename</link></term>
      <listitem><para>quickly rename nodes with in-line Perl code</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_command">set</link></term>
      <listitem><para>create or modify document content (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_dtd_command">set-dtd</link></term>
      <listitem><para>set document's DTD declaration</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_enc_command">set-enc</link></term>
      <listitem><para>set document's charset (encoding)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_namespace_command">set-ns</link></term>
      <listitem><para>set namespace of the current node (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_standalone_command">set-standalone</link></term>
      <listitem><para>set document's standalone flag</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="sort_command">sort</link></term>
      <listitem><para>sort a given node-list by given criteria</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="strip_ws_command">strip-whitespace</link></term>
      <listitem><para>strip leading and trailing whitespace</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="wrap_command">wrap</link></term>
      <listitem><para>wrap given nodes into elements</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="wrap_span_command">wrap-span</link></term>
      <listitem><para>wrap spans of nodes into elements</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xcopy_command">xcopy</link></term>
      <listitem><para>copy nodes (in the all-to-every mode)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xinsert_command">xinsert</link></term>
      <listitem><para>create nodes on all target locations</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xmove_command">xmove</link></term>
      <listitem><para>move nodes (in the all-to-every mode)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath">xpath</link></term>
      <listitem><para>XPath expression</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xslt_command">xslt</link></term>
      <listitem><para>compile a XSLT stylesheet and/or transform a document with XSLT</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xupdate_command">xupdate</link></term>
      <listitem><para>apply XUpdate commands on a document</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Flow">
      <title>Flow control</title>
      <para>
	As almost every scripting language, XSH2 supports subroutines,
	various conditional statements, loops and even exceptions.
      </para>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="9">    <varlistentry>
      <term><link linkend="block">block</link></term>
      <listitem><para>a block of XSH2 commands</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="call_command">call</link></term>
      <listitem><para>indirect call to a user-defined routine (macro)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="def">def</link></term>
      <listitem><para>sub-routine declaration</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="do_command">do</link></term>
      <listitem><para>execute a given block of commands</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="eval_command">eval</link></term>
      <listitem><para>evaluate given expression as XSH commands</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exit_command">exit</link></term>
      <listitem><para>exit XSH2 shell</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="foreach">foreach</link></term>
      <listitem><para>loop iterating over a node-list or a perl array</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="if">if</link></term>
      <listitem><para>if statement</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="ifinclude_command">ifinclude</link></term>
      <listitem><para>conditionally include another XSH2 source in current position</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="include_command">include</link></term>
      <listitem><para>include another XSH2 source in current position</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="iterate">iterate</link></term>
      <listitem><para>iterate a block over current subtree</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="last_command">last</link></term>
      <listitem><para>immediately exit an enclosing loop</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="next_command">next</link></term>
      <listitem><para>start the next iteration of an enclosing
	loop</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="prev_command">prev</link></term>
      <listitem><para>restart an iteration on a previous node</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="redo_command">redo</link></term>
      <listitem><para>restart the innermost enclosing loop block</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="return_command">return</link></term>
      <listitem><para>return from a subroutine</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="run_mode">run-mode</link></term>
      <listitem><para>switch into normal execution mode (quit <link linkend="test_mode">test-mode</link>)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="stream_process_command">stream</link></term>
      <listitem><para>process selected elements from an XML stream (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="test_mode">test-mode</link></term>
      <listitem><para>do not execute any command, only check the syntax</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="throw_command">throw</link></term>
      <listitem><para>throw an exception</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="try_catch">try</link></term>
      <listitem><para>try/catch statement</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="undef">undef</link></term>
      <listitem><para>undefine sub-routine or variable</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unless">unless</link></term>
      <listitem><para>negated if statement</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="while">while</link></term>
      <listitem><para>simple while loop</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Information">
      <title>Retrieving more information</title>
      <para> Beside the possibility to browse the DOM tree and
	list some parts of it (as described in <link linkend="Navigation">Navigation</link>), 
        XSH2 provides commands to obtain other
	information related to open documents as well as the XSH2
	interpreter itself. These commands are listed bellow.
      </para>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="10">    <varlistentry>
      <term><link linkend="apropos_command">apropos</link></term>
      <listitem><para>search the documentation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="c14n_command">canonical</link></term>
      <listitem><para>serialize nodes as to canonical XML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="count_command">count</link></term>
      <listitem><para>calculate a <link linkend="exp">expression</link> and enumerate node-lists</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="doc_info_command">doc-info</link></term>
      <listitem><para>displays various information about a document</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="expression_command">get</link></term>
      <listitem><para>calculate a given expression and return the result.</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="files_command">documents</link></term>
      <listitem><para>display a list of open documents</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="help_command">help</link></term>
      <listitem><para>on-line documentation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="lineno_command">lineno</link></term>
      <listitem><para>print line-numbers corresponding to matching nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="list_command">ls</link></term>
      <listitem><para>list a given part of a document as XML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="list_defs_command">defs</link></term>
      <listitem><para>list all user-defined subroutines</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="list_dtd_command">dtd</link></term>
      <listitem><para>show document's DTD</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="locate_command">locate</link></term>
      <listitem><para>show a given node location (as a canonical XPath)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="namespaces_command">namespaces</link></term>
      <listitem><para>List namespaces available in a context of
	  a given nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="options_command">settings</link></term>
      <listitem><para>list current settings using XSH2 syntax</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="print_command">print</link></term>
      <listitem><para>print stuff on standard or standard error output</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="print_enc_command">enc</link></term>
      <listitem><para>show document's original character encoding</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="pwd_command">pwd</link></term>
      <listitem><para>show current context node location (as a canonical XPath)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="validate_command">validate</link></term>
      <listitem><para>validate a document against a DTD, RelaxNG, or XSD schemas</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="var_command">variables</link></term>
      <listitem><para>list global variables</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="version">version</link></term>
      <listitem><para>show version information</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Namespaces">
      <title>Namespaces in XML and XPath</title> <para>Namespaces provide a
	simple method for qualifying element and attribute names in
	XML documents.  Namespaces are represented by a namespace URI
	but, since the URI can be very long, element and attribute
	names are associated with a namespace using a namespace prefix
	(see the <ulink url="http://www.w3.org/TR/REC-xml-names/">W3C
	recommendation</ulink> for details). In an XML document, a
	prefix can be associated with a namespace URI using a
	declaration which takes form of special attribute of the form
	<literal moreinfo="none">xmlns:prefix="namespace uri"</literal> on an element.
	The scope of the namespace declaration is then the subtree of the
	element carrying the special <literal moreinfo="none">xmlns:prefix</literal> attribute (and includes
	attributes of the element). Moreover, a default namespace can
	be declared using just <literal moreinfo="none">xmlns="namespace
	uri"</literal>.  In that case all unprefixed element names
	in the scope of such a
	declaration belong to the namespace. 
	An unprefixed element which is not in scope of 
	a default namespace declaration does not belong to any namespace.
	It is recommended not to combine namespaced elements and
	non-namespaced elements in a single document.
	Note that regardless of default
	namespace declarations, unprefixed attributes do not belong to any namespace
	(because they are uniquely determined by their name
	and the namespace and name of the the element which carries them).
      </para>
      <para>XSH2 tries to deal namespace declarations transparently
	(creating them if necessary when nodes are copied between
	different documents or scopes of namespace declarations). 
	Most commands which create new elements or attributes provide
	means to indicate a namespace. In addition, XSH2 provides commands <link linkend="declare_namespace_command">declare-ns</link>, <link linkend="set_namespace_command">set-ns</link>, <link linkend="change_namespace_uri_command">change-ns-uri</link>, and <link linkend="change_namespace_prefix_command">change-ns-prefix</link> to
	directly manipulate XML namespace declarations on the current
	node.
      </para>
      <para>
	Since XSH2 is heavily XPath-based, it is important to
	remember that XPath 1.0 maps prefixes to namespaces
	independently of the declarations in the current document. The
	mapping is instead provided via so called XPath context.
	Namespaces can be tested in XPath either using the built-in
	<literal moreinfo="none">namespace-uri()</literal> function, but it is more
	convenient to use namespace prefixes associated with namespace
	URIs in the XPath context.  This association is independent of
	the documents to which the XPath expression is applied and can
	be established using the command <link linkend="registerns_command">register-namespace</link>.  Additional, XSH2
	automatically propagates the namespace association in the
	scope of the current node to the XPath context, so that
	per-document prefixes in the current scope can also be used.
      </para>
      <para>
	IMPORTANT: <ulink url="http://www.w3.org/TR/xpath">XPath 1.0</ulink> has no concept of a default namespace.
	Unprefixed names in XPath only match names which have no
	namespace. So, if the document uses a default namespace,
	it is required to associate a
	non-empty prefix with the default namespace
        via  <link linkend="registerns_command">register-namespace</link>
	and add that prefix to names in XPath expressions intended to match 
	nodes in the default namespace.
      </para>
      <example>
	<title>Manipulating nodes in XHTML documents</title>
	<programlisting format="linespecific">open "index.xhtml";
$xhtmlns = "http://www.w3.org/1999/xhtml";
register-namespace x $xhtmlns;
wrap --namespace $xhtmlns '&lt;font color="blue"&gt;' //x:a[@href];
# or 
wrap '&lt;x:font color="blue"&gt;' //x:a[@href];</programlisting>
      </example>
      <para>In the preceding example we associate the (typically
	default) namespace of XHTML documents with the prefix
	<literal moreinfo="none">x</literal>.  We than use this prefix to match all
	links (<literal moreinfo="none">a</literal> elements) in the document.  Note
	that we do not write <literal moreinfo="none">@x:href</literal> to match the
	<literal moreinfo="none">@href</literal> attribute because unprefixed
	attributes do not belong to the default namespace.  The <link linkend="wrap_command">wrap</link> command is used to create new containing
	elements for the nodes matched by the XPath expression. We may
	either specify the namespace of the containing element
	explicitly, using <literal moreinfo="none">--namespace</literal> option, or
	implicitly, by using a prefix associated with the namespace in
	the XPath context.  In the latter case, XSH2 chooses a
	suitable prefix declared for the namespace in the document
	scope (in this case the default, i.e. no, prefix), adding a
	new namespace declaration if necessary.
      </para>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="24">    <varlistentry>
      <term><link linkend="change_namespace_prefix_command">change-ns-prefix</link></term>
      <listitem><para>change namespace prefix (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="change_namespace_uri_command">change-ns-uri</link></term>
      <listitem><para>change namespace URI (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="declare_namespace_command">declare-ns</link></term>
      <listitem><para>create a special attribute declaring an XML namespace (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="namespaces_command">namespaces</link></term>
      <listitem><para>List namespaces available in a context of
	  a given nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_command">register-namespace</link></term>
      <listitem><para>register namespace prefix to use XPath expressions</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_xhtml_command">register-xhtml-namespace</link></term>
      <listitem><para>register a prefix for the XHTML namespace</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_xsh_command">register-xsh-namespace</link></term>
      <listitem><para>register a prefix for the XSH2 namespace</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="set_namespace_command">set-ns</link></term>
      <listitem><para>set namespace of the current node (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unregisterns_command">unregister-namespace</link></term>
      <listitem><para>unregister namespace prefix</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Argtypes">
      <title>Argument Types</title>
      <para>
	XSH2 commands accept arguments of various types,
	usually expressed as Perl or XPath
	<link linkend="exp">expression</link>s. Unlike in most languages,
	individual XSH2 commands may evaluate the same expression differently, 
	usually
	to enforce a result
	of a certain type (such as a node-list, a string, a number,
	a filename, a node name, etc.).
	See <link linkend="exp">expression</link> and
	individual argument types for more information.
      </para>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="10">    <varlistentry>
      <term><link linkend="block">block</link></term>
      <listitem><para>a block of XSH2 commands</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="command">command</link></term>
      <listitem><para>List of XSH2 commands and their general syntax</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="document">document</link></term>
      <listitem><para>specifying documents</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="enc_string">encoding</link></term>
      <listitem><para>character encoding (codepage) identifier</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exp">expression</link></term>
      <listitem><para>expression argument type</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="filename">filename</link></term>
      <listitem><para>specifying filenames</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="loc">location</link></term>
      <listitem><para>relative destination specification (such as after, before, etc.)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nodename">nodename</link></term>
      <listitem><para>specifying names of DOM nodes</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nodetype">node-type</link></term>
      <listitem><para>node type specification (such as element, attribute, etc.)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="perl_code">perl-code</link></term>
      <listitem><para>in-line code in Perl programming language</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="subname">subroutine</link></term>
      <listitem><para>name of a sub-routine</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="varname">$variable</link></term>
      <listitem><para></para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath">xpath</link></term>
      <listitem><para>XPath expression</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Variables">
      <title>Variables</title>
      <para>
	In XSH2, like in Perl and XPath, 
	<link linkend="varname">variable names</link> are are prefixed
        with a dollar sign ($). 
        Variables can
        contain arbitrary Perl Scalar (string, number, array
        reference, hash reference or an object reference).  XPath
        objects are transparently mapped to Perl objects via
        XML::LibXML objects. 
        Values can be assigned to variables
        either by simple <link linkend="assign_command">assignments</link> of the form
	<literal moreinfo="none">$variable = <link linkend="exp">expression</link></literal>,
        where the right hand side is an expression, or by command 
        <link linkend="assign_command">assignments</link> of the form
	<literal moreinfo="none">$variable := <link linkend="command">command</link></literal>,
        where the right hand side is a XSH2 command, or by
	capturing the output of some command with a variable
	redirection of the following form:</para>
      <programlisting format="linespecific">command |&gt; $variable;</programlisting>
      <para>
	XSH2 expressions are evaluated either by XPath
	engine or by Perl (the latter only happens if the entire
	expression is enclosed with braces
	<literal moreinfo="none">{...}</literal>), and
	both Perl and XPath can access all XSH2 variables
	transparently (Perl expressions may even assign to them).
      </para>
      <para>
	A simple simple expression consisting of a variable name
        (e.g. <literal moreinfo="none">$variable</literal>) is always evaluated by the
        XPath engine and the result is the content of the variable as
        it appears to the XPath data model.  Since in XPath object
        cannot be void (undefined), XPath engine complains, if the
        value of the variable is undefined. On the other hand,
        expressions like <literal moreinfo="none">{$variable}</literal> are evaluated by
        Perl, which results in the value of the variable as seen
	by Perl.
      </para>
      <para>
	Variables can also be used as macros for complicated XPath
	expressions. Any occurrence of a substring of the form
	<literal moreinfo="none">${variable}</literal> in an XPath expression is
	interpolated to the value of <literal moreinfo="none">$variable</literal> (if
	<literal moreinfo="none">$variable</literal> contains an object rather than a
	string or number, then the object is cast to string first) before the
	entire expression is evaluated.  So, for example, if
	<literal moreinfo="none">${variable}</literal> contains string
	"<literal moreinfo="none">chapter[title]</literal>" (without the quotes), then
	the XPath expression
	<literal moreinfo="none">//sect1/${variable}/para</literal> interpolates to 
	<literal moreinfo="none">//sect1/chapter[title]/para</literal> prior
	to evaluation. 
      </para>
      <para>
	To display the current value of a variable, use either
	<link linkend="print_command">print</link>
	or (in case of a global variables - the distinction is discussed below)
	the command <link linkend="var_command">variables</link>:
      </para>
      <informalexample>
	  <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$b="my_document";</userinput>
xsh&gt; <userinput moreinfo="none">$file="${b}s.xml";</userinput>
xsh&gt; <userinput moreinfo="none">$f := open $file;</userinput>
xsh&gt; <userinput moreinfo="none">ls //$b[count(descendant::para)&gt;10]</userinput>
xsh&gt; <userinput moreinfo="none">print $b</userinput>
my_document
xsh&gt; <userinput moreinfo="none">variables</userinput>
...
$b='my_document';
...
$file='my_documents.xml';
...
</programlisting>
	</informalexample>
      <para>
	Variables can also serve as containers for documents and can be used to
	store lists of nodes that result from evaluating an XPath
	expression (a.k.a. XPath node-sets). This is especially useful
	when a sequence of commands is to be performed on some fixed
        set of nodes and repetitive evaluation of the same XPath 
	expression would be lengthy.  XPath
	node-sets are represented by
	<literal moreinfo="none">XML::LibXML::NodeList</literal> Perl objects (which
	is simply a array reference blessed to the above class, which
	provides some simple operator overloading). In XPath, by a
	node-set by definition can only contain a single copy of each
	node and the nodes within a node-set are processed in the same
	order as they appear in the XML document. Having XPath
	node-sets represented by a list gives us the advantage of having
	the possibility to process the list in a different order than
	the one implied by the document (which is what happens
	if a variable containing a node-list is evaluated by Perl 
	rather than XPath), see an example below.
      </para>
      <informalexample>
	<programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$creatures = //creature[@status='alive']</userinput>
# process creatures in the document order: 
xsh&gt; <userinput moreinfo="none">foreach $creature print @name;</userinput>
# process creatures in the reverse document order: 
xsh&gt; <userinput moreinfo="none">foreach { reverse @$creature } print @name;</userinput>
# append some more nodes to a node-list (using a variant of
# a simple assignment)
xsh&gt; <userinput moreinfo="none">$creatures += //creature[@status='dead'];</userinput>
# again, we can process creatures in order implied by the document:
xsh&gt; <userinput moreinfo="none">foreach $creature print @name;</userinput>
# but we can also process first living and then dead creatures,
# since this is how they are listed in $creature
xsh&gt; <userinput moreinfo="none">foreach {$creature} print @name;</userinput>
# same as the above is
xsh&gt; <userinput moreinfo="none">foreach {@$creature} print @name;</userinput>
</programlisting>
      </informalexample>
      <para>
	XSH2 variables are either globally or lexically scoped.
	Global variables need not to be declared (they can be directly
	assigned to), whereas lexical variables must be declared
	using the command <link linkend="my_command">my</link>. Global variable
	assignment may also be made temporal for the enclosing block,
	using <link linkend="local_command">local</link>.
      </para>
      <informalexample>
	<programlisting format="linespecific">$var1 = "foo";           # a global variable requires no declaration
local $var1 $var2 $var3; # localizes global variables
$var1 = "bar";           # assignment to a localized variable is temporary
local $var4 = "foo";     # localized assignment
my $var1 $var $var3;     # declares lexical variables
my $var1 = "foo";        # lexical variable declaration with assignment
</programlisting>
      </informalexample>
      <para>
	Lexical variables are only defined in the scope of current
	block or subroutine. There is no way to refer to a lexical
	variable form outside of the block it was declared in, nor
	from within a nested subroutine call. Of course, lexical
	variables can be referred to from nested blocks or Perl
	expressions (where they behave just like Perl's lexical
	variables).
      </para>
      <para>
	On the other hand, global or localized XSH2 variables are just
	Perl Scalar variables belonging to the
	<literal moreinfo="none">XML::XSH2::Map</literal> namespace, which is also the
	default namespace for any Perl code evaluated from XSH2 (so
	there's no need to use this prefix explicitly in Perl expressions,
	unless of course there is a lexical variable in the current
	scope with the same).
      </para>
      <para>Localizing a variable using the <literal moreinfo="none">local</literal>
	keyword makes all assignments to it occurring in the enclosing block
	temporary. The variable itself remains global, only its
	original value is restored at the end of the block that localized it.
      </para>
      <para> 
	In all above cases, it is possible to arbitrarily
	intermix XSH2 and Perl assignments:
      </para>
      <informalexample>
	  <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">ls //chapter[1]/title</userinput>
&lt;title&gt;Introduction&lt;/title&gt;
xsh&gt; <userinput moreinfo="none">$a=string(//chapter[1]/title)</userinput>
xsh&gt; <userinput moreinfo="none">perl { $b="CHAPTER 1: ".uc($a); }</userinput>
xsh&gt; <userinput moreinfo="none">print $b</userinput>
CHAPTER 1: INTRODUCTION
</programlisting>
      </informalexample>
      <para>
	Although all XSH2 variables are in fact Perl Scalars, it is
	still possible to store Perl Array or Hash value to a XSH2
	variable via reference. The following example demonstrates
	using Perl Hashes to collect and print some simple racial
	statistics about the population of Middle-Earth:
      </para>
      <informalexample>
	<programlisting format="linespecific">my $races;
foreach a:/middle-earth/creature { 
  my $race=string(@race);
  perl { $races-&gt;{$race}++ };
}
print "Middle-Earth Population (race/number of creatures)"
print { map "$_/$races-&gt;{$_}\n" keys(%$races); };
</programlisting>
      </informalexample>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="10">    <varlistentry>
      <term><link linkend="assign_command">assign</link></term>
      <listitem><para>variable assignment</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="document">document</link></term>
      <listitem><para>specifying documents</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exp">expression</link></term>
      <listitem><para>expression argument type</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="local_command">local</link></term>
      <listitem><para>temporarily assign new value to a variable</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="subname">subroutine</link></term>
      <listitem><para>name of a sub-routine</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="varname">$variable</link></term>
      <listitem><para></para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath">xpath</link></term>
      <listitem><para>XPath expression</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Redirection">
      <title>Command output redirection</title>
      <para>WARNING: XSH2 redirection syntax is not
	yet finished. It is currently the same as in XSH1
	but this may be changed in the future releases.
      </para>
      <para>
	Output redirection can be used to pipe output of some XSH <link linkend="command">command</link> to some external program, or to capture it
	to a variable. Redirection of output of more than one XSH
	command can be achieved using the <link linkend="do_command">do</link> command.
      </para> 
      <section id="Redirection_pipe">
	<title>Redirect output to an external program</title>
	<para>The syntax for redirecting the output of a XSH command to
	  an external program, is <literal moreinfo="none">xsh-command | shell-command
	    ;</literal>, where <literal moreinfo="none">xsh-command</literal> is any XSH2
	  command and <literal moreinfo="none">shell-command</literal> is any command
	  (or code) recognized by the default shell interpreter of the
	  operating system (i.e. on UNIX systems by
	  <literal moreinfo="none">/bin/sh</literal> or <literal moreinfo="none">/bin/csh</literal>, on
	  Windows systems by <literal moreinfo="none">cmd</literal>).  The shell command
	  may contain further redirections (as supported by the system
	  shell interpreter), but should not contain semicolons, except when
	  the whole shell command is enclosed in brackets.
	</para>
	<example>
	  <title>Use well-known UNIX commands to filter XPath-based XML
	    listing from a document and count the results</title>
	  <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">ls //something/* | grep foo | wc</userinput></programlisting>
	</example>
      </section>
      <section id="Redirection_variable">
	<title>Capture output to a variable</title>
	<para>
	  The syntax for capturing the output of an XSH command to a variable is
	  <literal moreinfo="none">xsh-command |&gt; $variable</literal>, 
	  where <literal moreinfo="none">xsh-command</literal> is
	  any XSH <link linkend="command">command</link> and 
	  <literal moreinfo="none">$variable</literal> is any valid
	  name for a <link linkend="Variables">variable</link>.
	</para>
	<example>
	  <title>Store the number of all words in a variable named count.</title>
	  <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">count //words |&gt; $count</userinput></programlisting>
	</example>
      </section>
    </section><section id="Configuration">
      <title>Global settings</title> <para>The commands listed below
      can be used to modify the default behavior of the XML parser or
      XSH2 itself.  Some of the commands switch between two different
      modes according to a given expression (which is expected to
      result either in zero or non-zero value). Other commands also
      working as a flip-flop have their own explicit counterparts
      (e.g.  <link linkend="verbose">verbose</link> and <link linkend="quiet">quiet</link> or
      <link linkend="debug">debug</link> and <link linkend="nodebug">nodebug</link>).  This
      inconsistency is due to historical reasons.
      </para>
      <para>
	The <link linkend="encoding">encoding</link> and <link linkend="query_encoding">query-encoding</link>
	settings 
	allow to specify character
	encodings of user's input and XSH2's own output. This is particularly
	useful when you work with UTF-8 encoded documents on a console
	which only supports 8-bit characters.
      </para>
      <para>
	The <link linkend="options_command">settings</link> command
	displays current settings by means of XSH2 commands.
	Thus it can not only be used to review current values, but
	also to store them for future use, e.g. in ~/.xsh2rc file.
      </para>
      <informalexample>
	<programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">settings | cat &gt; ~/.xsh2rc</userinput></programlisting>
      </informalexample>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="27">    <varlistentry>
      <term><link linkend="backups">backups</link></term>
      <listitem><para>turn on backup file creation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="cdonopen">switch-to-new-documents</link></term>
      <listitem><para>set on/off changing current document to newly
	  open/created files</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="complete_attributes">parser-completes-attributes</link></term>
      <listitem><para>turn on/off parser's ability to fill default attribute values</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="debug">debug</link></term>
      <listitem><para>display many annoying debugging messages</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="empty_tags">empty-tags</link></term>
      <listitem><para>turn on/off serialization of empty tags</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="enc_string">encoding</link></term>
      <listitem><para>character encoding (codepage) identifier</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="encoding">encoding</link></term>
      <listitem><para>choose output charset</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="indent">indent</link></term>
      <listitem><para>turn on/off pretty-printing</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="keep_blanks">keep-blanks</link></term>
      <listitem><para>turn on/off ignorable whitespace preservation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="load_ext_dtd">load-ext-dtd</link></term>
      <listitem><para>turn on/off external DTD fetching</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nobackups">nobackups</link></term>
      <listitem><para>turn off backup file creation</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="nodebug">nodebug</link></term>
      <listitem><para>turn off debugging messages</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="options_command">settings</link></term>
      <listitem><para>list current settings using XSH2 syntax</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="parser_expands_entities">parser-expands-entities</link></term>
      <listitem><para>turn on/off parser's tendency to expand entities</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="parser_expands_xinclude">parser-expands-xinclude</link></term>
      <listitem><para>turn on/off transparent XInclude insertion by parser</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="pedantic_parser">pedantic-parser</link></term>
      <listitem><para>make the parser more pedantic</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="query_encoding">query-encoding</link></term>
      <listitem><para>declare the charset of XSH2 source files and terminal input</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="quiet">quiet</link></term>
      <listitem><para>turn off many XSH2 messages</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="recovering">recovering</link></term>
      <listitem><para>turn on/off parser's ability to fix broken XML</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerfunc_command">register-function</link></term>
      <listitem><para>define XPath extension function (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_command">register-namespace</link></term>
      <listitem><para>register namespace prefix to use XPath expressions</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_xhtml_command">register-xhtml-namespace</link></term>
      <listitem><para>register a prefix for the XHTML namespace</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="registerns_xsh_command">register-xsh-namespace</link></term>
      <listitem><para>register a prefix for the XSH2 namespace</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="run_mode">run-mode</link></term>
      <listitem><para>switch into normal execution mode (quit <link linkend="test_mode">test-mode</link>)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="skip_dtd">skip-dtd</link></term>
      <listitem><para>turn on/off serialization of DTD DOCTYPE declaration</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="test_mode">test-mode</link></term>
      <listitem><para>do not execute any command, only check the syntax</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unregisterfunc_command">unregister-function</link></term>
      <listitem><para>undefine extension function (EXPERIMENTAL)</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="unregisterns_command">unregister-namespace</link></term>
      <listitem><para>unregister namespace prefix</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="validation">validation</link></term>
      <listitem><para>turn on/off validation in XML parser</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="verbose">verbose</link></term>
      <listitem><para>make XSH2 print many messages</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath_axis_completion_command">xpath-axis-completion</link></term>
      <listitem><para>sets TAB completion for axes in xpath expressions in
	the interactive mode</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath_completion_command">xpath-completion</link></term>
      <listitem><para>turn on/off TAB completion for xpath expressions in
	the interactive mode</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="xpath_extensions_command">xpath-extensions</link></term>
      <listitem><para>map predefined XSH2 XPath extension functions to
	  no or other namespace
	</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Perl_shell">
      <title>Interacting with Perl and Shell</title>
      <para>
	Along with XPath, Perl is one of two XSH2 expression languages,
	and borrows XSH2 its great expressive power.
	Perl is a language optimized for scanning arbitrary text
	files, extracting information from those text files, and
	printing reports based on that information. It has built-in
	regular expressions and powerful yet easy to learn 
	data structures (scalars, arrays, hash tables). It's also a
	good language for many system management tasks.
	XSH2 itself is written in Perl (except for the XML engine,
	which uses libxml2 library written in C by Daniel Veillard).
      </para>
      <section id="binding_perl">
	<title>Calling Perl</title>
	<para>
	  Perl <link linkend="perl_code">expressions or blocks of
	  code</link> can either be used as arguments to any XSH2 command.
	  One of them is 
	  <link linkend="perl_command">perl</link> command
	  which simply evaluates the given Perl block.
	  Other commands, such as <link linkend="map_command">map</link>,
	  even require Perl expression argument and allow
	  quickly change DOM node content.
	  Perl expressions may also provide lists of strings to iterate over
	  with a <link linkend="foreach">foreach</link> loop, or serve as
	  conditions for <link linkend="if">if</link>, <link linkend="unless">unless</link>, and 
	  <link linkend="while">while</link> statements.
	</para>
	<para>
	  To prevent conflict between XSH2 internals and the evaluated
	  Perl code, XSH2 runs such code in the context of a special
	  namespace <literal moreinfo="none">XML::XSH2::Map</literal>. As described in
	  the section <link linkend="Variables">Variables</link>, XSH2 string
	  variables may be accessed and possibly assigned from Perl
	  code in the most obvious way, since they actually
	  <emphasis>are</emphasis> Perl variables defined in the
	  <literal moreinfo="none">XML::XSH2::Map</literal> namespace.</para>
	<para>
	  The interaction between XSH2 and Perl actually works the
	  other way round as well, so that you may call back XSH2 from the
	  evaluated Perl code.  For this, Perl function
	  <literal moreinfo="none">xsh</literal> is defined in the
	  <literal moreinfo="none">XML::XSH2::Map</literal> namespace.  All parameters
	  passed to this function are interpreted as XSH2 commands.</para>
	<para>Moreover, the following Perl helper functions are defined:
	</para>
	<para><literal moreinfo="none">xsh(string,....)</literal> - evaluates
	  given string(s) as XSH2 commands.
	</para>
	<para><literal moreinfo="none">call(name)</literal> - call a given
	  XSH2 subroutine.
	</para>
	<para><literal moreinfo="none">count(string)</literal> - evaluates
	  given string as an XPath expression and returns
	  either literal value of the result (in case of
	  boolean, string and float result type) or
	  number of nodes in a returned node-set.
	</para>
	<para><literal moreinfo="none">literal(string|object)</literal> -
	  if passed a string, evaluates it as a XSH2 expression 
	  and returns the literal value of the result;
	  if passed an object, returns literal value of
	  the object.
	  For example,
	  <literal moreinfo="none">literal('$doc/expression')</literal> returns the same
	  value as <literal moreinfo="none">count('string($doc/expression)')</literal>.
	</para>
	<para>
	  <literal moreinfo="none">serialize(string|object)</literal> - 
	  if passed a string, it first evaluates the string
	  as a XSH2 expression to obtain a node-list object. 
	  Then it serializes the object into XML.
	  The resulting string is equal to the output of the XSH2 command <link linkend="list_command">ls</link> applied on the same expression or object
	  expression only without indentation and folding.
	</para>
	<para>
	  <literal moreinfo="none">type(string|object)</literal> - 
	  if passed a string, it first evaluates
	  the string as XSH2 expression to obtain a node-list object.
	  It returns a list of strings representing
	  the types of nodes in the node-list
	  (ordered in the canonical document order).
	  The returned type strings are: 
	  <literal moreinfo="none">element</literal>,
	  <literal moreinfo="none">attribute</literal>,
	  <literal moreinfo="none">text</literal>,
	  <literal moreinfo="none">cdata</literal>,
	  <literal moreinfo="none">pi</literal>,
	  <literal moreinfo="none">entity_reference</literal>,
	  <literal moreinfo="none">document</literal>,
	  <literal moreinfo="none">chunk</literal>,
	  <literal moreinfo="none">comment</literal>,
	  <literal moreinfo="none">namespace</literal>,
	  <literal moreinfo="none">unknown</literal>.
	</para>
	<para>
	  <literal moreinfo="none">nodelist(string|object,...)</literal> - 
	  converts its arguments to objects if necessary
	  and returns a node-list consisting of the objects.
	</para>
	<para>
	  <literal moreinfo="none">xpath(string, node?)</literal> - 
	  evaluates a given string as an XPath expression
	  in the context of a given node and returns
	  the result.
	</para>
	<para>
	  <literal moreinfo="none">echo(string,...)</literal> - prints
	  given strings on XSH2 output.
	  Note, that in the interactive mode,
	  XSH2 redirects all output to a specific terminal file handle
	  stored in the variable <literal moreinfo="none">$OUT</literal>.
	  So, if you for example mean to pipe the result 
	  to a shell command, you should avoid using STDOUT filehandle
	  directly. You may either use the usual <literal moreinfo="none">print</literal>
	  without a filehandle, 
	  use the <literal moreinfo="none">echo</literal> function,
	  or use <literal moreinfo="none">$OUT</literal> as a filehandle.
	</para>
	<para>
	  In the following examples we use Perl to populate the
	  Middle-Earth with Hobbits whose names are read from a text
	  file called <literal moreinfo="none">hobbits.txt</literal>, unless there are
	  some Hobbits in Middle-Earth already.
	</para>
	<example>
	  <title>Use Perl to read text files</title>
	  <programlisting format="linespecific">unless (//creature[@race='hobbit']) {
  perl {
    open my $fh, "hobbits.txt" };
    @hobbits=&lt;$file&gt;;
    close $fh;
  }
  foreach { @hobbits } {
    copy xsh:new-element("creature","name",.,"race","hobbit")
      into m:/middle-earth/creatures;
  }
}
</programlisting>
	</example>
	<example>
	  <title>The same code as a single Perl block</title>
	  <programlisting format="linespecific">perl {
  unless (count(//creature[@race='hobbit'])) {
    open my $file, "hobbits.txt";
    foreach (&lt;$file&gt;) {
      xsh(qq{insert element "&lt;creature name='$_' race='hobbit'&gt;"
        into m:/middle-earth/creatures});
    }
    close $file;
  }
};</programlisting>
	</example>
      </section>
      <section id="binding_perl_xpathextensions">
        <title>Writing your own XPath extension functions in Perl</title>
        <para>
	  XSH2 allows users to extend the set of XPath functions by
	  providing extension functions written in Perl.  This can
	  be achieved using the <link linkend="registerfunc_command">register-function</link>
	  command. The perl code implementing an extension function
	  works as a usual perl routine accepting its arguments in
	  <literal moreinfo="none">@_</literal> and returning the result. The
	  following conventions are used:
	</para>
	<para>
	  The arguments passed to the perl implementation by the XPath
	  engine are simple scalars for string, boolean and float
	  argument types and
	  <literal moreinfo="none">XML::LibXML::NodeList</literal> objects for node-set
	  argument types. The implementation is
	  responsible for checking the argument number and types. The
	  implementation may use general Perl functions as well as
	  <literal moreinfo="none">XML::LibXML</literal>
	  methods to process the arguments and return the result.
	  Documentation for the <literal moreinfo="none">XML::LibXML</literal> Perl module
	  can be found for example at <ulink url="http://search.cpan.org/~pajas/XML-LibXML/">http://search.cpan.org/~pajas/XML-LibXML/</ulink>.
	</para>
	<para>
	  Extension functions SHOULD NOT MODIFY the document DOM tree.
	  Doing so could not only confuse the XPath engine but possibly 
	  even result in an critical error (such as segmentation fault).
	  Calling XSH2 commands from extension function implementations
	  is also dangerous and isn't generally recommended.
	</para>
	<para>
	  The extension function implementation must return 
	  a single value, which can be of
	  one of the following types: simple scalar (a number or
	  string), <literal moreinfo="none">XML::LibXML::Boolean</literal> object
	  reference (result is a boolean value),
	  <literal moreinfo="none">XML::LibXML::Literal</literal> object reference
	  (result is a string), <literal moreinfo="none">XML::LibXML::Number</literal>
	  object reference (result is a float),
	  <literal moreinfo="none">XML::LibXML::Node</literal> (or derived) object
	  reference (result is a node-set consisting of a single node),
	  or <literal moreinfo="none">XML::LibXML::NodeList</literal> (result is a
	  node-set). For convenience, simple (non-blessed) array
	  references consisting of
	  <literal moreinfo="none">XML::LibXML::Node</literal> objects can also be
	  used for a node-set result instead of a
	  <literal moreinfo="none">XML::LibXML::NodeList</literal>.
        </para>
      </section>
      <section id="binding_shell">
	<title>Calling the System Shell</title>
	<para>
	  In the interactive mode, XSH2 interprets all lines starting
	  with the exclamation mark (<literal moreinfo="none">!</literal>) as shell
	  commands and invokes the system shell to interpret the line
	  (this is to mimic FTP and similar command-line interpreters).
	</para>
	<informalexample>
	  <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">!ls -l</userinput>
-rw-rw-r--    1 pajas    pajas        6355 Mar 14 17:08 Artistic
drwxrwxr-x    2 pajas    users         128 Sep  1 10:09 CVS
-rw-r--r--    1 pajas    pajas       14859 Aug 26 15:19 ChangeLog
-rw-r--r--    1 pajas    pajas        2220 Mar 14 17:03 INSTALL
-rw-r--r--    1 pajas    pajas       18009 Jul 15 17:35 LICENSE
-rw-rw-r--    1 pajas    pajas         417 May  9 15:16 MANIFEST
-rw-rw-r--    1 pajas    pajas         126 May  9 15:16 MANIFEST.SKIP
-rw-r--r--    1 pajas    pajas       20424 Sep  1 11:04 Makefile
-rw-r--r--    1 pajas    pajas         914 Aug 26 14:32 Makefile.PL
-rw-r--r--    1 pajas    pajas        1910 Mar 14 17:17 README
-rw-r--r--    1 pajas    pajas         438 Aug 27 13:51 TODO
drwxrwxr-x    5 pajas    users         120 Jun 15 10:35 blib
drwxrwxr-x    3 pajas    users        1160 Sep  1 10:09 examples
drwxrwxr-x    4 pajas    users          96 Jun 15 10:35 lib
-rw-rw-r--    1 pajas    pajas           0 Sep  1 16:23 pm_to_blib
drwxrwxr-x    4 pajas    users         584 Sep  1 21:18 src
drwxrwxr-x    3 pajas    users         136 Sep  1 10:09 t
-rw-rw-r--    1 pajas    pajas          50 Jun 16 00:06 test
drwxrwxr-x    3 pajas    users         496 Sep  1 20:18 tools
-rwxr-xr-x    1 pajas    pajas        5104 Aug 30 17:08 xsh</programlisting>
	</informalexample>
	<para>
	  To invoke a system shell command or program
	  from the non-interactive mode or from a complex
	  XSH2 construction, use the <link linkend="exec_command">exec</link>
	  command.
	</para>
	<para>
	  Since UNIX shell commands are very powerful tool for
	  processing textual data, XSH2 supports direct redirection of
	  XSH2 commands output to system shell command.  This is very
	  similarly to the redirection known from UNIX shells, except
	  that here, of course, the first command in the pipe-line
	  colone is an XSH2 <link linkend="command">command</link>. Since semicolon (<literal moreinfo="none">;</literal>)
	  is used in XSH2 to separate commands, it has to be prefixed
	  with a backslash if it should be used for other purposes.
	</para>
	<example>
	  <title>Use grep and less to display context of `funny'</title>
	  <programlisting format="linespecific">xsh&gt; ls //chapter[5]/para | grep funny | less</programlisting>
	</example>
	<example>
	  <title>The same on Windows 2000/XP systems</title>
	  <programlisting format="linespecific">xsh&gt; ls //chapter[5]/para | find "funny" | more</programlisting>
	</example>
      </section>
    <section>
  <title>Related topics</title>
  <para>
    <variablelist termlength="10">    <varlistentry>
      <term><link linkend="cd_command">lcd</link></term>
      <listitem><para>change system working directory</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exec_command">exec</link></term>
      <listitem><para>execute a shell command</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="exp">expression</link></term>
      <listitem><para>expression argument type</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="hash_command">hash</link></term>
      <listitem><para>index selected nodes by some key value</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="map_command">map</link></term>
      <listitem><para>transform node value/data using Perl or XPath expression</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="perl_code">perl-code</link></term>
      <listitem><para>in-line code in Perl programming language</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="perl_command">perl</link></term>
      <listitem><para>evaluate in-line Perl code</para></listitem>
    </varlistentry>    <varlistentry>
      <term><link linkend="rename_command">rename</link></term>
      <listitem><para>quickly rename nodes with in-line Perl code</para></listitem>
    </varlistentry></variablelist>
  </para>
 </section></section><section id="Prompt">
      <title>Prompt in the interactive shell</title>
      <para>
	Like many other shells, XSH2 provides means for customizing
	the format of its interactive shell prompt.  The prompt is
	displayed according to the content of the variable
	<literal moreinfo="none">$PROMPT</literal> on which the following
	substitutions and interpolations are performed
	(in this order):
      </para>
<para>1. Prompt-string replacements</para>
<programlisting format="linespecific">
%% - percent sign
%p - XPath location of the current node
%P - like %p but without an initial document variable
%l - XPath location of the current node with ID-shortcuts
%L - like %l but without an initial document variable
%n - name of the current node
%N - local name of the current node
%c - canonical XPath name of the current node
%y - type of the current node (element,attribute,...)
%i - ID of the current node
%d - current document variable
%h - the hostname up to the first '.'
%H - the hostname
%s - XSH shell name (basename of $0)
%t - the current time in 24-hour HH:MM:SS format
%T - the current time in 12-hour HH:MM:SS format
%@ - the current time in 12-hour am/pm format
%A - the current time in 24-hour HH:MM format
%u - the username of the current user
%v - the version of XSH2 (e.g., 2.1.0)
%V - the revision number of XML::XSH2::Functions (e.g. 2.40)
%w - current working directory (on the local filesystem)
%W - basename of %w
</programlisting>
<para>2. Variable, XPath and Perl interpolations</para>
<para>
Substrings of the forms <literal moreinfo="none">${variable}</literal>,
<literal moreinfo="none">${{...perl...}}</literal> and
<literal moreinfo="none">${(...xpath...)}</literal> are interpolated as in XSH2
<link linkend="exp">expressions</link>.
</para>
      <para>3. Special character substitution</para>
<programlisting format="linespecific">
\n - newline character
\r - line-feed character
\t - tab character
\a - bell character
\b - backspace character
\f - form feed character
\e - escape character (\033)
\\ - backslash character
\nnn - the character corresponding to the octal number nnn
(useful for non-printable terminal control characters)
</programlisting>
<para>The default value of <literal moreinfo="none">$PROMPT</literal> is <literal moreinfo="none">"%p&gt;"</literal>.</para>
      <para>Note that you must escape <literal moreinfo="none">${...}</literal>
	interpolators like <literal moreinfo="none">\${...}</literal> if you
	want them to be evaluated at each prompt
	rather than at the time of the assignment to <literal moreinfo="none">$PROMPT</literal>.
	For example:
      </para>
      <example>
	<title>Let `uname` be computed once, `date` at every prompt</title>
	<programlisting format="linespecific">$PROMPT="[${{ chomp($u=`uname`);$u }} \${{ chomp($d=`date`);$d }}] %p&gt;"</programlisting>
      </example>
    </section><section id="xsh2delta">
      <title>Changes since XSH 1.x</title>
      <para>
	This section briefly describes 
	differences between XSH2 and previous XSH 1.x releases.
	The list should not be considered complete.
	Some syntax variations or amendments in 
	the semantics of various commands may not be documented
	in this section, neither are various improvements in the
	XSH interpreter.
      </para>
      <section id="new_in_xsh2">
	<title>Changes in XSH2</title>
	<orderedlist continuation="restarts" inheritnum="ignore">
	  <listitem>
	<para>
	  In XSH2, subroutines can be called without a 
	  <link linkend="call_command">call</link>. They can be 
	  <link linkend="def">redefined</link> and 
	  <link linkend="undef">undefined</link>.
	  The command <link linkend="call_command">call</link>
	  can still be used, but it's use only makes sense
	  in indirect calls, where subroutine's name is computed
	  from an expression.
	</para>
	<programlisting format="linespecific">def foo $param1 $param2 { 
  # param1 and $param2 are lexical (a.k.a. my)
  ls $param1; 
  echo $param2 
}
foo (//chapter)[1] (//chapter)[1]/title

def inc $param1 { return ($param1 + 1) }
$two := inc 1;
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	  XSH2 uses variables of the form <link linkend="varname">$variable</link> 
	  for all kinds of objects, including node-sets
	  (which, if evaluated as Perl expressions, preserve node order).
	  Node-list variables of XSH 1.x have been deprecated.
	</para>
	<programlisting format="linespecific">$var = //foo/bar;                 # node set
$var = "hallo world";             # string
$var = xsh:new-element("foo");    # node object
$var = { ['a','b','c'] };         # Perl array reference
$var = {{ 'a'=&gt;'A', 'b'=&gt;'B' }};  # Perl hash reference
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	  XSH2 allows variables to be used in XPath just as they are used in XSLT:
	</para>
	<programlisting format="linespecific">$var = //foo/bar;
ls //baz[ . = $var[@test=1]/any ]
</programlisting>
	    <para>
	  Variable interpolation is still available in XSH2 via ${var},
	  but it's importance is diminished compared to XSH 1.x, 
	  because the XPath engine now evaluates
	  variables directly. Interpolation can still be used for
	  things like "XPath-macros":
	</para>
	<programlisting format="linespecific">$filter = "[ . = $var[@test=1]/any ]";
ls //baz${filter};
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	  XSH2 equally supports XPath and
	  Perl <link linkend="exp">expressions</link> 
	  (written in braces { ... }).
	  Unfortunately, Perl expressions can't be embedded in XPath 
	  <link linkend="exp">expressions</link>,
	  but one can still use variables as an agent:
	</para>
	<programlisting format="linespecific">perl { use MIME::Base64 };
my $encoded = { encode_base64('open sesame') }
ls //secret-cave[string(password) = $encoded]
</programlisting>
	<para>We can, however, use Perl-only expressions complemented with auto-conversion
	      to do things like:</para>
	<programlisting format="linespecific">copy { encode_base64('Pe do mellon a minno!') } replace //secret-cave/password/text();
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	  Commands return values 
	  (see <link linkend="assign_command">:= assignment</link>, 
	  or <link linkend="exp">&amp;{ } expressions</link>).
	</para>
	<programlisting format="linespecific">$moved_paras := xmove //para replace .;
$chapter := wrap chapter $moved_paras;
ls $chapter;

# or just

ls &amp;{ wrap chapter &amp;{ xmove //para replace . } };
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	  XSH2 deprecates "string" expressions of XSH 1.x.  However,
	  for convenience, some XSH2 commands interpret name-like
	  XPath expressions on certain argument positions as strings
	  (mostly commands that expect file-name or node-name
	  arguments):
	</para>
	<programlisting format="linespecific">insert element my_document into .;
insert text "foo" into my_document;

$doc := open my_document;         # opens file named "my_document"
$doc := open "my_document";       # same
$doc := open (my_document);       # opens file named "foo"
$doc := open string(my_document); # same
</programlisting>
	  </listitem>
	  <listitem>
	<para>
	  In XSH2, XML documents
	  have no ID. 
	  They are referred to using variables (which fits in well with the unified variable concept):
	</para>
	<programlisting format="linespecific">$doc1 := open "foo1.xml";
$doc2 := open "foo2.xml";
ls ($doc1//para|$doc2//para);
cd $doc1;
ls id('intro');             # finds ID intro in the current document ($doc1)
ls xsh:id2($doc2, 'intro'); # finds ID intro in $doc2
</programlisting>
	  </listitem>
	  <listitem>
	    <para>
	      XSH2 commands have options and flags instead of many optional (positional) arguments.
	      Options/flags usually have both long forms (like --flag) and equivalent
	      short forms (like :f) (colon is borrowed from Scheme, because dash is reserved for XPath minus).
	    </para>
	<programlisting format="linespecific">$doc := open --format html "version1.html";
save --file "version2.xml" $doc;

ls --fold /;
ls :f /;
ls --depth 1 /;
ls :d 1 /;

# all the same:
$sorted = sort --key @name --locale --descending //user;
$sorted = sort :l:d:k@name //user;
$sorted = sort --key @name --compare { use locale; $b cmp $a } //user;

validate --relaxng --file "test.rng" $mydoc;
validate --public "-//OASIS//DTD DocBook XML V4.1.2//EN" $mydoc;
validate --yesno $mydoc;
</programlisting>
	  </listitem>
	  <listitem>
	    <para>Finally, <link linkend="eval_command">eval</link> is no longer
	      an alias for <link linkend="perl_command">perl</link> in XSH2,
	      but instead evaluates strings containing XSH2 commands
	      (so <literal moreinfo="none">eval $string</literal> now practically works like old ugly
	      <literal moreinfo="none">perl { xsh($string) }</literal>). See the documentation for 
	      <link linkend="eval_command">eval</link> for a handy usage example
	      (no more PHP, XSTL and XPathScript :-)).
	    </para>
	  </listitem>
	</orderedlist>
      </section>
      <section id="xsh2delta_examples">
	<title>Examples</title>
	<example>
	  <title>Open command has changed.</title>
	  <programlisting format="linespecific">XSH1:
foo = file.xml;
or
foo = "file.xml";
</programlisting>
	  <programlisting format="linespecific">XSH2:
$foo := open file.xml;        # file.xml is a bareword in file-name context
or
$foo := open "file.xml";      # "file.xml" is a XPath string
or
$foo := open {"file.xml"};    # "file.xml" is a Perl string
or
$foo = xsh:open("file.xml");  # righthand side is an XPath extension function
</programlisting>
	</example>
	<example>
	  <title>XSH2 commands have options</title>
	  <programlisting format="linespecific">XSH1:
open HTML FILE foo2 = "file.html";
</programlisting>
	  <programlisting format="linespecific">XSH2:
$foo2 := open --format html "file.html";
</programlisting>
	</example>


	<example>
	  <title>documents</title>
	  <programlisting format="linespecific">XSH1:
foo = file.xml;
ls foo:(//bar|//baz);
</programlisting>
	  <programlisting format="linespecific">XSH2:
$foo := open file.xml;
ls ($foo//bar|$foo//baz);
</programlisting>
	</example>


	<example>
	  <title>variable interpretation</title>
	  <programlisting format="linespecific">XSH1:
$family = "Arial";
ls //font[@family="$family"];   # interpolation
or
ls //font[@family="${family}"]; # interpolation
</programlisting>
	  <programlisting format="linespecific">XSH2:
$family = "Arial";
ls //font[@family=$family];     # evaluation by XPath engine
or
ls //font[@family="${family}"]; # interpolation
</programlisting>
	</example>



	<example>
	  <title>adding new nodes</title>
	  <programlisting format="linespecific">XSH1:
insert attribute "foo=bar" into /scratch;
</programlisting>
	  <programlisting format="linespecific">XSH2:
insert attribute "foo=bar" into /scratch;
or
copy xsh:new-attribute("foo","bar") into /scratch;
</programlisting>
	</example>


	<example>
	  <title>foreach with perl expression</title>
	  <programlisting format="linespecific">XSH1:
foreach { glob('*.xml') } {
  open doc = $__;
  ...
}
</programlisting>
	  <programlisting format="linespecific">XSH2:
foreach { glob('*.xml') } {
  my $doc := open .;
  ...
} 
</programlisting>
	</example>
	<example>
	  <title>foreach (perl expression) with variable</title>
	  <programlisting format="linespecific">XSH2:
foreach my $filename in { glob('*.xml') } {
  my $doc := open $filename;
  ...
} 
</programlisting>
	</example>
	<example>
	  <title>sorting nodes</title>
	  <programlisting format="linespecific">XSH1:
%list = //player;
sort @best_score { $a &lt;=&gt; $b } %list;
copy %list into .;
</programlisting>
	  <programlisting format="linespecific">XSH2:
$list := sort --numeric --key @best_score //player;
copy { $list } into .;
or
copy &amp;{ sort --numeric --key @best_score //player } into .;
or (using short options)
copy &amp;{ sort :n :k @best_score //player } into .;
</programlisting>
	</example>
      </section>
    </section></section>
  <section id="cmd">
    <title>Command Reference</title>
  <section id="apropos_command" role="command"><title>apropos</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">apropos [--fulltext] [--regexp] <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Print all help topics containing given expression
	    in their short description. The
	    <literal moreinfo="none">--fulltext</literal> flag forces
	    the search to be performed over the full text
	    of help. 
	    <literal moreinfo="none">--regexp</literal> indicates,
	    that the given <link linkend="exp">expression</link>
	    is a regular expression instead of a literal string.
	  </para>
	</simplesect></section><section id="assign_command" role="command"><title>assign</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">[assign] <link linkend="varname">$variable</link> = <link linkend="exp">expression</link></literal><literal moreinfo="none">[assign] <link linkend="varname">$variable</link> := <link linkend="command">command</link></literal><literal moreinfo="none">[assign]
	  <link linkend="varname">$variable</link> [-= | += | *= | /= | %= | x= | .= | ||= | &amp;&amp;= ] <link linkend="exp">expression</link></literal><literal moreinfo="none">[assign]
	  <link linkend="varname">$variable</link> [-:= | +:= | *:= | /:= | %:= | x:= | .:= | ||:= | &amp;&amp;:= ] <link linkend="command">command</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Evaluate the expression (= assignment) 
	    or command (:= assignment) on the right 
	    side of the assignment and store the result in 
	    a given variable. Optionally a Perl operator
	    (- subtraction, + addition, * multiplication,
	    / division, % modulo, x repeat string n-times,
	    . concatenation, || logical OR, &amp;&amp; logical AND)
	    can precede the assignment, in which
	    case the variable is assigned the result
	    of applying given operator on its previous
	    value and the value of the right side of the assignment.
	  </para>
	  <example>
	    <title>Assign XPath (node-set, string), or Perl results</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$a=chapter/title;</userinput>
xsh&gt; <userinput moreinfo="none">$b="hallo world";</userinput>
xsh&gt; <userinput moreinfo="none">$c={ `uname` };</userinput>
xsh&gt; <userinput moreinfo="none">ls $a;</userinput>
</programlisting>
	  </example>
	  <example>
	    <title>Arithmetic expressions (XPath)</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$a=5*100 </userinput># assign 500 to $a
xsh&gt; <userinput moreinfo="none">$a += 20 </userinput># add 20 to $a
xsh&gt; <userinput moreinfo="none">$a = (($a+5) div 10) </userinput>
</programlisting>
	  </example>
	  <example>
	    <title>Arithmetic expressions (Perl)</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$a={ 5*100 } </userinput>
xsh&gt; <userinput moreinfo="none">$a = { join ';', split //,"hallo" } </userinput># assigns "h;a;l;l;o" to $a
</programlisting>
	  </example>
	  <example>
	    <title>Command result assignment</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$doc := open "file.xml" </userinput># open a document
xsh&gt; <userinput moreinfo="none">$copies := xcopy //foo into //bar </userinput># copy elements and store the copies
xsh&gt; <userinput moreinfo="none">$wrappers := wrap "wrapper" $copies </userinput># wrap each node from $copies to a new element "wrapper" and store the wrapping elements
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="var_command">variables</link></para></simplesect></section><section id="backups" role="command"><title>backups</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">backups</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Enable creating backup files on save (default).</para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$BACKUPS</literal> variable to 1.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="nobackups">nobackups</link></para></simplesect></section><section id="call_command" role="command"><title>call</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">call <link linkend="exp">expression</link> [<link linkend="exp">expression</link> ...]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Call a subroutine whose name is computed by evaluating
	    the first argument <link linkend="exp">expression</link>. All other
	    expressions are evaluated too and the results are passed
	    to the subroutine as arguments.
	  </para>
	  <para>
	    This command should only be used if the name of the subroutine
	    isn't known at the compile time. Otherwise it is recommended
	    to use a direct subroutine call of the form:
	  </para>
	  <programlisting format="linespecific">subroutine-name [argument1 argument2 ...]</programlisting>
	  <informalexample>
	    <programlisting format="linespecific">def a $arg { echo "A says" $arg }
def b $arg { echo "B says" $arg }
a "hallo!";  # call subroutine a
b "hallo!";  # call subroutine b
call { chr(ord("a")+rand(2)) } "surprise!"; # call a or b randomly 
</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="def">def</link>, <link linkend="return_command">return</link></para></simplesect></section><section id="c14n_command" role="command"><title>canonical</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">canonical [--comments|:c] [--filter|:f <link linkend="xpath">xpath</link>] [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This commands prints a canonical XML representing nodes specified
	    by its argument (or current node, if no argument is given).</para>
	  <para><literal moreinfo="none">--comments</literal> or
	    <literal moreinfo="none">:c</literal> removes comments
	    from the resulting XML.</para>
	  <para>
	    <literal moreinfo="none">--filter</literal> or <literal moreinfo="none">:f</literal>
	    can be used to filter
	    the resulting XML so that it only contains
	    nodes explicitly included in the given node-set.</para>
	  <para>
	    For
	    details see <ulink url="http://www.w3.org/TR/xml-c14n">"Canonical
	      XML"</ulink> or <ulink url="http://www.w3.org/TR/xml-exc-c14n">"Exclusive XML Canonicalization"</ulink> W3C recommendations.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="list_command">ls</link></para></simplesect></section><section id="catalog_command" role="command"><title>catalog</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">catalog <link linkend="filename">filename</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Make use of a given XML file as a catalog during all parsing
	    processes. Using a catalog may significantly speed up
	    parsing processes if many external resources are loaded
	    into the parsed documents (such as DTDs or XIncludes).
	  </para>
	</simplesect></section><section id="chxpath_command" role="command"><title>cd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">cd [<link linkend="exp">expression</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> chxpath</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Evaluate given <link linkend="exp">expression</link>
	    to a node-list and 
	    change current context node to
	    the first node in it.
          </para>
	</simplesect></section><section id="change_namespace_prefix_command" role="command"><title>change-ns-prefix</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">change-ns-prefix <link linkend="exp">expression</link> [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command takes one or two arguments.  The first
	    argument is a new prefix and the second, optional,
	    argument is an old namespace prefix. It changes the prefix
	    of a namespace declaration of the context node to the new
	    value. If no old prefix is given, the change applies to a
	    declaration on the context node whose prefix equals to the
	    prefix of the context node, otherwise the command changes
	    the declaration with the given old prefix.
	  </para>
	  <para>
	    The command throws an exception if the new prefix is
	    already taken by some other declaration in the scope.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="change_namespace_uri_command">change-ns-uri</link>, <link linkend="set_namespace_command">set-ns</link>, <link linkend="declare_namespace_command">declare-ns</link>, <link linkend="namespaces_command">namespaces</link></para></simplesect></section><section id="change_namespace_uri_command" role="command"><title>change-ns-uri</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">change-ns-uri <link linkend="exp">expression</link> [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command takes one or two arguments.  The first
	    argument is a new namespace URI and the second, optional,
	    argument is a namespace prefix. It changes the URI value
	    of a namespace declaration of the context node to the new
	    value. If no prefix is given, the change applies to a
	    declaration on the context node whose prefix equals to the
	    prefix of the context node, otherwise the change applies
	    to a declaration with the given prefix.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="change_namespace_prefix_command">change-ns-prefix</link>, <link linkend="set_namespace_command">set-ns</link>, <link linkend="declare_namespace_command">declare-ns</link>, <link linkend="namespaces_command">namespaces</link></para></simplesect></section><section id="clone_command" role="command"><title>clone</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$doc := clone <link linkend="document">document</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> dup</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create and return a copy of a given <link linkend="document">document</link>.
	    Unless <link linkend="cdonopen">switch-to-new-documents</link>
	    configuration flag is turned off,
	    the root node of the new document
	    becomes the current node.
	  </para>
	  <para>Calling this command only makes sense if
	    either
	    <link linkend="cdonopen">switch-to-new-documents</link> is set, or
	    if the result is assigned to a variable or
	    passed to another XSH2 command using the <literal moreinfo="none">&amp;{...}</literal>
	    syntax, since otherwise the newly 
	    created copy of the document is automatically garbage-collected and
	    destroyed.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="open_command">open</link>, <link linkend="close_command">close</link>, <link linkend="print_enc_command">enc</link>, <link linkend="files_command">documents</link></para></simplesect></section><section id="close_command" role="command"><title>close</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">close [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Close a given <link linkend="document">document</link>
	    (or, if called with no argument,
	    the current document)
	    by trying to remove all references
	    from XSH2 variables to nodes
	    belonging to the document. If no references
	    to the document are left,
	    the garbage-collector destroys
	    the DOM tree and frees the memory it occupied
	    for later reuse (depending on architecture, this
	    may or may not give the allocated memory back
	    to the system).
	  </para>
	</simplesect></section><section id="copy_command" role="command"><title>copy</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">copy [--respective|:r] <link linkend="exp">expression</link> <link linkend="loc">location</link> <link linkend="exp">expression</link></literal><literal moreinfo="none">$results := copy [--respective|:r] <link linkend="exp">expression</link> <link linkend="loc">location</link> <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> cp</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Copies nodes in the first node-list <link linkend="exp">expression</link>
	    (source nodes) to the destinations determined by the 
	    the <link linkend="loc">location</link> directive
	    applied to nodes in the second node-list <link linkend="exp">expression</link>
	    (target nodes). If the source node-list contains
	    more than one node, than N'th node in the source node-list
	    is copied to the location relative to the N'th node in
	    the target node-list.
          </para>
	  <para>
	    If <literal moreinfo="none">--respective|:r</literal> option
	    is used, then the target node-list <link linkend="exp">expression</link>
	    is evaluated in the context of the source node
	    being copied.
	  </para>
          <para>Possible values for <link linkend="loc">location</link> are:
	    <literal moreinfo="none">after</literal>, <literal moreinfo="none">before</literal>,
	    <literal moreinfo="none">into</literal>, <literal moreinfo="none">replace</literal>,
	    <literal moreinfo="none">append</literal> and <literal moreinfo="none">prepend</literal>. The first
	    three location directives cause making a copy of the source nodes
	    after, before, and within (as the last child-node) the target
	    nodes, respectively. 
	    If <literal moreinfo="none">replace</literal> location directive is used,
            source node are copied before the respective
	    target nodes and target nodes are removed.
	    The <literal moreinfo="none">append</literal> and <literal moreinfo="none">prepend</literal>
	    location directives allow,
	    depending on the destination node type,
	    either inserting copies of the
	    source nodes as the first or last child nodes of
	    a destination element or appending/prepending
	    destination node data in case of non-element destination nodes.
	    See <link linkend="loc">location</link> argument type
	    for more detail.
	  </para>
	  <para>The command returns a node-list consisting of 
	    the copies of all source nodes created by the command.
	  </para>
	  <para>Despite the fact the command is named "copy", 
	    nodes resulting from copying
	    the source nodes may pass through certain type conversion before
	    they are inserted at the appointed destinations. This, however,
	    only happens in cases where the types of the source and target
	    nodes are not compatible with the location
	    directive. See <link linkend="loc">location</link> argument
	    type for more detail.
	  </para>
	  <para>Note that XSH2 refuses to create multiple top-level
	    elements using <literal moreinfo="none">copy</literal>, 
	    <link linkend="move_command">move</link> and similar commands.</para>
	  <example>
	    <title>Replace living-thing elements in the document b with copies
	      of the corresponding creature elements from the document $a.</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">copy $a//creature replace $b//living-thing</userinput></programlisting>             
	  </example>
	  <example>
	    <title>Copy every element into itself</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">copy --respective $a//* into .</userinput></programlisting>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">copy $a//* into $a//*</userinput>#same as
above</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="xcopy_command">xcopy</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link>, <link linkend="insert_command">insert</link>, <link linkend="xinsert_command">xinsert</link></para></simplesect></section><section id="count_command" role="command"><title>count</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">count [--quiet|:q] <link linkend="xpath">xpath</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Calculates a given <link linkend="exp">expression</link> expression. If
	    the result is a node-list, print number of nodes in the
	    node-list.  If the <link linkend="exp">expression</link> results in a
	    boolean, numeric or literal value, print the value.
	  </para>
	  <para>
	    If <literal moreinfo="none">--quiet</literal> or <literal moreinfo="none">:q</literal>
	    option is used, output is suppressed and the value
	    is returned.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="expression_command">get</link></para></simplesect></section><section id="create_command" role="command"><title>create</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$doc := create <link linkend="nodename">nodename</link>|<link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> new</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a new document object. The
	    argument must evaluate either to 
	    a valid element name (possibly followed
	    by some attribute declarations) to be used
	    for the document element, or to 
	    a well-formed XML string.
	  </para>
	  <para>
	    Unless <link linkend="cdonopen">switch-to-new-documents</link> option is turned off,
	    this command also changes current node
	    to the new document.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">$scratch/&gt; <userinput moreinfo="none">$t1 := create root</userinput>
$t1&gt; <userinput moreinfo="none">ls $t1</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root/&gt;

$t1&gt; <userinput moreinfo="none">$t2 := create "root id='r1'"</userinput>
$t2&gt; <userinput moreinfo="none">ls $t2</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root id="r1"/&gt;

$t2&gt; <userinput moreinfo="none">create "&lt;root id='r0'&gt;Just a &lt;b&gt;test&lt;/b&gt;&lt;/root&gt;"</userinput>
/&gt; <userinput moreinfo="none">ls /</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root id='r0'&gt;Just a &lt;b&gt;test&lt;/b&gt;&lt;/root&gt;
</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="open_command">open</link>, <link linkend="clone_command">clone</link></para></simplesect></section><section id="debug" role="command"><title>debug</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">debug</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Turn on debugging messages.</para>
	  <para>This is equivalent to setting
	    <literal moreinfo="none">$DEBUG</literal> variable to 1.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="nodebug">nodebug</link></para></simplesect></section><section id="declare_namespace_command" role="command"><title>declare-ns</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">declare-ns <link linkend="exp">expression</link> <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command takes one or two arguments: prefix and URI,
	    both evaluated as names.
	    It creates a namespace declaration
	    of the form <literal moreinfo="none">xmlns:prefix="URI"</literal>
	    on the current node.
	    The command produces an error if
	    the prefix is already declared in the scope of the current node
	    with a different namespace URI.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="set_namespace_command">set-ns</link>, <link linkend="change_namespace_uri_command">change-ns-uri</link>, <link linkend="change_namespace_prefix_command">change-ns-prefix</link>, <link linkend="namespaces_command">namespaces</link></para></simplesect></section><section id="def" role="command"><title>def</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">def <link linkend="subname">subroutine</link> [<link linkend="varname">$variable</link> ...] <link linkend="block">block</link>
	</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> define</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Define a new XSH2 sub-routine named <link linkend="subname">subroutine</link>.
	    The subroutine may require zero or more parameters. 
	    These are declared as a
	    whitespace-separated list of <emphasis>parametric
	    variables</emphasis>. The body of the
	    subroutine is specified as a <link linkend="block">block</link>.
	  </para>
	  <para>A sub-routine can be invoked directly by its name
	    followed by its arguments
	    just as any XSH2 command, or indirectly
	    using the <link linkend="call_command">call</link>
	    command followed by an expression evaluating
	    to the routine name and sub-routine arguments. 
	    Sub-routine arguments can be arbitrary 
	    expressions. These expressions are evaluated
	    <emphasis>prior</emphasis> the sub-routine's code
	    execution and are assigned to the sub-routine's 
	    parametric variables in the respective order.
	    The number of parameter variables in a sub-routine
	    definition and the number of arguments in a call to it
	    must match.
	    Calling a sub-routine with less or more arguments
	    than declared is a run-time error.
	  </para>
	  <para>	    
	    Parametric variables are lexical 
	    variables within the sub-routine body as if they
	    were declared with <link linkend="my_command">my</link>.
	  </para>
	  <para>
	    Note that a subroutine has to be defined before it is
	    first called (in terms of execution -- depending on the structure
	    of the program, the actual definition of the sub-routine
	    must not necessarily precede all references to it).
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">def l3 $nodes {
  ls --depth 3 $nodes; # list given nodes upto depth 3
}
l3 //chapter;           # direct call
$subref = 'l3';
call $subref //chapter; # in-direct call
</programlisting>
	  </informalexample>
	  <example>
	    <title>Commenting and un-commenting pieces of document</title>
	    <programlisting format="linespecific">def comment
    $n      # nodes to move to comments
    $mark   # maybe some handy mark to recognize such comments
{
  foreach $n {
    if ( . = ../@* ) {
      echo "Warning: attribute nodes are not supported!";
    } else {
      echo "Commenting out:";
      ls --depth 0 .;
      add comment concat($mark,xsh:serialize(.)) replace .;
    }
  }
}

def uncomment $n $mark {
  foreach $n {
    if (. = ../comment()) { # is this node a comment node
      local $string = substring-after(.,"$mark");
      add chunk $string replace .;
    } else {
      echo "Warning: Ignoring non-comment node:";
      ls --depth 0 .;
    }
  }
}

# comment out all chapters with no paragraphs
comment //chapter[not(para)] "COMMENT-NOPARA";

# uncomment all comments stamped with COMMENT-NOPARA
$mark="COMMENT-NOPARA";
uncomment //comment()[starts-with(.,"$mark")] $mark;
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="call_command">call</link>, <link linkend="return_command">return</link>, <link linkend="my_command">my</link>, <link linkend="local_command">local</link></para></simplesect></section><section id="list_defs_command" role="command"><title>defs</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">defs</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>List names and parametric variables for all user-defined XSH2 subroutines.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="def">def</link>, <link linkend="var_command">variables</link></para></simplesect></section><section id="do_command" role="command"><title>do</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">do <link linkend="block">block</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Execute <link linkend="block">block</link>.
	    This command is probably only useful when one wants to
	    redirect output of more than one command.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="block">block</link></para></simplesect></section><section id="doc_info_command" role="command"><title>doc-info</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">doc-info [<link linkend="document">document</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> doc_info</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    In the present implementation, this command displays
	    information provided in the <literal moreinfo="none">&lt;?xml
	    ...?&gt;</literal> declaration of a document:
	    <literal moreinfo="none">version, encoding, standalone</literal>, 
	    plus information about
	    level of <literal moreinfo="none">gzip</literal> compression of the
	    original XML file and
	    the original XML file URI.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="set_enc_command">set-enc</link>, <link linkend="set_standalone_command">set-standalone</link></para></simplesect></section><section id="files_command" role="command"><title>documents</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">documents</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> files, docs</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>Try to identify open documents and list their URIs
	    and variables that contain them.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="open_command">open</link>, <link linkend="close_command">close</link></para></simplesect></section><section id="list_dtd_command" role="command"><title>dtd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">dtd [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Print external or internal DTD for a given document. 
	    If used without arguments prints DTD of the current document.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="set_dtd_command">set-dtd</link>, <link linkend="validate_command">validate</link></para></simplesect></section><section id="edit_command" role="command"><title>edit</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">edit [--editor|:E <link linkend="filename">filename</link>]
	  [--all|:A] [--noindent|:n] [--recover|:r] [--keep-blanks|:k]
	  [--allow-empty|:0] [--no-coment|:q] [--encoding|:e <link linkend="enc_string">encoding</link>] <link linkend="exp">expression</link>
	</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>This command may be used to interactively edit parts of a XML
	    document directly in your favorite editor.
	  </para>
	  <para>
	    A given <link linkend="exp">expression</link> is evaluated to a node-list and the
	    first the first resulting node is opened
	    in an external editor as a XML fragment. 
	    When the editor exits, the (possibly modified) fragment
	    is parsed and returned to the original document. Unless
	    <literal moreinfo="none">--no-comment</literal> (<literal moreinfo="none">:q</literal>) flag is
	    used, the XML fragment is preceded with a XML comment specifying
	    canonical XPath of the node being edited.
	  </para>
	  <para>
	    The command returns a node-list consisting of nodes
	    that resulted from parsing the individual edits.
	  </para>
	  <para>
	    <literal moreinfo="none">--editor</literal> or <literal moreinfo="none">:E</literal>
	    option may be used to specify external editor command.
	    If not specified, environment variables
	    <literal moreinfo="none">EDITOR</literal> and <literal moreinfo="none">VISUAL</literal>
	    are tried first, then <literal moreinfo="none">vi</literal> editor
	    is used as a fallback.
	  </para>
	  <para>
	    If <literal moreinfo="none">--all</literal> or <literal moreinfo="none">:A</literal>
	    flag is present, all nodes from the node-list
	    are opened in the editor, one at a time.
	  </para>
	  <para>
	    If <literal moreinfo="none">--recover</literal> or <literal moreinfo="none">:r</literal>
	    is specified, the parser tries to recover from possible 
	    syntax errors when parsing the resulting XML.
	  </para>
	  <para>
	    <literal moreinfo="none">--keep-blanks</literal> or <literal moreinfo="none">:b</literal>
	    option may be used to force the parser to
	    include ignorable white space.
	  </para>
	  <para>If the result saved
	    by the editor is empty, the interactive
	    XSH2 shell asks user to confirm this was correct.
	    This confirmation can be suppressed using
	    <literal moreinfo="none">--allow-empty</literal> or
	    <literal moreinfo="none">:0</literal> (zero) options.
	  </para>
	  <para>
	    The <literal moreinfo="none">--encoding</literal> or <literal moreinfo="none">:e</literal>
	    parameter can be used to specify character encoding to
	    use when communicating with the external editor.
	  </para>
	  <example>
	    <title>Edit all chapter elements (one by one) with emacs</title>
	    <programlisting format="linespecific">edit --editor 'emacs -nw' --encoding iso-8859-1 --all //chapter</programlisting>
	  </example>
	</simplesect></section><section id="edit_string_command" role="command"><title>edit-string</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">edit-string [--editor|:E <link linkend="filename">filename</link>] 
	  [--encoding|:e <link linkend="enc_string">encoding</link>]
	  [--allow-empty|:0] <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Evaluating given <link linkend="exp">expression</link> to a string,
	    save it in a temporary file,
	    open the file an external editor as a plain text,
	    and when the editor exits,
	    read and return the result. The <literal moreinfo="none">--editor</literal>
	    (<literal moreinfo="none">:E</literal>) parameter can be used
	    to provide an editor command, whereas
	    <literal moreinfo="none">--encoding</literal> (<literal moreinfo="none">:e</literal>)
	    can be used to specify character encoding used for
	    communication with the editor. If the result
	    is empty, the interactive XSH2 shell asks user for
	    confirmation before returning the result in order
	    to prevent data loss due to some unexpected error.
	    To suppress this feature, use <literal moreinfo="none">--allow-empty</literal>
	    or <literal moreinfo="none">:0</literal> flag.
	  </para>
	</simplesect></section><section id="empty_tags" role="command"><title>empty-tags</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">empty-tags <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> empty_tags</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>If the value of <link linkend="exp">expression</link> is 1
	    (non-zero), empty tags are serialized as a
	    start-tag/end-tag pair
	    (<literal moreinfo="none">&lt;foo&gt;&lt;/foo&gt;</literal>).  This option
	    affects both <link linkend="list_command">ls</link> and <link linkend="save_command">save</link> and possibly other
	    commands. Otherwise, they are compacted into a short-tag
	    form (<literal moreinfo="none">&lt;foo/&gt;</literal>). Default value is
	    <literal moreinfo="none">0</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$EMPTY_TAGS</literal> variable.</para>
	</simplesect></section><section id="print_enc_command" role="command"><title>enc</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">enc [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Print the original document encoding string.
	    If no <link linkend="document">document</link> is given, the current document is
	    used.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="set_enc_command">set-enc</link></para></simplesect></section><section id="encoding" role="command"><title>encoding</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">encoding <link linkend="enc_string">encoding</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Set the default character encoding used
	    for standard (e.g. terminal) output. This doesn't influence
	    the encoding used for saving XML documents.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$ENCODING</literal> variable.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="query_encoding">query-encoding</link></para></simplesect></section><section id="eval_command" role="command"><title>eval</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">eval <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>NOTE: This command has very different behavior from XSH1,
	    where it used to be an alias for <link linkend="perl_command">perl</link>.
	  </para>
	  <para>This command first evaluates a given <link linkend="exp">expression</link> to obtain a string,
	    then evaluates this string as XSH2 code in the current context, returning
	    the return value of the last evaluated command.
	    This command raises
	    an exception if either <link linkend="exp">expression</link> evaluates to
	    invalid XSH2 code or if evaluating the code raises an exception.
	  </para>
	  <example>
	    <title>Evaluate "in-line" XSH snippets within a XML document</title>
	    <programlisting format="linespecific">foreach //inline-xsh eval .;</programlisting>
	  </example>
	</simplesect></section><section id="exec_command" role="command"><title>exec</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">exec <link linkend="exp">expression</link> [<link linkend="exp">expression</link> ...]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> system</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>This command executes given <link linkend="exp">expression</link>(s)
	    as a system command and returns the exit code.
	  </para>
	  <example>
	    <title>Count words in "hallo wold" string, then print name
	      of your machine's operating system.</title>
	    <programlisting format="linespecific">exec echo hallo world;             # prints hallo world
exec "echo hallo word" | wc;       # counts words in hallo world
exec uname;                        # prints operating system name
</programlisting>
	  </example>
	</simplesect></section><section id="exit_command" role="command"><title>exit</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">exit [<link linkend="exp">expression</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> quit</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Exit xsh, optionally with an exit-code
	    resulting from evaluation of a given <link linkend="exp">expression</link>.
	  </para>
	  <para>
	    WARNING: No files are saved on exit.
	  </para>
	</simplesect></section><section id="fold_command" role="command"><title>fold</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">fold [--depth|:d <link linkend="exp">expression</link>] [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This feature is still EXPERIMENTAL and
	    may change in the future! 
	    Fold command may be used to
	    mark elements with a
	    <literal moreinfo="none">xsh:fold</literal> attribute from the
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal> namespace. 
	    When
	    listing the DOM tree using 
	    <literal moreinfo="none"><link linkend="list_command">ls</link> --fold <link linkend="xpath">xpath</link></literal>, 
	    elements marked in this
	    way are folded to a given depth (default is 0 = fold immediately).
	  </para>
	  <para>
	    The option <literal moreinfo="none">--depth</literal> (<literal moreinfo="none">:d</literal>)
	    may be used to specify the depth at which
	    subtrees of given elements are to be folded.
	  </para>
	  <para>
	    If called without arguments,
	    the command applies to the current element,
	    otherwise the <link linkend="exp">expression</link> is evaluated to the node-list
	    and folding is applied to all elements within this node-list.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">fold --depth 1 //chapter</userinput>
xsh&gt; <userinput moreinfo="none">ls --fold  //chapter[1]</userinput>
&lt;chapter id="intro" xsh:fold="1"&gt;
  &lt;title&gt;...&lt;/title&gt;
  &lt;para&gt;...&lt;/para&gt;
  &lt;para&gt;...&lt;/para&gt;
&lt;/chapter&gt;
</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="unfold_command">unfold</link>, <link linkend="list_command">ls</link></para></simplesect></section><section id="foreach" role="command"><title>foreach</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">foreach <link linkend="exp">expression</link> 
	  <link linkend="command">command</link>|<link linkend="block">block</link>
	</literal><literal moreinfo="none">foreach [my|local] <link linkend="varname">$variable</link> in <link linkend="exp">expression</link>
	  <link linkend="command">command</link>|<link linkend="block">block</link>
	</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> for</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Evaluate given <link linkend="exp">expression</link> to a node-list and for each
	    resulting node execute given <link linkend="command">command</link> or 
	    <link linkend="block">block</link>. If used without a loop <link linkend="varname">$variable</link>, the loop temporarily sets current node to
	    the node being processed. Otherwise, the processed node is assigned
	    to the loop variable.
	  </para>
	  <para>
	    The <link linkend="exp">expression</link> may be <link linkend="xpath">xpath</link> as well as
	    a <link linkend="perl_code">perl-code</link>.
	    In the latter case, if used without a loop variable, 
	    the loop automatically converts Perl objects to
	    nodes. No conversion is performed when
	    a loop variable is used.
	  </para>
	  <example>
	    <title>Move all employee sub-elements in a company element
	      into the first staff subelement of the same company</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">foreach //company xmove employee into staff[1];</userinput></programlisting>
	  </example>
	  <example>
	    <title>List content of all XML files in current directory</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">foreach my $filename in { glob('*.xml') } {
  $f := open $filename;
  do_something $f; 
}</userinput>
</programlisting>
	  </example>
	</simplesect></section><section id="expression_command" role="command"><title>get</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">get <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> exp, expr</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Calculate a given <link linkend="exp">expression</link> and return the value.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="count_command">count</link></para></simplesect></section><section id="hash_command" role="command"><title>hash</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$hash := hash <link linkend="exp">expression</link> <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command takes two arguments: an expression computing
	    a key from a given node (1st argument) and a node-set (2nd
	    argument). For each node in the node-set, the key value is
	    computed and the node is stored under the given key in
	    the resulting hash. For a given key, the value stored
	    in the hash table is a node-list consisting of all nodes
	    for which the 1st expression evaluated to an object
	    string-wise equal to the key. It is therefore possible to
	    index more than one node under the same key.
	  </para>
	  <para>
	    The XPath function
	    <literal moreinfo="none">xsh:lookup(varname,key)</literal> can
            be used to retrieve values from hashes in XPath expressions.
	  </para>
	  <example>
	    <title>Index books by author</title>
	    <programlisting format="linespecific">my $books_by_author := hash concat(author/firstname," ",author/surname) //book;</programlisting>
	  </example>
	  <example>
	    <title>Lookup books by Jack London.</title>
	    <programlisting format="linespecific">ls { $books_by_author-&gt;{'Jack London'} };
ls xsh:lookup('books_by_author','Jack London');</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="lookup_function">xsh:lookup</link></para></simplesect></section><section id="help_command" role="command"><title>help</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">help <link linkend="command">command</link>|argument-type|xsh:xpath-function</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Print help on a given command, argument type or
	    XPath extension function 
	    (use <literal moreinfo="none">xsh:</literal> as a prefix to XPath extensions
	    function names, e.g <literal moreinfo="none">help xsh:id2</literal>).
	  </para>
	</simplesect></section><section id="if" role="command"><title>if</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">if <link linkend="exp">expression</link> <link linkend="command">command</link>
	</literal><literal moreinfo="none">
          if <link linkend="exp">expression</link>
	  <link linkend="block">block</link> [ elsif <link linkend="block">block</link> ]* [ else <link linkend="block">block</link> ]
	</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Executes <link linkend="command">command</link> or <link linkend="block">block</link> if a given <link linkend="exp">expression</link>
	    expression evaluates to a non-emtpty node-list, true
	    boolean-value, non-zero number or non-empty literal. If
	    the first expression fails, then 
	    <literal moreinfo="none">elsif</literal> conditions are tested (if any) and the
	    <link linkend="block">block</link> corresponding to the first one of
	    them which is true is executed. If none of the conditions is satisfied, an
	    optional <literal moreinfo="none">else</literal> <link linkend="block">block</link> is executed.
	  </para>
	  <example>
	    <title>Display node type</title>
	    <programlisting format="linespecific">def node_type %n {
  foreach (%n) {
    if ( . = self::* ) { # XPath trick to check if . is an element
      echo 'element';
    } elsif ( . = ../@* ) { # XPath trick to check if . is an attribute
      echo 'attribute';
    } elsif ( . = ../processing-instruction() ) {
      echo 'pi';
    } elsif ( . = ../text() ) {
      echo 'text';
    } elsif ( . = ../comment() ) {
      echo 'comment'
    } else { # well, this should not happen, but anyway, ...
      echo 'unknown-type';
    }
  }
}
</programlisting>
	  </example>
	  <example>
	    <title>Check a environment variable</title>
	    <programlisting format="linespecific">if { defined($ENV{HOME}) } lcd { $ENV{HOME} }</programlisting>
	  </example>
	</simplesect></section><section id="ifinclude_command" role="command"><title>ifinclude</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">ifinclude [--encoding|:e <link linkend="enc_string">encoding</link>] <link linkend="filename">filename</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Unless the file <link linkend="filename">filename</link> has already
	    been included using either <link linkend="include_command">include</link> of
	    <link linkend="ifinclude_command">ifinclude</link>, load the file and
	    execute it as a XSH2 script.
	  </para>
	  <para>Use <literal moreinfo="none">--encoding</literal> or <literal moreinfo="none">:e</literal>
	    parameter to specify character encoding used in
	    the included file.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="include_command">include</link></para></simplesect></section><section id="include_command" role="command"><title>include</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">include [--encoding|:e <link linkend="enc_string">encoding</link>] <link linkend="filename">filename</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> .</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Load a file named <link linkend="filename">filename</link> and execute it as a XSH2
	    script.
	  </para>
	  <para>Use <literal moreinfo="none">--encoding</literal> or <literal moreinfo="none">:e</literal>
	    parameter to specify character encoding used in
	    the included file.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="ifinclude_command">ifinclude</link></para></simplesect></section><section id="indent" role="command"><title>indent</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">indent <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>If the value of <link linkend="exp">expression</link> is 1,
	    saved and listed XML will be formatted
	    using some (hopefully) ignorable whitespace. 
	    If the value is 2 (or
	    higher), XSH2 will act as in case of 1, plus it will add a
	    leading and a trailing linebreak to each text node.
	  </para>
	  <para>Note, that since the underlying C library
	    (libxml2) uses a hard-coded indentation of 2 space
	    characters per indentation level, the amount of
	    whitespace used for indentation can not be
	    altered at runtime.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$INDENT</literal> variable.</para>
	</simplesect></section><section id="index_command" role="command"><title>index</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">index [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command makes <literal moreinfo="none">libxml2</literal> library to remember
	    document-order position of every element node in the <link linkend="document">document</link>. Such indexation makes XPath queries
	    considerably faster on large documents (with thousands of nodes).
	    The command should only be used on documents which don't change;
	    modifying an indexed document might possibly lead to non-conformant
	    behavior of later XPath queries on the document.
	  </para>
	</simplesect></section><section id="insert_command" role="command"><title>insert</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">insert [--namespace|:n <link linkend="exp">expression</link>] <link linkend="nodetype">node-type</link> <link linkend="exp">expression</link> <link linkend="loc">location</link> <link linkend="xpath">xpath</link>
	</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> add</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Works just like <link linkend="xinsert_command">xinsert</link>, 
	    except that the new node is attached
	    only the first node matched.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="xinsert_command">xinsert</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link></para></simplesect></section><section id="iterate" role="command"><title>iterate</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">iterate <link linkend="xpath">xpath</link> <link linkend="block">block</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Iterate works very much like a <link linkend="foreach">foreach</link> loop with the
	    same <link linkend="xpath">xpath</link> expression, except that it
	    evaluates the <link linkend="block">block</link> as soon as a new node
	    matching a given <link linkend="xpath">xpath</link> is found. As a
	    limitation, an <link linkend="xpath">xpath</link> expression
	    used with <literal moreinfo="none">iterate</literal> may consist of one XPath
	    step only, i.e. it may not contain an XPath step separator
	    <literal moreinfo="none">/</literal>.
	  </para>
	  <para>
	    A possible benefit of using <literal moreinfo="none">iterate</literal> instead of
	    <link linkend="foreach">foreach</link> is some efficiency when
	    iterating over huge node-sets. Since
	    <literal moreinfo="none">iterate</literal> doesn't compute
	    the resulting node-set in advance, it
	    doesn't have to 1) allocate extra memory for it
	    and 2) (more importantly) doesn't have to sort
	    the node-list in the document order (which
	    tends to be slow on large node-sets, unless
	    <link linkend="index_command">index</link> is used). On the other
	    hand, <literal moreinfo="none">iterate</literal> suffers from a considerable
	    speed penalty since it isn't implemented in C (unlike
	    libxml2's XPath engine).
	  </para>
	  <para>
	    Author's experience shows that, unless <link linkend="index_command">index</link>
	    is used, <literal moreinfo="none">iterate</literal> beats
	    <link linkend="foreach">foreach</link> in speed on large
	    node-lists (&gt;=1500 nodes, but your milage may vary) while
	    <link linkend="foreach">foreach</link> wins on smaller node-lists.
	  </para>
	  <para>The following two examples give equivalent results.
	    However, the one using <literal moreinfo="none">iterate</literal> 
	    may be faster if the number of nodes being counted 
	    is huge and document order isn't indexed.</para>
	  <example>
	    <title>Count inhabitants of the kingdom of Rohan in productive age</title>
	    <programlisting format="linespecific">cd rohan/inhabitants;</programlisting>
	    <programlisting format="linespecific">iterate child::*[@age&gt;=18 and @age&lt;60] { perl $productive++ };</programlisting>
	    <programlisting format="linespecific">echo "$productive inhabitants in productive age";</programlisting>
	  </example>
	  <example>
	    <title>Using XPath</title>
	    <programlisting format="linespecific">$productive=count(rohan/inhabitants/*[@age&gt;=18 and @age&lt;60]);</programlisting>
	    <programlisting format="linespecific">echo "$productive inhabitants in productive age";</programlisting>
	  </example>
	  <para>
	    Hint: use e.g. <literal moreinfo="none">| time cut</literal> pipe-line
	    redirection to benchmark a XSH2 command on a UNIX system.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="foreach">foreach</link>, <link linkend="index_command">index</link>, <link linkend="next_command">next</link>, <link linkend="prev_command">prev</link>, <link linkend="last_command">last</link></para></simplesect></section><section id="keep_blanks" role="command"><title>keep-blanks</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">keep-blanks <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> keep_blanks</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Allows you to turn on/off preserving the parser's default
	    behavior of preserving all whitespace in the document.
	    Setting this option to 0, instructs the XML parser
	    to ignore whitespace occurring between adjacent element
	    nodes, so that no extra text nodes are created for it.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$KEEP_BLANKS</literal> variable.</para>
	</simplesect></section><section id="last_command" role="command"><title>last</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">last [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    The <literal moreinfo="none">last</literal> command is like the break
	    statement in C (as used in loops); it immediately exits an
	    enclosing loop. The optional <link linkend="exp">expression</link>
	    argument may evaluate to a positive integer number that
	    indicates which level of the nested loops to quit. If this
	    argument is omitted, it defaults to 1, i.e. the innermost
	    loop.
	  </para>
	  <para>
	    Using this command outside a loop causes an
	    immediate run-time error.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="foreach">foreach</link>, <link linkend="while">while</link>, <link linkend="iterate">iterate</link>, <link linkend="next_command">next</link>, <link linkend="last_command">last</link></para></simplesect></section><section id="cd_command" role="command"><title>lcd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">lcd <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> chdir</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Changes the filesystem working directory 
	    to <link linkend="exp">expression</link>, if possible.  
	    If <link linkend="exp">expression</link> is omitted, changes to the directory
	    specified in HOME environment variable, if set; if not,
	    changes to the directory specified by LOGDIR environment
	    variable.
	  </para>
	</simplesect></section><section id="lineno_command" role="command"><title>lineno</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">lineno [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    <literal moreinfo="none">lineno</literal>
	    command prints line numbers of
	    all nodes in a given node-list. Note however, that
	    <literal moreinfo="none">libxml2</literal>
	    only stores line number information for element nodes.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="locate_command">locate</link></para></simplesect></section><section id="load_ext_dtd" role="command"><title>load-ext-dtd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">load-ext-dtd <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> load_ext_dtd</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Non-zero <link linkend="exp">expression</link> instructs 
	    the XML parser to load external DTD
	    subsets declared in XML documents. 
	    This option is enabled by default.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$LOAD_EXT_DTD</literal> variable.</para>
	</simplesect></section><section id="local_command" role="command"><title>local</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">local <link linkend="varname">$variable</link> = <link linkend="xpath">xpath</link></literal><literal moreinfo="none">local <link linkend="varname">$variable</link> [ <link linkend="varname">$variable</link> ... ] </literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para> 
	    This command acts in a very similar way as
	    <link linkend="assign_command">assign</link> does, except
	    that the variable assignment is done temporarily
	    and lasts only for the rest of its enclosing
	    <link linkend="block">block</link> or subroutine. At the end of the
	    enclosing block or subroutine, the original value
	    is restored. This also reverts any later usual assignments to the
	    variable done occurring before the end of the block.
	    This command may also be used without the assignment part.
	  </para>
	  <para>Note, that the variable itself remains
	    global in the sense that it is still visible to any
	    subroutine called subsequently from the same block.
	    Unlike <link linkend="my_command">my</link>
	    declaration, it does not <emphasis>create</emphasis> a
	    new lexically scoped variable.
	  </para>
	  <para>
	    Hint for Perl programmers: <literal moreinfo="none">local</literal>
	    in XSH2 works exactly as <literal moreinfo="none">local</literal>
	    in Perl.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="assign_command">assign</link>, <link linkend="my_command">my</link>, <link linkend="def">def</link></para></simplesect></section><section id="locate_command" role="command"><title>locate</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">locate [--id|:i] <link linkend="xpath">xpath</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Print canonical XPaths leading to nodes matched by
	    a given <link linkend="xpath">xpath</link>.</para>
	  <para>
	    If flag <literal moreinfo="none">--id</literal> (<literal moreinfo="none">:i</literal>) is
	    used then ID-based shortcuts are allowed in the resulting
	    location paths. That means that if the node or some of its
	    ancestors has an ID attribute (either
	    <literal moreinfo="none">xml:id</literal> or one specified in a DTD) then
	    the corresponding segment of the canonical location path
	    is replaced by the <literal moreinfo="none">id()</literal> function
	    which jumps directly to an element based on its ID.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="pwd_command">pwd</link></para></simplesect></section><section id="list_command" role="command"><title>ls</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">ls [--fold|:f] [--fold-attrs|:A] [--indent|:i | --no-indent|:I]
	  [--depth|:d <link linkend="exp">expression</link>] [<link linkend="exp">expression</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> list</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Print XML representation of a given
	    <link linkend="exp">expression</link>, in particular,
	    if used with an <link linkend="xpath">xpath</link>,
	    list parts of the document matching given expression.
	  </para>
	  <para>
	    If used without an argument,
	    current node is listed to the depth 1 (see below).
	  </para>
	  <para>
	    <literal moreinfo="none">--depth</literal> or <literal moreinfo="none">:d</literal>
	    argument may be used to specify depth of the XML listing.
	    If negative, the listing depth is unlimited.
	    All content below the specified depth is replaced with
	    an ellipsis (<literal moreinfo="none">...</literal>).
	  </para>
	  <para>
	    <literal moreinfo="none">--fold</literal> or <literal moreinfo="none">:f</literal>
	    option makes the listing fold elements marked using the
	    <link linkend="fold_command">fold</link> command are folded, i.e. listed
	    only to the depth specified in the folding mark.
	  </para>
	  <para>
	    <literal moreinfo="none">--fold-attrs</literal> or <literal moreinfo="none">:A</literal>
	    option avoids listing of attributes of the folded
	    elements (i.e. elements on the lowest level of listing).
	    Folded attributes are replaced with
	    ellipsis (<literal moreinfo="none">...</literal>).
	  </para>
	  <para>
	    <literal moreinfo="none">--indent</literal> (<literal moreinfo="none">:i</literal>)
	    and 
	    <literal moreinfo="none">--no-indent</literal> (<literal moreinfo="none">:I</literal>)
	    may be used to enforce/suppress
	    indentation, overriding current setting
	    (see command <link linkend="indent">indent</link>).
	  </para>
	  <para>
	    Unless in <link linkend="quiet">quiet</link> mode, 
	    this command also prints the number of
	    (top-level) nodes listed.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="count_command">count</link>, <link linkend="fold_command">fold</link>, <link linkend="unfold_command">unfold</link></para></simplesect></section><section id="map_command" role="command"><title>map</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">map <link linkend="exp">expression</link> <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    NOTE: THE SEMANTICS OF COMMAND HAS CHANGED IN 2.1.0
	  </para>
	  <para>
	    This command provides an easy way to transform node's data
	    (content) using arbitrary expression.
	    It takes two arguments: a mapping expression
	    and a node-list.
	  </para>
	  <para>
	    First the second argument is evaluated to a node-list.
	    For each of the nodes,
	    the mapping expression is evaluated 
	    and the result is used to replace the original content
	    of the node. 
	    The node is made the context node for the time
	    of evaluation of the mapping expression.
	    Moreover, if the expression is a Perl code,
	    it gets the original text content in 
	    the variable <literal moreinfo="none">$_</literal>.
	  </para>
	  <para>
	    Note that if the processed node is an element
	    than the mapping expression may even produce nodes
	    which are then copied into the element discarding
	    any previous content of the element.
	  </para>
	  <para>
	    If the mapping expression returns an undefined value
	    for a node, then its content is kept untouched.
	  </para>
	  <para>
	    <literal moreinfo="none">--in-place</literal> (<literal moreinfo="none">:i</literal>) flag:
	    if the expression is a Perl code, then
	    it is sometimes convenient to change the value
	    in place. In that case use this flag to indicate that the result
	    should to be taken from the <literal moreinfo="none">$_</literal> variable
	    rather than from the value of the expression itself.
	    Without this flag, <literal moreinfo="none">$_</literal> is read-only.
	  </para>
	  <para>
	    <literal moreinfo="none">--reverse</literal> (<literal moreinfo="none">:r</literal>) flag
	    instruct the map to process the nodelist
	    in reversed order.
	  </para>
	  <example>
	    <title>Capitalizes all hobbit names</title>
	    <programlisting format="linespecific">map { ucfirst($_) } //hobbit/@name;</programlisting>	  
	  </example>
	  <example>
	    <title>Changes Goblins to Orcs in all hobbit tales (\b matches word boundary).</title>
	    <programlisting format="linespecific">map :i { s/\bgoblin\b/orc/gi } //hobbit/tale/text();</programlisting>
	  </example>
	  <example>
	    <title>Recompute column sums in the last row of row-oriented table</title>
	    <programlisting format="linespecific">map sum(/table/row[position()&lt;last()]/
cell[count(xsh:current()/preceding-sibling::cell)+1])
/table/row[last()]/cell;</programlisting>
	  </example>
	  <example>
	    <title>The following commands do all about the same:</title>
	    <programlisting format="linespecific">wrap --inner Z //*;
map --reverse xsh:parse(concat("&lt;Z&gt;",xsh:serialize(node()),"&lt;/Z&gt;")) //*;
map xsh:parse(concat("&lt;Z&gt;",xsh:serialize(node()),"&lt;/Z&gt;")) { reverse xpath('//*') };
</programlisting>
	  </example>
	  <para>Note that in the last example we use
	    <literal moreinfo="none">:r</literal> (or Perl <literal moreinfo="none">reverse</literal>
	    function) to reverse the node list order so that child
	    nodes get processed before their parents. Otherwise, the child
	    nodes would be replaced by parent's new content before the
	    processing could reach them.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="rename_command">rename</link></para></simplesect></section><section id="move_command" role="command"><title>move</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">move <link linkend="xpath">xpath</link> <link linkend="loc">location</link> <link linkend="xpath">xpath</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> mv</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para><literal moreinfo="none">move</literal> command acts exactly like
	      <link linkend="copy_command">copy</link>, except that it
	      <emphasis>removes</emphasis> the source nodes after a
	      successful copy. Remember that the moved nodes are
	      actually <emphasis>different nodes</emphasis> from the
	      original ones (which may not be obvious when moving
	      nodes within a single document into locations that do
	      not require type conversion). So, after the move, the
	      original nodes don't belong to any document
	      and are automatically destroyed unless some
	      variable still contains to them.
	  </para>
	  <para>
	    This command returns a node-list consisting of nodes
	    it created on the target locations.
	  </para>
	  <para>
	    See <link linkend="copy_command">copy</link> for more details on how
	    the copies of the moved nodes are created.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="xmove_command">xmove</link>, <link linkend="copy_command">copy</link>, <link linkend="xcopy_command">xcopy</link>, <link linkend="insert_command">insert</link>, <link linkend="xinsert_command">xinsert</link></para></simplesect></section><section id="my_command" role="command"><title>my</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">my <link linkend="varname">$variable</link> [$var2 ...];</literal><literal moreinfo="none">my <link linkend="varname">$variable</link> = <link linkend="exp">expression</link>;</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Same as in Perl: a "my" declares the listed variables to be local
	    (lexically) to the enclosing block, or sub-routine.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="local_command">local</link></para></simplesect></section><section id="namespaces_command" role="command"><title>namespaces</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">namespaces [--registered|:r] [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    For each node in a given node-list lists
	    all namespaces that are valid the scope of the node.
	    Namespaces are listed in the form of
	    <literal moreinfo="none">xmlns:prefix="uri"</literal> declarations,
	    preceded by a canonical xpath of the corresponding node
	    on a separate line.
	  </para>
	  <para>
	    If <literal moreinfo="none">--registered</literal> or <literal moreinfo="none">:r</literal>
	    flag is used, list also namespaces registered with the
	    <link linkend="registerns_command">register-namespace</link> command
	    in XSH syntax.
	  </para>
	  <para>
	    If called without the <literal moreinfo="none">--registered</literal> flag and
	    no <link linkend="xpath">xpath</link> is given, lists namespaces
	    in the scope of the current node.
	  </para>
	</simplesect></section><section id="next_command" role="command"><title>next</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">next [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    <literal moreinfo="none">next</literal> is like the continue statement in C; it starts the
	    next iteration of an enclosing loop. 
	    The command may be used with an optional argument evaluating
	    to a positive integer number indicating which
	    level of the nested loops should be restarted.
	    If the argument is omitted, it defaults to 1, i.e. the innermost loop.
	  </para>
	  <para>
	    Using this command outside a loop causes an
	    immediate run-time error.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="foreach">foreach</link>, <link linkend="while">while</link>, <link linkend="iterate">iterate</link>, <link linkend="redo_command">redo</link>, <link linkend="last_command">last</link>, <link linkend="prev_command">prev</link></para></simplesect></section><section id="nobackups" role="command"><title>nobackups</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">nobackups</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Disable creating backup files on save.</para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$BACKUPS</literal> variable to 0.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="nobackups">nobackups</link></para></simplesect></section><section id="nodebug" role="command"><title>nodebug</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">nodebug</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Turn off debugging messages.</para>
	  <para>This is equivalent to setting
	    <literal moreinfo="none">$DEBUG</literal> variable to 0.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="debug">debug</link></para></simplesect></section><section id="normalize_command" role="command"><title>normalize</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">normalize <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para><literal moreinfo="none">normalize</literal> 
	    evaluates given <link linkend="exp">expression</link> to a node-list
	    and puts all text nodes in the full depth of the sub-tree
	    underneath each node in the node-list 
	    into a "normal" form where only structure (e.g., elements,
	    comments, processing instructions, CDATA sections, and
	    entity references) separates text nodes, i.e., there are
	    neither adjacent text nodes nor empty text nodes.
	  </para>
	  <para>
	    Note, that most XSH2 commands automatically join adjacent text nodes.
	  </para>
	</simplesect></section><section id="open_command" role="command"><title>open</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$doc := open [--format|:F html|xml|docbook]
          [--file|:f | --pipe|:p | --string|:s]
	  [--switch-to|:w | --no-switch-to|:W]
	  [--validate|:v | --no-validate|:V]
	  [--recover|:r | --no-recover|:R]
	  [--expand-entities|:e | --no-expand-entities|:E]
	  [--xinclude|:x | --no-xinclude|:X]
	  [--keep-blanks|:b  | --no-keep-blanks|:B]
	  [--pedantic|:n | --no-pedantic|:N]
	  [--load-ext-dtd|:d | --no-load-ext-dtd|:D]
	  [--complete-attributes|:a | --no-complete-attributes|:A]
	  <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Parse a XML, HTML or SGML DOCBOOK document from a file or URL,
	    command output or string and return a node-set consisting
	    of the root of the resulting DOM tree.
	  </para>
	  <para><literal moreinfo="none">--format</literal> (<literal moreinfo="none">:F</literal>)
	    option may be used
	    to specify file format. Possible values are
	    <literal moreinfo="none">xml</literal> (default), 
	    <literal moreinfo="none">html</literal>, and 
	    <literal moreinfo="none">docbook</literal>. Note, however,
	    that the support for parsing <literal moreinfo="none">DocBook</literal> SGML
	    files has been deprecated in recent <literal moreinfo="none">libxml2</literal>
	    versions.
	  </para>
	  <para><literal moreinfo="none">--file</literal> (<literal moreinfo="none">:f</literal>)
	    instructs the parser to consider a given <link linkend="exp">expression</link>
	    as a file name or URL.
	  </para>
	  <para>
	    <literal moreinfo="none">--pipe</literal> (<literal moreinfo="none">:p</literal>)
	    instructs the parser to consider a given <link linkend="exp">expression</link>
	    as a system command and parse its output.
	  </para>
	  <para>
	    <literal moreinfo="none">--string</literal> (<literal moreinfo="none">:s</literal>)
	    instructs the parser to consider a given <link linkend="exp">expression</link>
	    as a string of XML or HTML to parse.
	  </para>
	  <para>
	  <literal moreinfo="none">--switch-to</literal> (<literal moreinfo="none">:w</literal>)
	    and <literal moreinfo="none">--no-switch-to</literal> (<literal moreinfo="none">:W</literal>)
	    control whether the new document's root should
	    become current node. These option override
	    current global setting of
	    <link linkend="cdonopen">switch-to-new-documents</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--validate</literal> (<literal moreinfo="none">:v</literal>)
	    and <literal moreinfo="none">--no-validate</literal> (<literal moreinfo="none">:V</literal>)
	    turn on/off DTD-validation of the parsed document.
	    These option override
	    current global setting of
	    <link linkend="validation">validation</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--recover</literal> (<literal moreinfo="none">:r</literal>)
	    and <literal moreinfo="none">--no-recover</literal> (<literal moreinfo="none">:R</literal>)
	    turn on/off parser's ability to recover from
	    non-fatal errors.
	    These option override
	    current global setting of
	    <link linkend="recovering">recovering</link>.	    
	  </para>
          <para>
	  <literal moreinfo="none">--expand-entities</literal> (<literal moreinfo="none">:e</literal>)
	    and <literal moreinfo="none">--no-expand-entities</literal> (<literal moreinfo="none">:E</literal>)
	    turn on/off entity expansion, overriding current global
	    setting of <link linkend="parser_expands_entities">parser-expands-entities</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--xinclude</literal> (<literal moreinfo="none">:x</literal>) and
	    <literal moreinfo="none">--no-xinclude</literal> (<literal moreinfo="none">:X</literal>) turn
	    on/off XInclude processing, overriding current global settings of
	    <link linkend="parser_expands_xinclude">parser-expands-xinclude</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--keep-blanks</literal> (<literal moreinfo="none">:b</literal>) 
	    and <literal moreinfo="none">--no-keep-blanks</literal> (<literal moreinfo="none">:B</literal>)
	    control whether the parser should preserve so called ignorable
	    whitespace. These option override
	    current global setting of <link linkend="keep_blanks">keep-blanks</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--pedantic</literal> (<literal moreinfo="none">:n</literal>)
	    and <literal moreinfo="none">--no-pedantic</literal> (<literal moreinfo="none">:N</literal>)
	    turn on/off pedantic parser flag.
	  </para>
          <para>
	  <literal moreinfo="none">--load-ext-dtd</literal> (<literal moreinfo="none">:d</literal>)
	    and <literal moreinfo="none">--no-load-ext-dtd</literal> (<literal moreinfo="none">:D</literal>)
	    control whether the external DTD subset should be loaded
	    with the document. 
	    These option override
	    current global setting of <link linkend="load_ext_dtd">load-ext-dtd</link>.
	  </para>
          <para>
	  <literal moreinfo="none">--complete-attributes</literal> (<literal moreinfo="none">:a</literal>)
	    and <literal moreinfo="none">--no-complete-attributes</literal>
	    (<literal moreinfo="none">:A</literal>)
	    turn on/off parse-time default attribute completion
	    based on default values specified in the DTD.
	    These option override
	    current global setting of <link linkend="complete_attributes">parser-completes-attributes</link>.	    
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">$scratch/&gt; <userinput moreinfo="none">$x := open mydoc.xml # open an XML document</userinput>

# open a HTML document from the Internet
<userinput moreinfo="none">$h:=open --format html "http://www.google.com/?q=xsh"</userinput>
# quote file name if it contains whitespace
<userinput moreinfo="none">$y := open "document with a long name with spaces.xml"</userinput>

# use --format html or --format docbook to load these types
$z := open --format html <userinput moreinfo="none">index.htm</userinput>

# use --pipe flag to read output of a command
$z := open --format html --pipe <userinput moreinfo="none">'wget -O - xsh.sourceforge.net/index.html'</userinput>

# use document variable to restrict XPath search to a
# given document
<userinput moreinfo="none">ls $z//chapter/title</userinput>
</programlisting>
	  </informalexample>
	</simplesect></section><section id="complete_attributes" role="command"><title>parser-completes-attributes</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">parser-completes-attributes <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> complete_attributes, complete-attributes, parser_completes_attributes</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If the expression is non-zero, the command makes XML parser
	    add missing attributes with default values as specified in 
	    a DTD. By default, this option is enabled.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$PARSER_COMPLETES_ATTRIBUTES</literal> variable.</para>
	</simplesect></section><section id="parser_expands_entities" role="command"><title>parser-expands-entities</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">parser-expands-entities <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> parser_expands_entities</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If the
	    <link linkend="exp">expression</link> is non-zero
	    enable the entity expansion during the parse process; disable it otherwise.
	    If entity expansion is disabled, any external entity references in parsed
	    documents are preserved as references. By default, entity expansion
	    is enabled.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$PARSER_EXPANDS_ENTITIES</literal> variable.</para>
	</simplesect></section><section id="parser_expands_xinclude" role="command"><title>parser-expands-xinclude</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">parser-expands-xinclude <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> parser_expands_xinclude</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If the <link linkend="exp">expression</link> is non-zero, the parser is
	    allowed to expand XInclude tags immediately while parsing the
	    document.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$PARSER_EXPANDS_XINCLUDE</literal> variable.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="process_xinclude_command">process-xinclude</link></para></simplesect></section><section id="pedantic_parser" role="command"><title>pedantic-parser</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">pedantic-parser <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> pedantic_parser</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If you wish, you can make the XML parser little more pedantic by passing
	    a non-zero <link linkend="exp">expression</link> to this command.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$PEDANTIC_PARSER</literal> variable.</para>
	</simplesect></section><section id="perl_command" role="command"><title>perl</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">perl <link linkend="perl_code">perl-code</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Evaluate a given perl expression and return
	    the result.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="count_command">count</link></para></simplesect></section><section id="prev_command" role="command"><title>prev</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">prev [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command is only allowed inside an
	    <literal moreinfo="none">iterate</literal> loop. It returns the iteration
	    one step back, to the previous node on the iterated axis.
	    The optional <link linkend="exp">expression</link> argument may be
	    used to indicate to which level of nested loops the
	    command applies to (default is 1).
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="iterate">iterate</link>, <link linkend="redo_command">redo</link>, <link linkend="last_command">last</link>, <link linkend="next_command">next</link></para></simplesect></section><section id="print_command" role="command"><title>print</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">print [--nonl|:n] [--nospace|:s] [--stderr|:e] <link linkend="exp">expression</link> [<link linkend="exp">expression</link> ...]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> echo</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>Evaluate given expression(s) and print the results
	    (separated by a single space character).
	    Expressions not containing any special characters, such as
	    brackets, quotes, $, or @ are considered as bare words
	    and evaluate to themselves.
	  </para>
	  <para>
	    <literal moreinfo="none">--nonl</literal> or <literal moreinfo="none">:n</literal>
	    can be used to avoid printing a trailing new-line.
	  </para>
	  <para>
	    <literal moreinfo="none">--nospace</literal> or <literal moreinfo="none">:s</literal>
	    suppresses printing additional spaces between individual arguments.
	  </para>
	  <para>
	    <literal moreinfo="none">--stderr</literal> or <literal moreinfo="none">:e</literal>
	    causes the command to print on standard error output.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">print foo   bar;  # prints "foo bar"</programlisting>
	    <programlisting format="linespecific">print "foo   bar";  # prints "foo   bar"</programlisting>
	  </informalexample>
	</simplesect></section><section id="process_xinclude_command" role="command"><title>process-xinclude</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">process-xinclude [<link linkend="document">document</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> process_xinclude, process-xincludes, process_xincludes, xinclude, xincludes, load_xincludes, load-xincludes, load_xinclude, load-xinclude</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Replace any xinclude tags in a given <link linkend="document">document</link>
	    with the corresponding content. See
	    <ulink url="http://www.w3.org/TR/xinclude/">http://www.w3.org/TR/xinclude/</ulink>
	    to find out more about XInclude technology.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="parser_expands_xinclude">parser-expands-xinclude</link></para></simplesect></section><section id="pwd_command" role="command"><title>pwd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">pwd [--id|:i]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Print XPath leading to the current context node 
	    (equivalent to <literal moreinfo="none">locate .</literal>).
	  </para>
	  <para>
	    If flag <literal moreinfo="none">--id</literal> (<literal moreinfo="none">:i</literal>) is
	    used then ID-based shortcut is allowed in the resulting
	    location path. That means that if the current node or some of its
	    ancestors has an ID attribute (either
	    <literal moreinfo="none">xml:id</literal> or one specified in a DTD) then
	    the corresponding segment of the canonical location path
	    is replaced by the <literal moreinfo="none">id()</literal> function
	    which jumps directly to an element based on its ID.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="locate_command">locate</link>, <link linkend="path_function">xsh:path</link></para></simplesect></section><section id="query_encoding" role="command"><title>query-encoding</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">query-encoding <link linkend="enc_string">encoding</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> query_encoding</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>Set the default query character encoding, i.e.
	    encoding used when taking input from XSH2 prompt or standard input.</para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$QUERY_ENCODING</literal> variable.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="encoding">encoding</link></para></simplesect></section><section id="quiet" role="command"><title>quiet</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">quiet</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Turn off verbose messages.</para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$QUIET</literal> variable.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="verbose">verbose</link></para></simplesect></section><section id="recovering" role="command"><title>recovering</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">recovering <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If the <link linkend="exp">expression</link> evaluates to non-zero value,
	    turn on the recovering parser mode on; turn it off otherwise.
	    Defaults to off.</para>
	  <para>Note, that the in the recovering mode,
            validation is not performed by the parser even if
	    the validation flag is on.
	  </para>
	  <para>The recover mode helps to efficiently recover
	  documents that are almost well-formed. This for example
	  includes documents without a close tag for the document
	  element (or any other element inside the document).</para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$RECOVERING</literal> variable.</para>
	</simplesect></section><section id="redo_command" role="command"><title>redo</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">redo [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    <literal moreinfo="none">redo</literal> restarts a loop block without evaluating
	    the conditional again. The optional <link linkend="exp">expression</link> argument
	    may evaluate to a positive integer number that indicates which
	    level of the nested loops should be restarted. If omitted, it
	    defaults to 1, i.e. the innermost loop.
	  </para>
	  <para>
	    Using this command outside a loop causes an immediate
	    run-time error.
	  </para>
	  <example>
	    <title>Restart a higher level loop from an inner one</title>
	    <programlisting format="linespecific">while ($i&lt;100) { 
  # ...
  foreach //para {
    # some code
    if $param { 
      redo; # redo foreach loop
    } else {
      redo 2; # redo while loop
    }
  }
}
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="foreach">foreach</link>, <link linkend="while">while</link>, <link linkend="iterate">iterate</link>, <link linkend="next_command">next</link>, <link linkend="last_command">last</link></para></simplesect></section><section id="registerfunc_command" role="command"><title>register-function</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">register-function <link linkend="exp">expression</link> <link linkend="perl_code">perl-code</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> function, regfunc</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    EXPERIMENTAL! 
	  </para>
	  <para>Registers a given perl code as a new XPath
	    extension function under a name provided in the first
	    argument. XML::LibXML DOM
	    API as well as all Perl functions
	    pre-defined in the XML::XSH2::Map namespace
	    may be used in the perl code for object processing. If
	    the name contains a colon, then the first part before the
	    colon must be a registered namespace prefix 
	    (see <link linkend="registerns_command">register-namespace</link>) and the function is
	    registered within the corresponding namespace.
	  </para>
	</simplesect></section><section id="registerns_command" role="command"><title>register-namespace</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">register-namespace <link linkend="exp">expression</link> <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> regns</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
             Registers the first argument
             as a prefix for the namespace given in the second argument.
             The prefix can later be used in XPath expressions.
	  </para>
	</simplesect></section><section id="registerns_xhtml_command" role="command"><title>register-xhtml-namespace</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">register-xhtml-namespace <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> regns-xhtml</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
             Registers a prefix for the XHTML namespace
	    <literal moreinfo="none">http://www.w3.org/1999/xhtml</literal>.
             The prefix can later be used in XPath expressions.
	  </para>
	</simplesect></section><section id="registerns_xsh_command" role="command"><title>register-xsh-namespace</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">register-xsh-namespace <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> regns-xsh</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Registers a new prefix for the XSH2 namespace <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal>.  The prefix
	    can later be used in XPath expressions.  Note, that XSH2
	    namespace is by default registered with the prefix
	    <literal moreinfo="none">xsh</literal>. This command is thus, in
	    general, useful only when some document uses
	    <literal moreinfo="none">xsh</literal> prefix for a different namespace
	    or if you want a shorter prefix.
	  </para>
	</simplesect></section><section id="prune_command" role="command"><title>remove</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">remove <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> rm, prune, delete, del</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>Unlink all nodes in a given node-list
	    from their respective documents. Nodes, which
	    are neither attached to a document or stored in a variable
	    are automatically garbage-collected.
	  </para>
	  <para>Returns a number of nodes removed.</para>
	  <example>
	    <title>Get rid of all evil creatures.</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">del //creature[@manner='evil']</userinput></programlisting>
	  </example>
	</simplesect></section><section id="rename_command" role="command"><title>rename</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">rename <link linkend="nodename">nodename</link> <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    NOTE: THE SEMANTICS OF COMMAND HAS CHANGED IN 2.1.0
	  </para>
	  <para>
	    This command is very similar to the <link linkend="map_command">map</link>
	    command, except that it operates on nodes' names rather
	    than their content. It changes
	    name of every element, attribute or
	    processing-instruction contained
	    in the node-list specified in the second argument <link linkend="exp">expression</link>, according to the value of the 
	    <link linkend="nodename">nodename</link> expression,
	    which is evaluated in the context of each node in turn.
	  </para>
	  <para>If the <link linkend="nodename">nodename</link> is a Perl
	    expression, then the name of the node is also stored into Perl's
	    <literal moreinfo="none">$_</literal> variable prior to evaluation.
	  </para>
	  <para>The flag <literal moreinfo="none">--in-place</literal> (<literal moreinfo="none">:i</literal>)
	    can be used to indicate that
	    the new name should be collected from the <literal moreinfo="none">$_</literal>
	    variable rather than from the result of the expression itself.
	  </para>
	  <para>
	    The <literal moreinfo="none">--namespace</literal> (<literal moreinfo="none">:n</literal>) argument
	    may be used to provide namespace for the renamed nodes.
	  </para>
	  <para>
	    <literal moreinfo="none">--reverse</literal> (<literal moreinfo="none">:r</literal>) flag
	    instruct the map to process the nodelist
	    in reversed order.
	  </para>
	  <para>Note: if the expression <link linkend="nodename">nodename</link>
	    returns an undefined value for a particular node, the
	    node's original name and namespace are preserved.
	  </para>
	  <example>
	    <title>Renames all Hobbits to Halflings</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">rename halfling //hobbit</userinput></programlisting>
	  </example>
	  <example>
	    <title>Make all elements and attributes uppercase (yack!)</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">rename { uc } (//*|//@*)</userinput></programlisting>	  
	  </example>
	  <example>
	    <title>Substitute dashes with underscores in all node names</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">rename :i { s/-/_/g } (//*|//@*)</userinput></programlisting>	  
	  </example>
	  <example>
	    <title>Make all elements start with the name of their parents</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">rename concat(local-name(parent::*),'.',local-name(.)) //*[parent::*]</userinput></programlisting>	  
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="map_command">map</link></para></simplesect></section><section id="return_command" role="command"><title>return</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">return [<link linkend="exp">expression</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command immediately stops the execution of a
	    procedure it occurs in and returns the execution to the
	    place of the script from which the subroutine was called.
	    Optional argument may be used as a return value for the
	    subroutine call.
	  </para>
	  <para>
	    Using this command outside a subroutine causes an
	    immediate run-time error.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="def">def</link>, <link linkend="call_command">call</link></para></simplesect></section><section id="run_mode" role="command"><title>run-mode</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">run-mode</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> run_mode</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Switch from the <link linkend="test_mode">test-mode</link> back
	    to the normal execution mode.
	  </para>
	  <para>This is equivalent to setting
	    <literal moreinfo="none">$TEST_MODE</literal> variable to 0.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="test_mode">test-mode</link></para></simplesect></section><section id="save_command" role="command"><title>save</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">save [--format|:F html|xml] [--xinclude|:x] 
	  [--file|:f <link linkend="filename">filename</link> | 
           --pipe|:p <link linkend="filename">filename</link> | 
           --string|:s |
           --print|:r ]
          [--subtree|:S]
          [--indent|:i | --no-indent|:I]
	  [--skip-dtd|:d | --no-skip-dtd|:D]
	  [--skip-empty-tags|:t | --no-skip-empty-tags|:T]
	  [--skip-xmldecl|:x]
          [--encoding|:e <link linkend="enc_string">encoding</link>] 
	  <link linkend="document">document</link>
	</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This takes a given <link linkend="document">document</link>,
	    serializes it to XML or HTML and
	    either saves the result
	    to its original file or another file (default),
	    pipes it to an external command,
	    prints it on standard output, or
	    simply returns it. Without arguments
	    it simply saves current document
	    to its original file.
	  </para>
	  <para>
	    <literal moreinfo="none">--file|:f</literal> option
	    may be used to specify an output file-name.
	    By default, the original document's file-name
	    is used.
	  </para>
	  <para>
	    <literal moreinfo="none">--pipe|:p</literal> option
	    specifies, that the output should be
	    piped to an external command
	    specified as the option's argument.
	  </para>
	  <para>
	    <literal moreinfo="none">--print|:r</literal> option
	    specifies, that the output should 
	    be printed on standard output.</para>
	  <para>
	    <literal moreinfo="none">--string|:s</literal>
	    option specifies, that the output
	    should be returned by the command
	    as a string. In this case, the result is
	    always in UTF8, regardless on which
	    encoding is specified in the document
	    or using <literal moreinfo="none">--encoding</literal> option.
	  </para>
	  <para>The above four options are mutually exclusive.</para>
	  <para>
	    <literal moreinfo="none">--format</literal> option may be used
	    to specify the output format. It's argument
	    should be either <literal moreinfo="none">xml</literal>,
	    <literal moreinfo="none">html</literal> or an expression
	    evaluating to one of these. If not specified,
	    XML output is assumed.
	    Note, that a document should be saved as HTML only if it
	    actually is a HTML document, otherwise the result would be 
	    an invalid XML instance. Note also, that the optional
	    encoding parameter only forces character conversion; it is
	    up to the user to declare the document encoding in the
	    appropriate HTML &lt;META&gt; tag, if needed.
	  </para>
	  <para>
	    <literal moreinfo="none">--xinclude</literal>
	    automatically implies XML format and
	    can be used to force XSH2 to save all already expanded
	    XInclude sections back to their original files while
	    replacing them with &lt;xi:include&gt; tags in the main
	    XML file. Moreover, all material included within
	    &lt;include&gt; elements from the
	    <ulink url="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</ulink>
	    namespace is saved to separate files too according to the
	    <literal moreinfo="none">href</literal> attribute, leaving only empty
	    &lt;include&gt; element in the root file. This feature may
	    be used to split the document to a new set of XInclude fragments.
	  </para>
	  <para>
	    If the <literal moreinfo="none">--subtree</literal> (<literal moreinfo="none">:S</literal>)
	    flag is used, only the subtree of the
	    specified node is saved instead of the complete document
	    (this flag cannot be used
	    with <literal moreinfo="none">--html</literal> format).
          </para>
	  <para>
	    <literal moreinfo="none">--indent</literal> (<literal moreinfo="none">:i</literal>)
	    and 
	    <literal moreinfo="none">--no-indent</literal> (<literal moreinfo="none">:I</literal>)
	    may be used to enforce/suppress
	    indentation, overriding current global setting
	    of <link linkend="indent">indent</link>.
	  </para>
	  <para>
	    <literal moreinfo="none">--skip-dtd</literal> (<literal moreinfo="none">:d</literal>)
	    and 
	    <literal moreinfo="none">--no-skip-dtd</literal> (<literal moreinfo="none">:D</literal>)
	    may be used to enforce/suppress
	    skipping DTD declaration and internal subset
	    on output, overriding current global setting
	    of <link linkend="skip_dtd">skip-dtd</link>.
	  </para>
	  <para>
	    <literal moreinfo="none">--empty-tags</literal> (<literal moreinfo="none">:t</literal>)
	    and 
	    <literal moreinfo="none">--no-empty-tags</literal> (<literal moreinfo="none">:T</literal>)
	    may be used to override current global setting
	    of <link linkend="empty_tags">empty-tags</link>.
	    <literal moreinfo="none">--no-empty-tags</literal> instructs XSH2
	    to serialize elements with no child nodes
	    as start-tag/end-tag pair
	    <literal moreinfo="none">&lt;element&gt;&lt;/element&gt;</literal>
	    instead of using a short empty-tag form
	    <literal moreinfo="none">&lt;element/&gt;</literal>.
	  </para>
	  <para>
	    <literal moreinfo="none">--skip-xmldecl</literal> (<literal moreinfo="none">:x</literal>)
	    instructs XSH2 to omit the XML declaration
	    from the saved document. Note however, that XML declaration
	    is obligatory for XML documents. It usually looks like
	    <literal moreinfo="none">&lt;?xml version="1.0" ...?&gt;</literal>.
	  </para>
	  <para>
	    <literal moreinfo="none">--backup</literal> (<literal moreinfo="none">:b</literal>)
	    and 
	    <literal moreinfo="none">--no-backup</literal> (<literal moreinfo="none">:B</literal>)
	    can be used to enforce/suppress
	    creation of a backup file if target file
	    already exists. Using these options
	    overrides current global setting of <link linkend="backups">backups</link>.
	  </para>	  
	  <para>
	    <literal moreinfo="none">--encoding</literal>
	     followed by a <link linkend="enc_string">encoding</link>
	    instructs XSH2 to save the document in the specified
	    encoding.  In case of XML output, the &lt;?xml?&gt;
	    declaration is automatically changed accordingly.
	  </para>
	  <example>
	    <title>Use save to preview current HTML document in Lynx</title>
	    <programlisting format="linespecific">save --format html --pipe 'lynx -stdin'</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="open_command">open</link>, <link linkend="close_command">close</link>, <link linkend="print_enc_command">enc</link>, <link linkend="files_command">documents</link></para></simplesect></section><section id="set_command" role="command"><title>set</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set <link linkend="xpath">xpath</link> [<link linkend="xpath">xpath</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>This command provides very easy way to create
            or modify content of a document.
            It takes two XPath expressions. The first one
	    should be a node location path which specifies the target node,
	    the second is optional and provides new content for the target
            node.
	    If a node matches the first XPath expression, then its content
	    is replaced with the given value. If no node matches, then XSH2 tries
	    to magically extend the current document by adding nodes in order to
            add missing steps of the location path so as to make the expression
	    match a node. This node is then populated with
	    a copy of the content value (either text or, if the content <link linkend="xpath">xpath</link> results in a node-list and the target
            node is an element, nodes).
	  </para>
	  <example>
	    <title>Try the following on an empty scratch document</title>
	    <programlisting format="linespecific">$scratch/&gt; ls /
&lt;scratch/&gt;
$scratch/&gt; set scratch/@say "hallo world"
&lt;scratch say="hello world"/&gt;

$scratch/&gt; set scratch/foo[2]/../foo[1]/following-sibling::bar/baz[3] "HALLO"
$scratch/&gt; ls /
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;scratch say="hello world"&gt;
  &lt;foo/&gt;
    &lt;bar&gt;
      &lt;baz/&gt;
      &lt;baz/&gt;
      &lt;baz&gt;HALLO&lt;/baz&gt;
    &lt;/bar&gt;
  &lt;foo/&gt;
&lt;scratch/&gt;
</programlisting>
	  </example>
	  <para>
	    Only a limited subset of XPath is currently supported by
	    this command. Namely, the XPath expression must be a
	    location path consisting of a /-separated sequence of one
	    or more location steps and new nodes
	    can only be magically created along the child, sibling, or
	    attribute axes.
	    The node-test part of the expression
	    can neither be a wildcard (<literal moreinfo="none">*</literal>,
	    <literal moreinfo="none">@*</literal>, <literal moreinfo="none">prefix:*</literal>, ...),
	    nor the <literal moreinfo="none">node()</literal> function. If a namespace
	    prefix is used, then either the namespace must already be
	    declared in the document or registered with XSH. 
	  </para>
	  <para>
	    Location steps may contain arbitrary predicates (filters), however,
	    only a limited subset is supported for magically created
	    nodes.
	    In particular, if a filter predicate of a location step
	    specifies a position of a node (e.g. with
	    <literal moreinfo="none">[4]</literal>, or
	    <literal moreinfo="none">[position()&gt;3]</literal>, etc), then the
	    parser tries to automatically create empty siblings nodes
	    until it finally creates one with for which the predicate
	    is true.
	  </para>
	  <para>
	    Note, that this command only processes one location step
	    at a time and always picks the first matching node. So,
	    expressions like <literal moreinfo="none">/root/a/b</literal> are treated
	    as <literal moreinfo="none">/root/a[1]/b[1]</literal>.  This means that an
	    expression <literal moreinfo="none">/root/a/b</literal> will magically
	    create element <literal moreinfo="none">&lt;b&gt;</literal> in a first
	    matching <literal moreinfo="none">&lt;a&gt;</literal> even if some
	    following <literal moreinfo="none">&lt;a&gt;</literal> already contains a
	    <literal moreinfo="none">&lt;b&gt;</literal>.
	  </para>
	  <para>
	    To prevent this, either explicitly state that <literal moreinfo="none">b</literal> must
	    exist with e.g. <literal moreinfo="none">/root/a[b]/b</literal> or make the corresponding
	    element <literal moreinfo="none">&lt;a&gt;</literal> the context
	    node and use a relative location path:
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">for /root/a/b set b 'foo'</programlisting>
	  </informalexample>
	</simplesect></section><section id="set_dtd_command" role="command"><title>set-dtd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set-dtd [--internal] [--name|:n <link linkend="exp">expression</link>] 
	  [--public|:p <link linkend="exp">expression</link>] 
	  [--system|:s <link linkend="exp">expression</link>] 
	  [<link linkend="document">document</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> set_dtd</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Set external (default) or internal DTD for a given document.  If
	    no <link linkend="document">document</link> is given, the current
	    document is used. At least one of <literal moreinfo="none">--public</literal>
	    and <literal moreinfo="none">--system</literal> options should be used
	    to specify the PUBLIC and SYSTEM identifiers of the DTD.
	    If <literal moreinfo="none">--name</literal> parameter is not provided, 
	    name of the document root element is used as DTD name.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="list_dtd_command">dtd</link>, <link linkend="validate_command">validate</link></para></simplesect></section><section id="set_enc_command" role="command"><title>set-enc</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set-enc <link linkend="enc_string">encoding</link> [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Changes character encoding of a given document. 
	    If no <link linkend="document">document</link>
	    is given, the command applies to the
	    current document. This has two effects:
	    changing the XMLDecl encoding declaration 
	    in the document prolog to display the new
	    encoding and making all future <link linkend="save_command">save</link> operations
	    on the document default to the given charset.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">ls</userinput>
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;foo&gt;...&lt;/foo&gt;
xsh&gt; <userinput moreinfo="none">set-enc "utf-8"</userinput>
xsh&gt; <userinput moreinfo="none">ls</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;foo&gt;...&lt;/foo&gt;
xsh&gt; <userinput moreinfo="none">save</userinput># saves the file in UTF-8 encoding
</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="print_enc_command">enc</link>, <link linkend="doc_info_command">doc-info</link></para></simplesect></section><section id="set_namespace_command" role="command"><title>set-ns</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set-ns [:p|--prefix <link linkend="exp">expression</link>] <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command takes one argument, the namespace URI,
	    possibly accompanied by a prefix provided in
	    the option <literal moreinfo="none">--prefix</literal> <literal moreinfo="none">:p</literal>;
	    both these expressions are evaluated as names.
	    The command changes the namespace of the current element to a given
	    namespace URI. The current node must be in the scope
	    of a namespace declaration associating the namespace URI
	    with a prefix; if prefix option is given, then
	    one of such declarations must associate the particular given prefix
	    with the namespace URI. If this condition
	    is not met or the current node is neither element nor
	    attribute, an error is issued.
	    The command also changes the prefix of the current element accordingly.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="declare_namespace_command">declare-ns</link>, <link linkend="change_namespace_uri_command">change-ns-uri</link>, <link linkend="change_namespace_prefix_command">change-ns-prefix</link>, <link linkend="namespaces_command">namespaces</link></para></simplesect></section><section id="set_standalone_command" role="command"><title>set-standalone</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set-standalone <link linkend="exp">expression</link> [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Changes the value of <literal moreinfo="none">standalone</literal> declaration
            in the XMLDecl prolog of a document. The <link linkend="exp">expression</link> should evaluate to either 1 or 0 
	    or <literal moreinfo="none">'yes'</literal> or <literal moreinfo="none">'no'</literal>.
	    The result of applying the command on other values is not specified.
	    If no <link linkend="document">document</link> is given, 
	    the command applies to the current document. 
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="doc_info_command">doc-info</link></para></simplesect></section><section id="set_filename_command" role="command"><title>set_filename</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">set_filename <link linkend="exp">expression</link> [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Changes filename or URL associated with a 
	    given document (or the current document, if only
	    one argument is specified). Document filename is initialized
	    by the <link linkend="open_command">open</link> command
	    and used e.g. by <link linkend="save_command">save</link>.
	    It can be queried in XPath expressions using the
	    <link linkend="filename_function">xsh:filename</link> function.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="open_command">open</link>, <link linkend="save_command">save</link>, <link linkend="filename_function">xsh:filename</link></para></simplesect></section><section id="options_command" role="command"><title>settings</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">settings</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>List current values of all XSH2 settings (such as
	    validation flag or query-encoding).</para>
	  <para><literal moreinfo="none">--variables</literal> or <literal moreinfo="none">:v</literal>
	    flag enforces syntax which makes use of variable assignments.
	    Otherwise, settings are listed in the form of XSH commands.
	  </para>
	  <example>
	    <title>Store current settings in your .xsh2rc</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">settings | cat &gt; ~/.xsh2rc</userinput></programlisting>
	  </example>
	</simplesect></section><section id="skip_dtd" role="command"><title>skip-dtd</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">skip-dtd <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> skip_dtd</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>If the value of <link linkend="exp">expression</link> is 1 (non-zero),
	    DTD DOCTYPE declaration is omitted from any further serializations
	    of XML documents (including <link linkend="list_command">ls</link>
	    and <link linkend="save_command">save</link>). Default value is
	    <literal moreinfo="none">0</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$SKIP_DTD</literal> variable.</para>
	</simplesect></section><section id="sort_command" role="command"><title>sort</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$result := sort [ --key|:k <link linkend="exp">expression</link> ]
	  --compare|:c <link linkend="perl_code">perl-code</link> <link linkend="exp">expression</link></literal><literal moreinfo="none">$result := sort [ --key|:k <link linkend="exp">expression</link> ]
	  [ --numeric|:n ] [ --descending|:d ] [ --locale|:l]  <link linkend="exp">expression</link>
	  </literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>This command sorts a given node-list,
	    returning a node-list ordered according to a given
	    key and ordering function.
	  </para>
	  <para>
	    <literal moreinfo="none">--key|:k</literal> followed by an expression
	    specifies the key to be computed for each member of the
	    node-list and the result used as the sorting key. If omitted,
	    keys are created by converting the nodes
	    to string as if XPath expression <literal moreinfo="none">string(.)</literal>
	    was used.
	  </para>
	  <para>
	    <literal moreinfo="none">--numeric|:n</literal> specifies, that
	    keys should be compared by their numerical values
	    (the default is string comparison).
	  </para>
	  <para>
	    <literal moreinfo="none">--descending|:d</literal> specifies,
	    that the result should be ordered in descending order
	    (default is ascending).
	  </para>
	  <para>
	    <literal moreinfo="none">--locale|:l</literal> forces using
	    current locale settings for string comparison
	    (default is no locale).
	  </para>
	  <para>
	    <literal moreinfo="none">--compare</literal> argument followed
	    by a <link linkend="perl_code">perl-code</link> allows to define a custom
	    comparison method in a similar way to Perl <literal moreinfo="none">sort</literal>
	    command. The keys to be compared are passed
	    to the code in variables <literal moreinfo="none">$a</literal> and 
	    <literal moreinfo="none">$b</literal>. The code is supposed to return 1 if
	    the key in <literal moreinfo="none">$a</literal> is  greater than
	    <literal moreinfo="none">$b</literal>, 0 if the keys are equal
	    and <literal moreinfo="none">-1</literal> if <literal moreinfo="none">$a</literal>
	    is less than <literal moreinfo="none">$b</literal>, depending
            on how the corresponding elements are to be ordered.
	    It is a run-time error to use
	    <literal moreinfo="none">--compare</literal> together with either
	    <literal moreinfo="none">--numeric</literal> or
	    <literal moreinfo="none">--descending</literal>. 
	  </para>
	  <example>
	    <title>Case-insensitive sort of a given node-list</title>
	    <programlisting format="linespecific">$ordered := sort --key xsh:lc(.) $unordered;</programlisting>
	  </example>
	  <example>
	    <title>Reorder creature elements by name attribute
	      in ascending order using Czech locale settings
	    </title>
	    <programlisting format="linespecific">perl {
# setup locale collating function
# Note, that the collating function must be UTF8 aware.
use POSIX qw(locale_h);
setlocale(LC_COLLATE,'cs_CZ.UTF-8');
};

xmove &amp;{ sort :k@name :l * } into /middle-earth[1]/creatures;
</programlisting>
	  </example>
	  <example>
	    <title>Sort a node-list by a pre-computed score (Perl-based sort)</title>
	    <programlisting format="linespecific">$results := sort --numeric --descending --key { $scores{literal('@name')} } $players;
</programlisting>
	  </example>
	</simplesect></section><section id="stream_process_command" role="command"><title>stream</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">stream 
         [ --input-file|:f <link linkend="filename">filename</link> |
	   --input-pipe|:p <link linkend="filename">filename</link> |
           --input-string|:s <link linkend="exp">expression</link>]
	 [ --output-file|:F <link linkend="filename">filename</link> |
           --output-pipe|:P <link linkend="filename">filename</link> |
           --output-string|:S <link linkend="varname">$variable</link> |
           --no-output|:N ]
           select <link linkend="xpath">xpath</link> <link linkend="block">block</link>
         [ select <link linkend="xpath">xpath</link> <link linkend="block">block</link> ... ]
                   </literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    EXPERIMENTAL!  This command provides a memory efficient
	    (though slower) way to process selected parts of an XML
	    document with XSH2. A streaming XML parser (SAX parser) is
	    used to parse the input. The parser has two states which
	    will be referred to as A and B below. The initial state of
	    the parser is A.</para> <para>In the state A, only a
	    limited vertical portion of the DOM tree is built. All XML
	    data coming from the input stream other than start-tags
	    are immediately copied to the output stream.  If a new
	    start-tag of an element arrives, a new node is created in
	    the tree. All siblings of the newly created node are
	    removed. Thus, in the state A, there is exactly one node
	    on every level of the tree. After a node is added to the
	    tree, all the <link linkend="xpath">xpath</link> expressions
	    following the <literal moreinfo="none">select</literal> keyword
	    are
	    checked. If none matches, the parser remains in state A
	    and copies the start-tag to the output stream. Otherwise,
	    the first expression that matches is remembered and the
	    parser changes its state to B.
	  </para>
	  <para>
	    In state B the parser builds a complete DOM subtree of the
	    element that was last added to the tree before the parser
	    changed its state from A to B. No data are sent to the
	    output at this stage. When the subtree is complete
	    (i.e. the corresponding end-tag for its topmost element is
	    encountered), the <link linkend="block">block</link> of instructions
	    following the <link linkend="xpath">xpath</link> expression that
	    matched is invoked with the root element of the subtree as
	    the current context node. The commands in <link linkend="block">block</link> are allowed to transform the whole
	    element subtree or even to replace it with a different DOM
	    subtree or subtrees. They must, however, leave intact 
	    all ancestor nodes of the subtree. 
            Failing to do so can result in an error or
	    unpredictable results.
	  </para>
	  <para>
	    After the subtree processing <link linkend="block">block</link>
	    returns, all subtrees that now appear in the DOM tree in
	    the place of the original subtree are serialized to the
	    output stream. After that, they are deleted and the parser
	    returns to state A.
	  </para>
	  <para>
	    Note that this type of processing highly limits the amount
	    of information the selecting XPath expressions can use. The first
	    notable fact is, that elements can not be selected by their
	    content. The only information present in the tree at the
	    time of the XPath evaluation is the element's name and
	    attributes plus the same information for all its
	    ancestors (there is no information at all about its possible
	    child nodes nor of the node's position
	    within the list of its siblings).
	  </para>
	  <para>The input parameters below are mutually exclusive.
	  If non is given, standard input is processed.</para>
	  <para><literal moreinfo="none">--input-file</literal> or <literal moreinfo="none">:f</literal>
	    instructs the processor to stream from a given file.</para>
	  <para><literal moreinfo="none">--input-pipe</literal> or <literal moreinfo="none">:p</literal>
	    instructs the processor to stream the output of a given a command.</para>
	  <para><literal moreinfo="none">--input-string</literal> or <literal moreinfo="none">:s</literal>
	    instructs the processor to use the result of a given
	    expression as the input to be processed.
	  </para>
	  <para>The output parameters below are mutually exclusive.
	    If none is given, standard output is used.
	  </para>
	  <para><literal moreinfo="none">--output-file</literal> or <literal moreinfo="none">:F</literal>
	    instructs the processor to save the output
	    to a given file.</para>
	  <para><literal moreinfo="none">--output-pipe</literal> or <literal moreinfo="none">:P</literal>
	    instructs the processor to pipe the output
	    to a given command.
	  </para>
	  <para><literal moreinfo="none">--output-string</literal> or <literal moreinfo="none">:S</literal>
	    followed by a variable name instructs the processor to 
	    store the result in the given variable.
	  </para>
	  <para><literal moreinfo="none">--no-output</literal> or <literal moreinfo="none">:N</literal>
            instructs the processor to throw the result away.
	  </para>
	</simplesect></section><section id="strip_ws_command" role="command"><title>strip-whitespace</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">strip-whitespace <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> strip_whitespace</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para><literal moreinfo="none">strip-whitespace</literal> removes all leading and
	    trailing whitespace from given nodes. If applied to an
	    element node, it removes all leading and trailing child
	    whitespace-only text nodes and CDATA sections.
	  </para>
	</simplesect></section><section id="cdonopen" role="command"><title>switch-to-new-documents</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">switch-to-new-documents <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> switch_to_new_documents</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>If non-zero, XSH2 changes
	    current node to the document node of a newly open/created
	    files every time a new document is opened or created with
	    <link linkend="open_command">open</link> or <link linkend="create_command">create</link>.
	    Default value for this option is 1. 
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$SWITCH_TO_NEW_DOCUMENTS</literal> variable.</para>
	</simplesect></section><section id="test_mode" role="command"><title>test-mode</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">test-mode</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> test_mode</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Switch into a mode in which no commands are actually
	    executed and only command syntax is checked.
	  </para>
	  <para>This is equivalent to setting
	    <literal moreinfo="none">$TEST_MODE</literal> variable to 1.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="run_mode">run-mode</link></para></simplesect></section><section id="throw_command" role="command"><title>throw</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">throw <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command throws and exception containing error message
	    given by the obligatory <link linkend="exp">expression</link>
	    argument. If the exception is not handled 
	    by some surrounding <link linkend="try_catch">try</link> block,
	    the execution is stopped immediately and the error
	    message is printed.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="try_catch">try</link></para></simplesect></section><section id="try_catch" role="command"><title>try</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">try <link linkend="block">block</link> catch [[local|my] <link linkend="varname">$variable</link>] <link linkend="block">block</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Execute the <link linkend="block">block</link> following the
	    <literal moreinfo="none">try</literal> keyword.  If an error or exception
	    occurs during the evaluation, execute the
	    <literal moreinfo="none">catch</literal> <link linkend="block">block</link>.  If the
	    <literal moreinfo="none">catch</literal> keyword is followed by a 
	    variable (possibly localized for the following block using
	    <link linkend="my_command">my</link> or <link linkend="local_command">local</link>)
	    and the <literal moreinfo="none">try</literal> block fails
	    with an exception, the error message of
	    the exception is stored to the variable before the
	    <literal moreinfo="none">catch</literal> block is executed.
	  </para>
	  <para>
	    The <link linkend="throw_command">throw</link> command as well as an equivalent
	    Perl construction <literal moreinfo="none">perl { die "error message" }</literal> allow user to throw custom exceptions.
	  </para>
	  <para>
	    Unless exception is raised or error occurs, this command
	    returns the return value of the <literal moreinfo="none">try</literal> block;
	    otherwise it returns the return value of 
	    the <literal moreinfo="none">catch</literal> block.
	  </para>
	  <example>
	    <title>Handle parse errors</title>
	    <programlisting format="linespecific">try {
  $doc:=open --format xml $input;
} catch {
  try {
    echo "XML parser failed, trying HTML";
    $doc := open --format html $input;
  } catch my $error {
    echo "Stopping due to errors: $error";
    exit 1;
  }
}
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="throw_command">throw</link></para></simplesect></section><section id="undef" role="command"><title>undef</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">undef [<link linkend="subname">subroutine</link> | <link linkend="varname">$variable</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> undefine</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command can be used to undefine previously defined
	    XSH2 subroutines and variables.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="close_command">close</link>, <link linkend="def">def</link></para></simplesect></section><section id="unfold_command" role="command"><title>unfold</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">unfold <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This feature is still EXPERIMENTAL! 
	  </para>
	  <para>Unfold command removes
	    <literal moreinfo="none">xsh:fold</literal> attributes from all given elements.
	    Such attributes are usually created by previous
	    usage of <link linkend="fold_command">fold</link>.  Be aware, that
	    <literal moreinfo="none">xmlns:xsh</literal> namespace declaration may
	    still be present in the document even when all elements
	    are unfolded.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="fold_command">fold</link>, <link linkend="list_command">ls</link></para></simplesect></section><section id="unless" role="command"><title>unless</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">unless <link linkend="exp">expression</link>
	  <link linkend="command">command</link>
	</literal><literal moreinfo="none">
          unless <link linkend="exp">expression</link>
	  <link linkend="block">block</link> [ else <link linkend="block">block</link> ]
	</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Like if but negating the result of the expression.
	    Also, unlike if, <literal moreinfo="none">unless</literal> has no
	    <literal moreinfo="none">elsif</literal> block.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="if">if</link></para></simplesect></section><section id="unregisterfunc_command" role="command"><title>unregister-function</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">unregister-function <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> unregfunc</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    EXPERIMENTAL!  Unregister XPath extension function of a
	    given name previously registered using <link linkend="registerfunc_command">register-function</link>.
	  </para>
	</simplesect></section><section id="unregisterns_command" role="command"><title>unregister-namespace</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">unregister-namespace <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> unregns</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Unregisters given namespace prefix previously registered
	    using <link linkend="registerns_command">register-namespace</link>.  The prefix
	    can no longer be used in XPath expressions unless declared
	    within the current scope of the queried document.
	  </para>
	</simplesect></section><section id="validate_command" role="command"><title>validate</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">validate [--yesno|:q] [<link linkend="document">document</link>]</literal><literal moreinfo="none">validate [--yesno|:q] [--dtd|:D | --relaxng|:R | --schema|:S] --file|:f <link linkend="filename">filename</link>] [<link linkend="document">document</link>]</literal><literal moreinfo="none">validate [--yesno|:q] [--dtd|:D | --relaxng|:R | --schema|:S] --string|:s <link linkend="exp">expression</link>] [<link linkend="document">document</link>]</literal><literal moreinfo="none">validate [--yesno|:q] [--dtd|:D | --relaxng|:R | --schema|:S] --doc|:d <link linkend="document">document</link>] [<link linkend="document">document</link>]</literal><literal moreinfo="none">validate [--yesno|:q] [--dtd|:d] --public|:p <link linkend="exp">expression</link> [--file|:f <link linkend="exp">expression</link>] [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command validates the current document or
	    a document specified in the argument against a DTD,
	    RelaxNG or XSD schema.
	    If <literal moreinfo="none">--yesno</literal> or <literal moreinfo="none">:q</literal> is specified, only prints
	    <literal moreinfo="none">yes</literal> and returns 1 if the document validates or
	    <literal moreinfo="none">no</literal> and returns 0 if it does
	    not. Without <literal moreinfo="none">--yesno</literal>, it throws an
	    exception with a complete validation error message if
	    the document doesn't validate.
	  </para>
	  <para><literal moreinfo="none">--dtd</literal> or <literal moreinfo="none">:D</literal> forces DTD validation
	  (default).</para>
	  <para><literal moreinfo="none">--relaxng</literal> or <literal moreinfo="none">:R</literal> forces RelaxNG
	  validation. Only XML RelaxNG grammars are supported.</para>
	  <para><literal moreinfo="none">--schema</literal> or <literal moreinfo="none">:S</literal> forces W3C XML Schema 
	    validation (XSD). Support for schema validation may still
	    be incomplete (see <ulink url="http://xmlsoft.org">libxml2 home page</ulink>
	    for more details).</para>
	  <para>
	    A DTD subset can be specified by its PUBLIC identifier (with
	    <literal moreinfo="none">--public</literal>), by its SYSTEM identifier
	    (with <literal moreinfo="none">--file</literal>), or as a string (with
	    <literal moreinfo="none">--string</literal>).  If none of these options is
	    used, validation is performed against the internal or
	    external DTD subset of the document being validated.
	  </para>
	  <para>
	    RelaxNG grammars and XML Schemas can either be
	    specified either as a filename or url (with
	    <literal moreinfo="none">--file</literal>), 
	    as a string containing (with <literal moreinfo="none">--string</literal>), 
	    or as a document currently open in XSH2 (with
	    <literal moreinfo="none">--doc</literal>).  
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">$mydoc := open "test.xml"</programlisting>
	    <programlisting format="linespecific"># in all examples below, mydoc can be omitted</programlisting>
	    <programlisting format="linespecific">validate --yesno $mydoc; # validate against the document's DOCTYPE</programlisting>
	    <programlisting format="linespecific">validate --public "-//OASIS//DTD DocBook XML V4.1.2//EN" $mydoc</programlisting>
	    <programlisting format="linespecific">validate --file "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" $mydoc</programlisting>
	  </informalexample>
	  <informalexample>
	    <programlisting format="linespecific">validate --relaxng --file "test.rng" $mydoc</programlisting>
	    <programlisting format="linespecific">validate --relaxng --string $relaxschema $mydoc</programlisting>
	    <programlisting format="linespecific">$rng := open "test.rng"</programlisting>
	    <programlisting format="linespecific">validate --relaxng --doc $rng $mydoc</programlisting>
	  </informalexample>
	  <informalexample>
	    <programlisting format="linespecific">validate --schema --file "test.xsd" $mydoc</programlisting>
	    <programlisting format="linespecific">validate --schema --string $xsdschema $mydoc</programlisting>
	    <programlisting format="linespecific">$xsd := open "test.xsd"</programlisting>
	    <programlisting format="linespecific">validate --schema --doc $xsd $mydoc</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="list_dtd_command">dtd</link></para></simplesect></section><section id="validation" role="command"><title>validation</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">validation <link linkend="exp">expression</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Turn on validation during the parse process if the
	    <link linkend="exp">expression</link> is non-zero or off otherwise.
	    Defaults to off.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$VALIDATION</literal> variable.</para>
	</simplesect></section><section id="var_command" role="command"><title>variables</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">variables</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> vars, var</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>List all global variables and their current values.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="files_command">documents</link>, <link linkend="list_defs_command">defs</link></para></simplesect></section><section id="verbose" role="command"><title>verbose</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">verbose</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Turn on verbose messages (default).</para>
	  <para>This is equivalent to setting
	    <literal moreinfo="none">$QUIET</literal> variable to 0.</para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="quiet">quiet</link></para></simplesect></section><section id="version" role="command"><title>version</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">version</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Prints program version plus version numbers of the most
	    important libraries used.
	  </para>
	</simplesect></section><section id="while" role="command"><title>while</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">while <link linkend="exp">expression</link> <link linkend="block">block</link></literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para> Execute the <link linkend="command">command</link> or <link linkend="block">block</link> as long as
	    the given <link linkend="exp">expression</link> evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or
	    non-empty literal.
	  </para>
	  <example>
	    <title>The commands in this example do the same thing</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">while /table/row remove /table/row[1];</userinput>
xsh&gt; <userinput moreinfo="none">remove /table/row;</userinput>
</programlisting>
	  </example>
	</simplesect></section><section id="wrap_command" role="command"><title>wrap</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">wrap [--namespace <link linkend="exp">expression</link>] 
	  [ [--inner] | [--while|:W <link linkend="exp">expression</link>] [--until|:U <link linkend="exp">expression</link>]
	    [--skip-whitespace|:w] [--skip-comments|:c] [--skip-pi|:p] ]
	  <link linkend="exp">expression</link> <link linkend="xpath">xpath</link>
	</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    For each node matching the <link linkend="xpath">xpath</link> argument,
	    this command creates a new element node according to a
	    given <link linkend="exp">expression</link> (in the same
	    way as <link linkend="xinsert_command">xinsert</link> does)
	    which replaces the matching node, and
	    moves the matching node into this newly created element.
	    If namespace <link linkend="exp">expression</link> is given,
	    the namespace is applied on the created element.
	    The command returns a node-list consisting
	    of the elements created.
	  </para>
	  <para>
	    With <literal moreinfo="none">--inner</literal> (or <literal moreinfo="none">:i</literal>)
	    flag the command 
	    wraps children nodes of the matching node
	    rather than the node it self
	    the following sense:
	    for each matching node
	    a new element node is created,
	    but this time it is placed into 
	    the matching node and 
	    all previous children of the matching node
	    are moved into the newly created node.
	    In this mode, all non-element matching
	    nodes are ignored. This flag cannot be used together
	    with <literal moreinfo="none">--while</literal>
	    and <literal moreinfo="none">--until</literal>, which we describe next.
	  </para>
	  <para>
	    <literal moreinfo="none">--while</literal> (<literal moreinfo="none">:W</literal>)
	    and/or <literal moreinfo="none">--until</literal> (<literal moreinfo="none">:U</literal>) 
	    arguments can be provided in order to move a sequence
	    of adjacent siblings following the matching node into
	    the newly created element. In this way the newly created element wraps
	    not just the matching node itself but a range of nodes starting
	    at the matching node and ending either before a first following node matching
	    the expression of <literal moreinfo="none">--until</literal>, or
	    before a first following node not matching the expression
	    of <literal moreinfo="none">--while</literal>, or at the last sibling if
	    neither of the prior apply. Both these expressions are
	    evaluated in the context of the currently tested sibling and prior to
	    the creation of the wrapping element. The context
	    position for these expressions is 1 at the first sibling
	    following the matching node and increases with each tested
	    sibling; the context size is the number of all
	    siblings following the matching node.
	    It is important to mention that siblings wrapped in this
	    way are excluded from further processing by <link linkend="wrap_command">wrap</link> even if included in the node-list
	    produced by the <link linkend="xpath">xpath</link> argument. This allows to easily wrap
	    certain adjacent elements without worrying about some
	    elements being wrapped multiple times
	    (for example, <literal moreinfo="none">wrap :W x y //x</literal> wraps
	    each sequence of adjacent elements <literal moreinfo="none">&lt;x&gt;</literal> in a <literal moreinfo="none">&lt;y&gt;</literal>).
	  </para>
	  <para><literal moreinfo="none">--skip-whitespace</literal> (<literal moreinfo="none">:w</literal>),
	    <literal moreinfo="none">--skip-comments</literal> (<literal moreinfo="none">:c</literal>), and 
	    <literal moreinfo="none">--skip-pi</literal> (<literal moreinfo="none">:p</literal>) can be used
	    in combination with <literal moreinfo="none">--while</literal> (<literal moreinfo="none">:W</literal>)
	    and/or <literal moreinfo="none">--until</literal> (<literal moreinfo="none">:U</literal>)
	    to skip testing the expressions on white-space text
	    nodes, comments, and/or processing instruction, respectively.
	    Such nodes are only included in the wrapped range if
	    followed by a sibling that is to be wrapped.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">$scratch/&gt; ls /;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;scratch/&gt;

$scratch/&gt; wrap 'foo' *;
$scratch/&gt; insert attribute 'bar=baz' into /foo;
$scratch/&gt; insert text 'some text' into //scratch;
$scratch/&gt; wrap --namespace 'http://foo/bar' 'a:A' //@*;
$scratch/&gt; $wrapper := wrap 'text aaa="bbb"' //text();
$scratch/&gt; wrap '&lt;elem ccc=ddd&gt;' //*;
$scratch/&gt; ls /;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;elem ccc="ddd"&gt;
  &lt;foo xmlns:a="http://foo/bar"&gt;
    &lt;elem ccc="ddd"&gt;
      &lt;scratch&gt;
        &lt;elem ccc="ddd"&gt;
          &lt;text aaa="bbb"&gt;some text&lt;/text&gt;
        &lt;/elem&gt;
      &lt;/scratch&gt;
    &lt;/elem&gt;
    &lt;elem ccc="ddd"&gt;
      &lt;a:A xmlns:a="http://foo/bar" bar="baz"/&gt;
    &lt;/elem&gt;
  &lt;/foo&gt;
&lt;/elem&gt;

$scratch/&gt; ls $wrapper;
&lt;text aaa="bbb"&gt;some text&lt;/text&gt;


$scratch/&gt; wrap --inner bar //foo
$scratch/&gt; ls /;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;elem ccc="ddd"&gt;
  &lt;foo xmlns:a="http://foo/bar"&gt;
    &lt;bar&gt;
      &lt;elem ccc="ddd"&gt;
        &lt;scratch&gt;
          &lt;elem ccc="ddd"&gt;
            &lt;text aaa="bbb"&gt;some text&lt;/text&gt;
          &lt;/elem&gt;
        &lt;/scratch&gt;
      &lt;/elem&gt;
      &lt;elem ccc="ddd"&gt;
        &lt;a:A xmlns:a="http://foo/bar" bar="baz"/&gt;
      &lt;/elem&gt;
    &lt;/bar&gt;
  &lt;/foo&gt;
&lt;/elem&gt;
</programlisting>
	  </informalexample>
	  <example>
	    <title>Wrapping a range of adjacent nodes</title>
	    <programlisting format="linespecific"># prepare the test document
$scratch/&gt; rm /scratch/node(); # cleanup the document
$scratch/&gt; set /scratch/li[5]; # create 5 &lt;li&gt; elements
$scratch/&gt; set /scratch/li[3]/following-sibling::li; # add &lt;br/&gt; after the 3rd &lt;li&gt;
$scratch/&gt; for //li set . position(); # number the &lt;li&gt; elements 
$scratch/&gt; ls /
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;scratch&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;br/&gt;
  &lt;li&gt;4&lt;/li&gt;
  &lt;li&gt;5&lt;/li&gt;
&lt;/scratch&gt;
# wrap adjacent elements &lt;li&gt; into an &lt;ol&gt;
$scratch/&gt; wrap --skip-whitespace --while self::li ol //li;
$scratch/&gt; ls /
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;scratch&gt;
  &lt;ol&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
  &lt;/ol&gt;
  &lt;br/&gt;
  &lt;ol&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
  &lt;/ol&gt;
&lt;/scratch&gt;
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="xinsert_command">xinsert</link>, <link linkend="insert_command">insert</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link></para></simplesect></section><section id="wrap_span_command" role="command"><title>wrap-span</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">wrap-span [--namespace <link linkend="exp">expression</link>] <link linkend="exp">expression</link> <link linkend="exp">expression</link> <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> wrap_span</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This command is very similar to <link linkend="wrap_command">wrap</link>
	    command, except that it works on spans of nodes.
	    It wraps spans (i.e. sequence of adjacent nodes between (and including)
	    a start node and an end node) with a new element
	    whose name is specified as the first argument. 
	    Nodes within each span must have the same parent node.
	    The spans to be wrapped are defined
	    by a pair of node-lists in the second and third argument.
	    The first node-list specifies the
	    start node of one or more spans, while
	    the second node-list should contain the corresponding 
	    end nodes.
	    The two node-lists must evaluate to the exactly same number of
	    nodes, otherwise a runtime error is reported.
	    The N'th span is then defined as a span
	    starting on the N'th node in the start node-list
	    and ending at the N'th node in the end node-list.
	  </para>
	  <para>
	    All nodes within the spans are removed from
	    the document and placed into the newly generated elements.
	    The wrapping elements are put back into the document tree
	    at the positions previously occupied by the node-spans.</para>
	  <para>
	    The command returns a node-list containing the newly created
	    wrapping elements.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">xsh $scratch/&gt; $foo := create { "&lt;root&gt;\n&lt;a/&gt;&lt;b/&gt;\n&lt;a/&gt;&lt;b/&gt;\n&lt;a/&gt;&lt;b/&gt;\n&lt;/root&gt;" };
xsh $foo/&gt; wrap-span 'span' //a //b;
xsh $foo/&gt; ls /;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root&gt;
&lt;span&gt;&lt;a/&gt;&lt;b/&gt;&lt;/span&gt;
&lt;span&gt;&lt;a/&gt;&lt;b/&gt;&lt;/span&gt;
&lt;span&gt;&lt;a/&gt;&lt;b/&gt;&lt;/span&gt;
&lt;/root&gt;
</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="xinsert_command">xinsert</link>, <link linkend="insert_command">insert</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link></para></simplesect></section><section id="xcopy_command" role="command"><title>xcopy</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xcopy [--respective|:r] [--preserve-order|:p] <link linkend="exp">expression</link> <link linkend="loc">location</link> <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xcp</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    xcopy is similar to <link linkend="copy_command">copy</link>, but copies
	    <emphasis>all</emphasis> nodes in the first node-list
	    <link linkend="exp">expression</link> to <emphasis>all</emphasis>
	    destinations determined by the
	    <link linkend="loc">location</link> directive relative 
	    to the second node-list <link linkend="exp">expression</link>. 
	    See <link linkend="copy_command">copy</link> for detailed description of
	    <literal moreinfo="none">xcopy</literal> arguments.
	  </para>
	  <para>
	    If <literal moreinfo="none">--respective|:r</literal> option
	    is used, then the target node-list <link linkend="exp">expression</link>
	    is evaluated in the context of the source node
	    being copied.
	  </para>
	  <para>
	    The <literal moreinfo="none">--preserve-order|:p</literal> option can be
	    used to ensure that the copied nodes are in the same
	    relative order as the corresponding source nodes.
	    Otherwise, if <link linkend="loc">location</link> is
	    <literal moreinfo="none">after</literal> or <literal moreinfo="none">prepend</literal>,
	    the relative order of the copied nodes will be reversed,
	    because source nodes are placed to the target location one
	    by one.
	  </para>
	  <example>
	    <title>Copy all middle-earth creatures within the document $a
	      into every world of the document $b.</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">xcopy $a/middle-earth/creature into $b//world</userinput></programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="copy_command">copy</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link>, <link linkend="insert_command">insert</link>, <link linkend="xinsert_command">xinsert</link></para></simplesect></section><section id="xinsert_command" role="command"><title>xinsert</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xinsert [--namespace <link linkend="exp">expression</link>] <link linkend="nodetype">node-type</link> <link linkend="exp">expression</link> <link linkend="loc">location</link> <link linkend="xpath">xpath</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xadd</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create new nodes of the 
	    <link linkend="nodetype">node-type</link> given in the 1st argument
	    of name specified in the 2nd argument and insert them 
	    to <link linkend="loc">location</link>s  relative to nodes
	    in the node-list specified in the 4th argument.
	  </para>
	  <para>
	    For element nodes, the the 2nd argument <link linkend="exp">expression</link> 
	    should evaluate to something like
	      "&lt;element-name att-name='attvalue' ...&gt;".  The
	      <literal moreinfo="none">&lt;</literal> and <literal moreinfo="none">&gt;</literal>
	      characters are optional. If no attributes are used, the
	      expression may simply consist the element name. Note,
	      that in the first case, the quotes are required since
	      the expression contains spaces.
	  </para>
	  <para>
	    Attribute nodes use the following syntax:
	    "att-name='attvalue' [...]".
	  </para>
	  <para>
	    For the other types of nodes (text, cdata, comments) the
	    expression should contain the node's literal content. Again,
	    it is necessary to quote all whitespace and special
	    characters as in any expression argument.
	  </para>
	  <para>
	    The <link linkend="loc">location</link> argument should be one of:
	    <literal moreinfo="none">after</literal>, <literal moreinfo="none">before</literal>,
	    <literal moreinfo="none">into</literal>,
	    <literal moreinfo="none">replace</literal>, <literal moreinfo="none">append</literal>
	    or <literal moreinfo="none">prepend</literal>. See documentation
	    of the <link linkend="loc">location</link> argument type for more detail.
	  </para>
	  <para>
	    Optionally, for element and attribute nodes,
	    a namespace may be specified with <literal moreinfo="none">--namespace</literal>
	    or <literal moreinfo="none">:n</literal>. If used, 
	    the expression should evaluate to the desired namespace
	    URI and the name of the element or attribute being inserted 
	    <emphasis>must have a prefix</emphasis>.
	  </para>
	  <para>
	    The command returns a node-list consisting of nodes it created.
	  </para>
	  <para>
	    Note, that instead of <literal moreinfo="none">xinsert</literal>, you can alternatively use 
	    one of <link linkend="new_attribute_function">xsh:new-attribute</link>,
	    <link linkend="new_cdata_function">xsh:new-cdata</link>,
	    <link linkend="new_chunk_function">xsh:new-chunk</link>,
	    <link linkend="new_comment_function">xsh:new-comment</link>,
	    <link linkend="new_element_function">xsh:new-element</link>,
	    <link linkend="new_element_ns_function">xsh:new-element-ns</link>,
	    <link linkend="new_pi_function">xsh:new-pi</link>, and
	    <link linkend="new_text_function">xsh:new-text</link>
	    together with the command <link linkend="xcopy_command">xcopy</link>.
	  </para>
	  <example>
	    <title>Give each chapter a provisional title element.</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">my $new_titles := xinsert element "&lt;title font-size=large underline=yes&gt;" \
  into /book/chapter</userinput>
xsh&gt; <userinput moreinfo="none">xinsert text "Change me!" into $new_titles;</userinput></programlisting>
	  </example>
	  <example>
	    <title>Same as above, using xcopy and xsh:new-... instead of xinsert</title>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">my $new_titles := xcopy xsh:new-element("title","font-size","large","underline","yes") \
  into /book/chapter</userinput>
xsh&gt; <userinput moreinfo="none">xcopy xsh:new-text("Change me!") into $new_titles;</userinput></programlisting>
	  </example>

	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="insert_command">insert</link>, <link linkend="move_command">move</link>, <link linkend="xmove_command">xmove</link></para></simplesect></section><section id="xmove_command" role="command"><title>xmove</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xmove [--respective|:r] [--preserve-order|:p] <link linkend="xpath">xpath</link> <link linkend="loc">location</link> <link linkend="xpath">xpath</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xmv</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>Like <link linkend="xcopy_command">xcopy</link>, except that
	    <literal moreinfo="none">xmove</literal> <emphasis>removes</emphasis> the source
	    nodes after a successful copy.  Remember that the moved nodes are
	    actually <emphasis>different nodes</emphasis> from the original
	    ones (which may not be obvious when moving nodes within a single
	    document into locations that do not require type conversion). So,
	    after the move, the original nodes don't belong to any document and
	    are automatically destroyed unless still contained in some variable.
	  </para>
	  <para>
	    This command returns a node-list consisting of all nodes
	    it created on the target locations.
	  </para>
	  <para>
	    If <literal moreinfo="none">--respective|:r</literal> option
	    is used, then the target node-list <link linkend="exp">expression</link>
	    is evaluated in the context of the source node
	    being copied.
	  </para>
	  <para>
	    The <literal moreinfo="none">--preserve-order|:p</literal> option can be
	    used to ensure that the copied nodes are in the same
	    relative order as the corresponding source nodes.
	    Otherwise, if <link linkend="loc">location</link> is
	    <literal moreinfo="none">after</literal> or <literal moreinfo="none">prepend</literal>,
	    the relative order of the copied nodes will be reversed,
	    because source nodes are placed to the target location one
	    by one.
	  </para>
	  <para>
	    See <link linkend="xcopy_command">xcopy</link> for more details on
	    how the copies of the moved nodes are created.
	  </para>
	  <para>
	    The following example demonstrates how <literal moreinfo="none">xmove</literal>
	    can be used to get rid of HTML <literal moreinfo="none">&lt;font&gt;</literal>
	    elements while preserving their content. As an exercise,
	    try to figure out why simple
	    <literal moreinfo="none">foreach //font { xmove node() replace . }</literal>
	    would not work here.
	  </para>
	  <example>
	    <title>Get rid of all &lt;font&gt; tags</title>
	    <programlisting format="linespecific">while //font {
  foreach //font {
    xmove node() replace .;
  }
}
</programlisting>
	  </example>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="move_command">move</link>, <link linkend="copy_command">copy</link>, <link linkend="xcopy_command">xcopy</link>, <link linkend="insert_command">insert</link>, <link linkend="xinsert_command">xinsert</link></para></simplesect></section><section id="xpath_axis_completion_command" role="command"><title>xpath-axis-completion</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xpath-axis-completion <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xpath_axis_completion</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    The following values are allowed:
	    <literal moreinfo="none">always</literal>, <literal moreinfo="none">never</literal>,
	    <literal moreinfo="none">when-empty</literal>. Note, that all other values
	    (including 1) work as <literal moreinfo="none">never</literal>!
	  </para>
	  <para>
	    If the <link linkend="exp">expression</link> evaluates 
	    to <literal moreinfo="none">always</literal>, TAB completion for
	    XPath expressions always includes axis names.
	  </para>
	  <para>
	    If the <link linkend="exp">expression</link> evaluates to
	    <literal moreinfo="none">when-empty</literal>, the TAB completion list for
	    XPath expressions includes axis names only if no element name
	    matches the completion.
	  </para>
	  <para>
	    If the <link linkend="exp">expression</link> evaluates to
	    <literal moreinfo="none">never</literal>, the TAB completion list for
	    XPath expressions never includes axis names.
	  </para>
	  <para>
	    The default value for this option is
	    <literal moreinfo="none">always</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$XPATH_AXIS_COMPLETION</literal> variable.</para>
	</simplesect></section><section id="xpath_completion_command" role="command"><title>xpath-completion</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xpath-completion <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xpath_completion</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    If the
	    <link linkend="exp">expression</link> is non-zero,
	    enable the TAB completion for <link linkend="xpath">xpath</link>
	    expansions in the interactive shell mode, disable it
	    otherwise. Defaults to on.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal moreinfo="none">$XPATH_COMPLETION</literal> variable.</para>
	</simplesect></section><section id="xpath_extensions_command" role="command"><title>xpath-extensions</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xpath-extensions [<link linkend="exp">expression</link>]</literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> xpath_extensions</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    <literal moreinfo="none">xpath-extensions</literal>
	    remaps all extra
	    XPath extension functions provided by XSH2
	    (which by default belong to the namespace
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal>)
	    to a new namespace given by <link linkend="exp">expression</link>.
	    If the argument is omitted, the functions
	    are re-registered without any namespace,
	    so that they may be called without a
	    namespace prefix, just by their function
	    names. This quite convenient.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">xpath-extensions;
ls grep(//word,"^.*tion$");</programlisting>
	  </informalexample>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="set_enc_command">set-enc</link>, <link linkend="set_standalone_command">set-standalone</link></para></simplesect></section><section id="xslt_command" role="command"><title>xslt</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">$result := xslt [--doc|:d | --precompiled|:p] [--string] <link linkend="exp">expression</link> [<link linkend="document">document</link> name=<link linkend="xpath">xpath</link> [name=<link linkend="xpath">xpath</link> ...]]</literal><literal moreinfo="none">$pre_compiled := xslt [--compile|:c] <link linkend="exp">expression</link></literal></para></simplesect> <simplesect role="aliases">
   <title>Aliases</title>
   <para><literal moreinfo="none"> transform, xsl, xsltproc, process</literal></para>
 </simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function compiles a given XSLT stylesheet 
	    and/or transforms a given document with XSLT.
	  </para>
	  <para>A XSLT stylesheet is specified in the
	    first argument either as a file name (default), or as a
	    document (<literal moreinfo="none">--doc</literal> or
	    <literal moreinfo="none">:d</literal>), or as a precompiled XSLT
	    stylesheet object (<literal moreinfo="none">--precompiled</literal> or
	    <literal moreinfo="none">:p</literal> - see <literal moreinfo="none">--compile</literal>
	    above).</para>
	  <para>
	    If <literal moreinfo="none">--compile</literal> or <literal moreinfo="none">:c</literal>
	    is used, compile a given XSLT stylesheet and return a
	    compiled XSLT stylesheet object. This object can be later
	    passed as a XSLT stylesheet to <literal moreinfo="none">xslt
	    --precompiled</literal>.
	  </para>
	  <para>
	    Without <literal moreinfo="none">--compile</literal> or
	    <literal moreinfo="none">:c</literal>, transform a given <link linkend="document">document</link> (or - if used with
	    only the stylesheet argument - the current document) 
	    using a given XSLT stylesheet and
	    return the result.</para>
	  <para>
	    All arguments following the second (document) argument are
	    considered to be stylesheet parameters and (after
	    expanding <literal moreinfo="none">${...}</literal> interpolators) are
	    directly passed to the XSLT engine without being evaluated
	    by XSH2. All stylesheet parameters should be of the form
	    <literal moreinfo="none">name=<link linkend="xpath">xpath</link></literal> (possibly
	    in brackets).
	  </para>
	  <example>
	    <title>Process current document with XSLT</title>
	    <programlisting format="linespecific">$result := xslt stylesheet.xsl . font='14pt' color='red'</programlisting>
	  </example>
	  <example>
	    <title>Same for several documents, reusing the XSLT stylesheet</title>
	    <programlisting format="linespecific">$xslt := xslt --compile stylesheet.xsl;
foreach my $file in {qw(f1.xml f2.xml f3.xml)} {
  save --file {"out_$file"} &amp;{xslt --precompiled $xslt &amp;{ open $file } font='14pt' color='red'};
}
</programlisting>
	  </example>

	</simplesect></section><section id="xupdate_command" role="command"><title>xupdate</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">xupdate <link linkend="document">document</link> [<link linkend="document">document</link>]</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Modify the current document or the document specified
	    by the second <link linkend="document">document</link> argument according to
	    XUpdate commands of the first <link linkend="document">document</link>
	    argument. 
	    XUpdate, or more specifically the XML Update Language, aims to
	    be a language for updating XML documents.
	  </para>
	  <para>
	    XUpdate language is described in XUpdate Working Draft at
            <ulink url="http://xmldb-org.sourceforge.net/xupdate/xupdate-wd.html">http://xmldb-org.sourceforge.net/xupdate/xupdate-wd.html</ulink>.	    	    
	  </para>
	  <para>XUpdate output can be generated for example by
            Python xmldiff utility from
	    <ulink url="http://www.logilab.org/projects/xmldiff/">http://www.logilab.org/projects/xmldiff/</ulink>.
	  </para>
	</simplesect></section></section>
  <section id="type">
    <title>Type Reference</title>
  <section id="varname" role="argtype"><title>variable name</title><simplesect role="description"><title>Description</title>
	  <para>
	    Variable names start with a dollar-sign (<literal moreinfo="none">$</literal>)
	    followed by an identifier. The identifier must
	    match the following regular
	    expression <literal moreinfo="none">[a-zA-Z_][a-zA-Z0-9_]*</literal>,
	    i.e., it must be at least one character long, must
	    beginning with a letter or
	    underscore, and may only containing letters, underscores, and
	    digits.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="Variables">Variables</link>, <link linkend="assign_command">assign</link>, <link linkend="my_command">my</link>, <link linkend="local_command">local</link></para></simplesect></section><section id="filename" role="argtype"><title>filename</title><simplesect role="description"><title>Description</title>
	  <para>An <link linkend="exp">expression</link> which evaluates to a valid
	    filename or URL. As long as the expression contains no
	    whitespace, no brackets of any type, quotes,
	    double-quotes, <literal moreinfo="none">$</literal> character nor
	    <literal moreinfo="none">@</literal> character, it is treated as a literal token
	    which evaluates to itself.
	  </para>
	</simplesect></section><section id="nodename" role="argtype"><title>node-name</title><simplesect role="description"><title>Description</title>
	  <para>An <link linkend="exp">expression</link> which evaluates to a valid
	    name of an element, attribute or processing-instruction
	    node. As long as the expression contains no
	    whitespace, no brackets of any type, quotes,
	    double-quotes, <literal moreinfo="none">$</literal> character,
	    nor <literal moreinfo="none">@</literal> character, it is treated as a literal token
	    which evaluates to itself.
	  </para>
	</simplesect></section><section id="xpath" role="argtype"><title>xPath</title><simplesect role="description"><title>Description</title>
	  <para>
	    XSH2 can evaluate XPath expressions as defined in W3C
	    recommendation at <ulink url="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</ulink>
	    with only a little limitation on use of syntactically
	    ignorable whitespace. 
	    (Nice interactive XPath tutorials and references
	    can be found at <ulink url="http://www.zvon.org">http://www.zvon.org</ulink>.)
	  </para>
	  <para>
	    In order to allow XSH2 to use white-space as a command
	    argument delimiter (which is far more convenient to type
	    than, say, commas), the use of white-space in XPath is
	    slightly restricted. Thus, in XSH2, white-space can only occur in
	    those parts of an XPath expression, that are surrounded by
	    either brackets, square brackets, single or double quotes.
	    So, for example, otherwise valid XPath expression like
	  </para>
	  <programlisting format="linespecific">/ foo / bar [ @baz = "bar" ]</programlisting> 
	  <para>
	    should in XSH2 be written as either of
	  </para>
	  <programlisting format="linespecific">/foo/bar[ @baz = "bar" ]</programlisting> 
	  <para>
	    avoiding any white-space outside the square brackets,
	    or completely enclosed in brackets as in
	  </para>
	  <programlisting format="linespecific">( / foo / bar [ @baz = "bar" ] ).</programlisting>
	  <para>
	    XSH2 provides a number of powerful XPath extension
	    functions, listed below and described in separate
	    sections. XPath extension
	    functions by default belong to XSH2 namespace
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal> with
	    a namespace prefix set to <literal moreinfo="none">xsh</literal>. A
	    program may however call the <link linkend="xpath_extensions_command">xpath-extensions</link> command to map XSH2
	    XPath extension functions into the default namespace, so
	    that they may be used directly without any prefix.
	  </para>
	  <para>
	    XPath extension functions defined in XSH2:
	    <simplelist type="inline"><member><link linkend="doc_function">xsh:doc</link></member><member><link linkend="document_uri_function">xsh:document-uri</link></member><member><link linkend="filename_function">xsh:filename</link></member><member><link linkend="base_uri_function">xsh:base-uri</link></member><member><link linkend="resolve_uri_function">xsh:resolve-uri</link></member><member><link linkend="lineno_function">xsh:lineno</link></member><member><link linkend="var_function">xsh:var</link></member><member><link linkend="matches_function">xsh:matches</link></member><member><link linkend="match_function">xsh:match</link></member><member><link linkend="grep_function">xsh:grep</link></member><member><link linkend="substr_function">xsh:substr</link></member><member><link linkend="reverse_function">xsh:reverse</link></member><member><link linkend="lc_function">xsh:lc</link></member><member><link linkend="uc_function">xsh:uc</link></member><member><link linkend="lcfirst_function">xsh:lcfirst</link></member><member><link linkend="ucfirst_function">xsh:ucfirst</link></member><member><link linkend="same_function">xsh:same</link></member><member><link linkend="max_function">xsh:max</link></member><member><link linkend="min_function">xsh:min</link></member><member><link linkend="strmax_function">xsh:strmax</link></member><member><link linkend="strmin_function">xsh:strmin</link></member><member><link linkend="sum_function">xsh:sum</link></member><member><link linkend="join_function">xsh:join</link></member><member><link linkend="subst_function">xsh:subst</link></member><member><link linkend="sprintf_function">xsh:sprintf</link></member><member><link linkend="serialize_function">xsh:serialize</link></member><member><link linkend="parse_function">xsh:parse</link></member><member><link linkend="current_function">xsh:current</link></member><member><link linkend="path_function">xsh:path</link></member><member><link linkend="if_function">xsh:if</link></member><member><link linkend="new_attribute_function">xsh:new-attribute</link></member><member><link linkend="new_element_function">xsh:new-element</link></member><member><link linkend="new_element_ns_function">xsh:new-element-ns</link></member><member><link linkend="new_text_function">xsh:new-text</link></member><member><link linkend="new_comment_function">xsh:new-comment</link></member><member><link linkend="new_pi_function">xsh:new-pi</link></member><member><link linkend="new_cdata_function">xsh:new-cdata</link></member><member><link linkend="new_chunk_function">xsh:new-chunk</link></member><member><link linkend="map_function">xsh:map</link></member><member><link linkend="evaluate_function">xsh:evaluate</link></member><member><link linkend="split_function">xsh:split</link></member><member><link linkend="times_function">xsh:times</link></member><member><link linkend="id2_function">xsh:id2</link></member><member><link linkend="lookup_function">xsh:lookup</link></member><member><link linkend="document_function">xsh:document</link></member><member><link linkend="documents_function">xsh:documents</link></member><member><link linkend="span_function">xsh:span</link></member><member><link linkend="context_function">xsh:context</link></member></simplelist></para>
	  <example>
	    <title>Open a document and count all sections containing a
	      subsection
	    </title>
	    <programlisting format="linespecific">xsh $scratch/&gt; <userinput moreinfo="none">$v := open mydocument1.xml;</userinput>
xsh $v/&gt; <userinput moreinfo="none">$k := open mydocument2.xml;</userinput>
xsh $k/&gt; <userinput moreinfo="none">count //section[subsection];</userinput># searches k
xsh $k/&gt; <userinput moreinfo="none">count $v//section[subsection];</userinput># searches v
</programlisting>
	  </example>
	</simplesect></section><section id="block" role="argtype"><title>block</title><simplesect role="description"><title>Description</title>
	  <para>
	    a block of semicolon-separated
	     XSH2 commands enclosed within braces.
	  </para>
	  <example>
	    <title>Count paragraphs in each chapter</title>
	    <programlisting format="linespecific">$i=0;
foreach //chapter {
  $c=count(./para);
  $i=$i+1;
  print "$c paragraphs in chapter no.$i";
}
</programlisting>
	  </example>
	</simplesect></section><section id="command" role="argtype"><title>command</title><simplesect role="description"><title>Description</title>
	  <para>
	    XSH2 command consists of a command name
	    and possibly command parameters separated
	    by whitespace. Individual <link linkend="command">XSH2 commands</link> are
	    separated with a semicolon. 
	    A command may optionally be followed
	    by an output redirection directive
	    (see <link linkend="binding_shell">binding_shell</link> for output
	    redirection to a command
	    and <link linkend="Variables">Variables</link> for output
	    redirection to variable).
	    Most commands have aliases, so for example
	    <link linkend="prune_command">remove</link> command
	    may also be invoked as <literal moreinfo="none">del</literal> or
	    <literal moreinfo="none">rm</literal>.
	  </para>
	  <para>XSH2 recognizes the following commands
	    (not including aliases):
	    <simplelist type="inline"><member><link linkend="try_catch">try</link></member><member><link linkend="if">if</link></member><member><link linkend="unless">unless</link></member><member><link linkend="while">while</link></member><member><link linkend="do_command">do</link></member><member><link linkend="eval_command">eval</link></member><member><link linkend="foreach">foreach</link></member><member><link linkend="undef">undef</link></member><member><link linkend="def">def</link></member><member><link linkend="assign_command">assign</link></member><member><link linkend="my_command">my</link></member><member><link linkend="local_command">local</link></member><member><link linkend="options_command">settings</link></member><member><link linkend="list_defs_command">defs</link></member><member><link linkend="ifinclude_command">ifinclude</link></member><member><link linkend="include_command">include</link></member><member><link linkend="apropos_command">apropos</link></member><member><link linkend="help_command">help</link></member><member><link linkend="exec_command">exec</link></member><member><link linkend="xslt_command">xslt</link></member><member><link linkend="files_command">documents</link></member><member><link linkend="set_filename_command">set_filename</link></member><member><link linkend="var_command">variables</link></member><member><link linkend="copy_command">copy</link></member><member><link linkend="xcopy_command">xcopy</link></member><member><link linkend="cd_command">lcd</link></member><member><link linkend="insert_command">insert</link></member><member><link linkend="wrap_command">wrap</link></member><member><link linkend="wrap_span_command">wrap-span</link></member><member><link linkend="xinsert_command">xinsert</link></member><member><link linkend="move_command">move</link></member><member><link linkend="xmove_command">xmove</link></member><member><link linkend="clone_command">clone</link></member><member><link linkend="normalize_command">normalize</link></member><member><link linkend="strip_ws_command">strip-whitespace</link></member><member><link linkend="list_command">ls</link></member><member><link linkend="c14n_command">canonical</link></member><member><link linkend="count_command">count</link></member><member><link linkend="change_namespace_uri_command">change-ns-uri</link></member><member><link linkend="change_namespace_prefix_command">change-ns-prefix</link></member><member><link linkend="set_namespace_command">set-ns</link></member><member><link linkend="declare_namespace_command">declare-ns</link></member><member><link linkend="set_command">set</link></member><member><link linkend="expression_command">get</link></member><member><link linkend="perl_command">perl</link></member><member><link linkend="prune_command">remove</link></member><member><link linkend="print_command">print</link></member><member><link linkend="sort_command">sort</link></member><member><link linkend="map_command">map</link></member><member><link linkend="rename_command">rename</link></member><member><link linkend="hash_command">hash</link></member><member><link linkend="close_command">close</link></member><member><link linkend="index_command">index</link></member><member><link linkend="open_command">open</link></member><member><link linkend="create_command">create</link></member><member><link linkend="save_command">save</link></member><member><link linkend="set_dtd_command">set-dtd</link></member><member><link linkend="list_dtd_command">dtd</link></member><member><link linkend="set_enc_command">set-enc</link></member><member><link linkend="set_standalone_command">set-standalone</link></member><member><link linkend="print_enc_command">enc</link></member><member><link linkend="validate_command">validate</link></member><member><link linkend="exit_command">exit</link></member><member><link linkend="process_xinclude_command">process-xinclude</link></member><member><link linkend="chxpath_command">cd</link></member><member><link linkend="pwd_command">pwd</link></member><member><link linkend="locate_command">locate</link></member><member><link linkend="xupdate_command">xupdate</link></member><member><link linkend="verbose">verbose</link></member><member><link linkend="test_mode">test-mode</link></member><member><link linkend="run_mode">run-mode</link></member><member><link linkend="debug">debug</link></member><member><link linkend="nodebug">nodebug</link></member><member><link linkend="version">version</link></member><member><link linkend="validation">validation</link></member><member><link linkend="recovering">recovering</link></member><member><link linkend="parser_expands_entities">parser-expands-entities</link></member><member><link linkend="keep_blanks">keep-blanks</link></member><member><link linkend="pedantic_parser">pedantic-parser</link></member><member><link linkend="complete_attributes">parser-completes-attributes</link></member><member><link linkend="indent">indent</link></member><member><link linkend="empty_tags">empty-tags</link></member><member><link linkend="skip_dtd">skip-dtd</link></member><member><link linkend="parser_expands_xinclude">parser-expands-xinclude</link></member><member><link linkend="load_ext_dtd">load-ext-dtd</link></member><member><link linkend="encoding">encoding</link></member><member><link linkend="query_encoding">query-encoding</link></member><member><link linkend="quiet">quiet</link></member><member><link linkend="cdonopen">switch-to-new-documents</link></member><member><link linkend="backups">backups</link></member><member><link linkend="nobackups">nobackups</link></member><member><link linkend="fold_command">fold</link></member><member><link linkend="unfold_command">unfold</link></member><member><link linkend="redo_command">redo</link></member><member><link linkend="next_command">next</link></member><member><link linkend="prev_command">prev</link></member><member><link linkend="last_command">last</link></member><member><link linkend="return_command">return</link></member><member><link linkend="throw_command">throw</link></member><member><link linkend="catalog_command">catalog</link></member><member><link linkend="iterate">iterate</link></member><member><link linkend="registerns_command">register-namespace</link></member><member><link linkend="unregisterns_command">unregister-namespace</link></member><member><link linkend="registerns_xhtml_command">register-xhtml-namespace</link></member><member><link linkend="registerns_xsh_command">register-xsh-namespace</link></member><member><link linkend="registerfunc_command">register-function</link></member><member><link linkend="unregisterfunc_command">unregister-function</link></member><member><link linkend="stream_process_command">stream</link></member><member><link linkend="namespaces_command">namespaces</link></member><member><link linkend="xpath_completion_command">xpath-completion</link></member><member><link linkend="xpath_axis_completion_command">xpath-axis-completion</link></member><member><link linkend="doc_info_command">doc-info</link></member><member><link linkend="xpath_extensions_command">xpath-extensions</link></member><member><link linkend="lineno_command">lineno</link></member><member><link linkend="edit_string_command">edit-string</link></member><member><link linkend="edit_command">edit</link></member><member><link linkend="call_command">call</link></member></simplelist></para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="block">block</link></para></simplesect></section><section id="document" role="argtype"><title>document</title><simplesect role="description"><title>Description</title>
	  <para>
	    A document is specified by arbitrary
	    <link linkend="exp">expression</link> which evaluates
	    to a non-empty node-list.
	    From this node-list, the first node
	    is taken and its owner document is used.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="Variables">Variables</link>, <link linkend="assign_command">assign</link>, <link linkend="my_command">my</link>, <link linkend="local_command">local</link></para></simplesect></section><section id="enc_string" role="argtype"><title>enc_string</title><simplesect role="description"><title>Description</title>
	  <para>
	    An <link linkend="exp">expression</link> which evaluates to a valid encoding
	    name, e.g. to utf-8, utf-16, iso-8859-1, iso-8859-2,
	    windows-1250 etc. As with <link linkend="filename">filename</link>,
	    as long as the expression doesn't contain special characters
	    like braces, brackets, quotes, <literal moreinfo="none">$</literal>, nor
	    <literal moreinfo="none">@</literal>, it is taken as a literal and
	    evaluates to itself.
	  </para>
	</simplesect></section><section id="exp" role="argtype"><title>expression</title><simplesect role="description"><title>Description</title>
	  <para>An XSH2 expression can be one of the following constructs:</para>
	  <orderedlist continuation="restarts" inheritnum="ignore">
	    <listitem>
	      <para>
		XPath 1.0 expression with the following restriction: 
		whitespace is only allowed within parts the expression
		enclosed in quotes (literal strings) or brackets (XPath
		has two types of brackets - plain and square). Thus, while
		<literal moreinfo="none">/ foo / bar</literal> is a valid XPath expression
		matching element named bar under root element foo, in XSH2 this
		expression must be written as <literal moreinfo="none">/foo/bar</literal> or
		<literal moreinfo="none">(/ foo / bar)</literal> or
		<literal moreinfo="none">(/foo/bar)</literal> etc.
		The reason for this restriction is simple: 
                XSH2, like most shell
		languages, uses whitespace as argument delimiter so it must
		be able to determine expression boundaries
		(otherwise, <literal moreinfo="none">/ bar / foo</literal> could be
		anything between one and four expressions).
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		In certain contexts, usually when a filename or a node
		name is
		expected as an argument, bareword (otherwise XPath) 
		expressions are
		evaluated in a non-standard way: as long as the
		expression contains no whitespace, no brackets of any
		kind, quotes, double-quotes, <literal moreinfo="none">$</literal>
		character, nor <literal moreinfo="none">@</literal> character, 
		it is treated as a literal
		token which evaluates to itself. 
		This usually happens if a file name or element
		name is expected, but some other commands, like
		<link linkend="print_command">print</link>,
		evaluate its arguments in this way. In order to force an
		XPath evaluation in such situations, the entire expression
		should be enclosed with brackets <literal moreinfo="none">(...)</literal>.
		For example, with
		<link linkend="open_command">open</link> command, <literal moreinfo="none">open
		file</literal> or <literal moreinfo="none">open "file"</literal> both
		open a file whose name is <literal moreinfo="none">file</literal>
		(literally) whereas <literal moreinfo="none">open (file)</literal> or
		<literal moreinfo="none">open @file</literal> compute the file name
		by evaluating <literal moreinfo="none">(file)</literal> or
		<literal moreinfo="none">@file</literal> respectively, as XPath
		expressions.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
  		Perl blocks. These are enclosed in braces like: 
		<literal moreinfo="none">{ perl-code }</literal>.
		Perl expressions can be used to evaluate more complicated
		things, like complex string expressions, regexp matches,
		perl commands, etc. In short, arbitrary perl.
		Of course, things like <literal moreinfo="none">{`ls`}</literal> work
		too, and that's why we don't need to define shell-like backticks
		in XSH2 itself.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Result of one XSH2 command can be directly passed as an argument
		to another. This is done using &amp;{ xsh-code } expressions.
		Most XSH2 commands always return <literal moreinfo="none">undef</literal> or 1,
		but some do return a value, usually a node-list. Examples of
		such commands are
		<link linkend="open_command">open</link>, <link linkend="copy_command">copy</link>, <link linkend="move_command">move</link>, <link linkend="wrap_command">wrap</link>, <link linkend="edit_command">edit</link>, or <link linkend="xslt_command">xslt</link>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Large blocks of literal data can be passed to commands
		via "here document" expressions
		<literal moreinfo="none">&lt;&lt;EOF</literal>,
		<literal moreinfo="none">&lt;&lt;'EOF'</literal>,
		&lt;&lt;"EOF"<literal moreinfo="none"></literal>, where
		<literal moreinfo="none">EOF</literal> is an arbitrary
		<literal moreinfo="none">ID</literal> string.
		<literal moreinfo="none">&lt;&lt;EOF</literal> and
		<literal moreinfo="none">&lt;&lt;"EOF"</literal> are equivalent, and
		are subject to interpolation of
		<literal moreinfo="none">${...}</literal> constructs, where as
		<literal moreinfo="none">&lt;&lt;'EOF'</literal> does not. The result
		of evaluation of these three is the literal content
		(with <literal moreinfo="none">${...}</literal> possibly interpolated)
		of the script starting at the following line and
		ending at a line containing just
		<literal moreinfo="none">EOF</literal>. <literal moreinfo="none">&lt;&lt;{EOF}</literal>
		and <literal moreinfo="none">&lt;&lt;(EOF)</literal> are implemented
		too, but I'm not sure they are of any use since
		putting the expression in ( ) or { } has the same
		effect.
	      </para>
	    </listitem>
	  </orderedlist>
	  <para>
	    XPath expressions (and their filename variant) are subject
	    to interpolation of substrings of the form
	    <literal moreinfo="none">${...}</literal> (called interpolators), where
	    <literal moreinfo="none">...</literal> can be of several different forms,
	    described below. The interpolation can be suppressed
	    by preceding the <literal moreinfo="none">$</literal> sign with a backslash.
	  </para>
	  <para>
	    Substrings of the form <literal moreinfo="none">${id}</literal> or
	    <literal moreinfo="none">${$id}</literal> are interpolated with the
	    value of the variable named <literal moreinfo="none">$id</literal>.
	  </para>
	  <para>
	    Interpolators of the form
	    <literal moreinfo="none">${{</literal> and <literal moreinfo="none">}}</literal>
	    evaluate their contents
	    as a Perl expression (in very much the same way as the
	    <link linkend="perl_command">perl</link> command) and interpolate
	    to the resulting value.
	  </para>
	  <para>
	    Interpolators of the form
	    <literal moreinfo="none">${(</literal> and <literal moreinfo="none">)}</literal>
	    evaluate their contents as an XPath expression and interpolates to
	    a string value of the result.
	  </para>
	  <para>
	    Substrings of the form <literal moreinfo="none">\${</literal>
	    interpolate to <literal moreinfo="none">${</literal>
	    (as a means for escaping <literal moreinfo="none">${...}</literal>
	    in an expression).
	  </para>
	  <para>
	    Expressions are evaluated by XSH2 commands themselves, so
	    the exact value an expression evaluates to, is also
	    command-dependent. There are commands that can handle
	    all data types, but some commands expect their arguments to
	    evaluate only to specific kinds of values.
	    As already mentioned above, commands
	    expecting a filename or a node name usually evaluate
	    simple expressions not containing any special characters
	    as literal strings, whereas commands expecting strings
	    evaluate all expressions so that they get a string value
	    (e.g. by converting a node-set to its text content).
	    Similarly, commands expecting a node-set usually convert
	    strings to a small XML fragments, while commands
	    expecting a single document node usually convert
	    node-sets to a document node by taking the owner
	    document of the first element in the node-set.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">$a = "bar";              # $a contains: bar</programlisting>
    	    <programlisting format="linespecific">$b = $a;                 # $b contains: bar</programlisting>
	    <programlisting format="linespecific">$b = "$a";               # $b contains: $a</programlisting>
	    <programlisting format="linespecific">$b = "${a}";             # $b contains: bar</programlisting>
            <programlisting format="linespecific">$b = {$a};               # $b contains: bar</programlisting>
            <programlisting format="linespecific">$b = //creature;         # $b contains a node-set</programlisting>
            <programlisting format="linespecific">ls $b;                   # prints the node-set as XML in document order</programlisting>
            <programlisting format="linespecific">count $b;                # prints number of nodes in the node-set</programlisting>
            <programlisting format="linespecific">echo count($b);          # the same</programlisting>
            <programlisting format="linespecific">$c = string($b[1]/@name) # $c contains string value of //creature[1]/@name (e.g. Bilbo)</programlisting>
            <programlisting format="linespecific">echo //creature          # prints: //creature</programlisting>
            <programlisting format="linespecific">echo (//creature)        # evaluates (//creature) as XPath and prints the
# text content of the resulting node-set</programlisting>
	    <programlisting format="linespecific"></programlisting>
	    <programlisting format="linespecific">echo { join(",",split(//,$a)) }              # prints: b,a,r</programlisting>
	    <programlisting format="linespecific">echo ${{ join(",",split(//,$a)) }}           # the same</programlisting>
	    <programlisting format="linespecific">echo "${{ join(",",split(//,$a)) }}"         # the same</programlisting>
	    <programlisting format="linespecific">echo "${(//creature[1]/@name)}"              # prints e.g.: Bilbo</programlisting>
	    <programlisting format="linespecific">echo ${(//creature[1]/@name)}                # the same</programlisting>
	    <programlisting format="linespecific">echo //creature[1]/@name                     # the same</programlisting>
	    <programlisting format="linespecific">echo string(//creature[1]/@name)             # the same</programlisting>
	    <programlisting format="linespecific">echo (//creature[1]/@name)                   # the same</programlisting>
	  </informalexample>
	  <example>
	    <title>In-line documents</title>
	    <programlisting format="linespecific">$a="bar"</programlisting>
	    <programlisting format="linespecific">echo foo &lt;&lt;END baz;
xx ${a} yy
END
# prints foo xx bar yy baz</programlisting>
	    <programlisting format="linespecific">echo foo &lt;&lt;"END" baz;
xx ${a} yy
END
# same as above</programlisting>
	    <programlisting format="linespecific">echo foo &lt;&lt;'END' baz;
xx ${a} yy
END
# prints foo xx $a yy baz</programlisting>
	  </example>
	  <example>
	    <title>Expressions returning result of a XSH2 command</title>
	    <programlisting format="linespecific">copy &amp;{ sort --key @best_score --numeric //player } into .;</programlisting>
	  </example>
	</simplesect></section><section id="loc" role="argtype"><title>location</title><simplesect role="description"><title>Description</title>
	  <para>One of: 
	    <literal moreinfo="none">after</literal>, 
	    <literal moreinfo="none">before</literal>, 
	    <literal moreinfo="none">into</literal>,
	    <literal moreinfo="none">append</literal>,
	    <literal moreinfo="none">prepend</literal>,
	    <literal moreinfo="none">replace</literal>.
	  </para>
	  <para>
	    This argument is required by all commands that insert
	    nodes to a document in some way to a destination described
	    by an XPath expression. The meaning of the values listed
	    above is supposed be obvious in most cases, however the
	    exact semantics for location argument values depends on
	    types of both the source node and the target node.
	  </para>
	  <para>
	    <literal moreinfo="none">after/before</literal> place the node right
	    after/before the destination node, except for when the
	    destination node is a document node or one of the source
	    nodes is an attribute: If the destination node is a
	    document node, the source node is attached to the
	    end/beginning of the document (remember: there is no
	    "after/before a document").  If both the source and
	    destination nodes are attributes, then the source node is
	    simply attached to the element containing the destination
	    node (remember: there is no order on attribute nodes). If
	    the destination node is an attribute but the source node
	    is of a different type, then the textual content of the
	    source node is appended to the value of the destination
	    attribute (i.e. in this case after/before act just as
	    append/prepend).
	  </para>
	  <para>
	    <literal moreinfo="none">append/prepend</literal> appends/prepends the
	    source node to the destination node. If the destination
	    node can contain other nodes (i.e. it is an element or a
	    document node) then the entire source node is attached to
	    it. In case of other destination node types, the textual
	    content of the source node is appended/prepended to the
	    content of the destination node.
	  </para>
	  <para>
	    <literal moreinfo="none">into</literal> can also be used to place
	    the source node to the end of an element (in the same way
	    as <literal moreinfo="none">append</literal>), to attach an attribute
	    to an element, or, if the destination node is a text node,
	    cdata section, processing-instruction, attribute or comment,
	    to replace its textual content with the textual content of 
	    the source node.
	  </para>
	  <para>
	    <literal moreinfo="none">replace</literal> replaces the entire destination
	    node with the source node except for the case when the
	    destination node is an attribute and the source node is
	    not. In such a case only the value of the destination
	    attribute is replaced with the textual content of the
	    source node. Note also that document node can never be
	    replaced.
	  </para>
	</simplesect></section><section id="nodetype" role="argtype"><title>node-type</title><simplesect role="description"><title>Description</title>
	  <para>
	    One of: element, attribute, text, cdata, comment, chunk
	    and (EXPERIMENTALLY!) entity_reference.  A
	    chunk is a character string which forms a well-balanced
	    piece of XML.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">add element hobbit into //middle-earth/creatures;
add attribute 'name="Bilbo"' into //middle-earth/creatures/hobbit[last()];
add chunk '&lt;hobbit name="Frodo"&gt;A small guy from &lt;place&gt;Shire&lt;/place&gt;.&lt;/hobbit&gt;' 
  into //middle-earth/creatures;
</programlisting>
	  </informalexample>
	</simplesect></section><section id="perl_code" role="argtype"><title>perl-code</title><simplesect role="description"><title>Description</title>
	  <para>
	    A block of Perl code enclosed in braces. 
	    All XSH2 variables are transparently accessible from
	    the Perl code as well.
	  </para>
	  <para>
	    For more information about embedded Perl code in XSH2, predefined
	    functions etc., see <link linkend="Perl_shell">Perl_shell</link>.
	  </para>
	  <informalexample>
	    <programlisting format="linespecific">xsh&gt; <userinput moreinfo="none">$i={ "foo" };</userinput>
xsh&gt; <userinput moreinfo="none">perl { echo "$i-bar\n"; }</userinput># prints foo-bar
xsh&gt; <userinput moreinfo="none">echo { "$i-bar" }</userinput># very much the same as above
</programlisting>
	  </informalexample>
	</simplesect></section><section id="subname" role="argtype"><title>sub-routine name</title><simplesect role="description"><title>Description</title>
	  <para>
	    A sub-routine name is an identifier
	    matching the following regular
	    expression <literal moreinfo="none">[a-zA-Z_][a-zA-Z0-9_]*</literal>,
	    i.e., it must be at least one character long, must
	    beginning with a letter or
	    underscore, and may only containing letters, underscores, and
	    digits.
	  </para>
	</simplesect></section></section>
  <section id="function">
    <title>XPath Extension Function Reference</title>
  <section id="base_uri_function" role="function"><title>xsh:base-uri</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:base-uri(node-set?)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Returns base URI of the first node in the node-set (or
	  the current node).  The function should work on both XML and
	  HTML documents even if base mechanisms for these are
	  completely different. It returns the base as defined in RFC
	  2396 sections "5.1.1. Base URI within Document Content" and
	  "5.1.2. Base URI from the Encapsulating Entity". However it
	  does not return the document base (5.1.3), use
	  document-uri() for this.
	  </para>
	</simplesect></section><section id="context_function" role="function"><title>xsh:context</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:context(node-set NODE, float BEFORE, float AFTER)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node-set of sibling nodes surrounding NODE. The
	    span consists of (up to) BEFORE-many nodes immediately
	    preceding NODE, the NODE itself, and (up to) AFTER-many
	    nodes immediately following NODE.  If the AFTER is not
	    given, AFTER is set equal to BEFORE.
	  </para>
	</simplesect></section><section id="current_function" role="function"><title>xsh:current</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:current()</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function (very similar to XSLT <literal moreinfo="none">current()</literal>
	    extension function) returns a node-set having the
	    current node as its only
	    member.
	  </para>
	</simplesect></section><section id="doc_function" role="function"><title>xsh:doc</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:doc(node-set)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node-set consisting of the owner document nodes
	    of all nodes in the given node-set.
	  </para>
	</simplesect></section><section id="document_function" role="function"><title>xsh:document</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:document(string URL)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Looks up among the currently open document the one whose
	    filename is same as the given URL and returns the
	    corresponding document node.  If no document's filename
	    matches exactly the given URL, then several heuristic
	    matches are tried: if the URI is a relative filename, it
	    is tilde-expanded and resolved (using the current working
	    directory as a base) and the lookup is restarted with the
	    absolute filename; finally, a lookup identifying filenames
	    with URLs of the file:// protocol is attempted.  If the
	    lookup fails completely, an empty node set is returned.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="hash_command">hash</link></para></simplesect></section><section id="document_uri_function" role="function"><title>xsh:document-uri</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:document-uri(node-set?)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Returns URI of the document containing
	    the first node in the given node-set.
	    If called without arguments, or if the node-set is 
	    empty, returns filename of the document containing the current node.
	  </para>
	</simplesect></section><section id="documents_function" role="function"><title>xsh:documents</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:documents()</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node-set consisting of the document
	    nodes of all currently open documents.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="hash_command">hash</link></para></simplesect></section><section id="evaluate_function" role="function"><title>xsh:evaluate</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:evaluate(string XPATH)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function is very similar to EXSLT
	    <literal moreinfo="none">dynamic:evaluate</literal> function.  The description
	    below is almost literally taken from the <ulink url="http://www.exslt.org/dyn/functions/map/index.html">EXSLT
	    specification</ulink>.
	  </para>
	  <para>
	    The <literal moreinfo="none">xsh:evaluate</literal> function evaluates a string as an XPath expression
	    and returns the resulting value, which might be a boolean, number,
	    string, node set, result tree fragment or external object. The sole
	    argument is the string to be evaluated. 
	  </para>
	  <para>
	    The string is always evaluated exactly as if it had been literally
	    included in place of the call to the <literal moreinfo="none">xsh:evaluate</literal> function.
	  </para>
	  <para>
	    In other words, the context information used when evaluating the
	    XPath expression passed as the argument to the <literal moreinfo="none">xsh:evaluate</literal>
	    function is exactly the same as the context information used when
	    evaluating the <literal moreinfo="none">xsh:evaluate</literal> function. This context information
	    includes: 
	  </para>
	  <orderedlist continuation="restarts" inheritnum="ignore">
	    <listitem>
	      <para>
		the context node, such that paths are evaluated relative to the
		context node at the point where the <literal moreinfo="none">xsh:evaluate</literal> function is
		called
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		the context position, such that the expression can contain
		calls to the position function
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		the context size, such that the expression can contain calls to
		the last function
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		variable bindings, such that the expression can contain
		variable references
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		function library, such that the expression can contain calls to
		extension functions
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		namespace declarations, such that paths can contain prefixes
		the current node, such that the expression can contain calls to
		the current function
	      </para>
	    </listitem>
	  </orderedlist>
	  <para>
	    If the expression string passed as the second argument is an
	    invalid XPath expression (including an empty string), this function
	    returns an empty node set. 
	  </para>
	  <para>
	    You should only use this function if the expression must be
	    constructed dynamically - otherwise it is much more efficient to
	    use the expression literally. For expressions that simply give an
	    element or attribute's name (to select a child element or
	    attribute), it is more efficient to use an expression 
	    in the style: 
	  </para>
	  <programlisting format="linespecific">*[name() = $expression]</programlisting>	      
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="map_function">xsh:map</link></para></simplesect></section><section id="filename_function" role="function"><title>xsh:filename</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:filename(node-set?)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Same as xsh:document-uri();</para>
	</simplesect></section><section id="grep_function" role="function"><title>xsh:grep</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:grep(node-set NODES, string PATTERN)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node set consisting of those nodes of
	    <literal moreinfo="none">NODES</literal> whose content 
	    (as returned by the built-in XPath 
	    function <literal moreinfo="none">string()</literal>)
	    matches the regular expression <literal moreinfo="none">PATTERN</literal>.
	  </para>
	</simplesect></section><section id="id2_function" role="function"><title>xsh:id2</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:id2(node-set DOC, string IDs)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function is like XPath built-in <literal moreinfo="none">id(IDs)</literal>
            function, except that it operates on the document
            specified in the first argument. It returns a node-set
            consisting of nodes that belong to the document DOC
            and whose ID belongs to the list of space separated
            IDs specified in the second argument.
	  </para>
	</simplesect></section><section id="if_function" role="function"><title>xsh:if</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">object xsh:if(object CONDITION, object YES, object NO)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function returns the <literal moreinfo="none">YES</literal> object
	    if <literal moreinfo="none">CONDITION</literal> is an non-empty
	    node-set or a string, boolean or integer 
	    evaluating to non-zero boolean. Otherwise the
	    <literal moreinfo="none">NO</literal> object is returned.
	  </para>
	</simplesect></section><section id="join_function" role="function"><title>xsh:join</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:join(string DELIM, object EXPRESSION,...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Joins the separate string values computed from 
	    <literal moreinfo="none">EXPRESSION</literal>(s) into a single
	    string with fields separated by the 
	    value of <literal moreinfo="none">DELIM</literal>,
	    and returns that new string.
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    joins string values of individual nodes.
	  </para>
	</simplesect></section><section id="lc_function" role="function"><title>xsh:lc</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:lc(string STR)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a lowercased version of <literal moreinfo="none">STR</literal>.
	  </para>
	</simplesect></section><section id="lcfirst_function" role="function"><title>xsh:lcfirst</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:lcfirst(string STR)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns the value of <literal moreinfo="none">STR</literal>
	    with the first character lowercased.
	  </para>
	</simplesect></section><section id="lineno_function" role="function"><title>xsh:lineno</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:lineno(node-set)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>Returns line number of the occurrence of
	    the first node in the given node-set in its original XML
	    document (if available).
	  </para>
	</simplesect></section><section id="lookup_function" role="function"><title>xsh:lookup</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:lookup(string VARNAME, string KEY)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function is similar to XSLT <literal moreinfo="none">key()</literal>
	    function. It returns a node-set
	    stored in a hash VARNAME under the key KEY.
	    The VARNAME must be a name of a lexical or global
	    XSH variable containing a Perl hash reference.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="hash_command">hash</link></para></simplesect></section><section id="map_function" role="function"><title>xsh:map</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:map(node-set NODE, string XPATH)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function is very similar to EXSLT
	    <literal moreinfo="none">dynamic:map</literal> function.  The description
	    below is almost literally taken from the <ulink url="http://www.exslt.org/dyn/functions/map/index.html">EXSLT
	    specification</ulink>.
	  </para>
	  <para>
	    The <literal moreinfo="none">xsh:map</literal> function evaluates the 
	    expression passed as the second argument for each of 
	    the nodes passed as the first argument, and returns a 
	    node-set of those values. 
	  </para>
	  <para>
	    The expressions are evaluated relative to the nodes 
	    passed as the first argument. In other words, the value 
	    for each node is calculated by evaluating the XPath 
	    expression with all context information being the same as 
	    that for the call to the <literal moreinfo="none">xsh:map</literal>
	    function itself, except for the following: 
	  </para>
	  <para>
	    1) the context node is the node whose value is being
	    calculated, 2) the context position is the position of the
	    node within the node set passed as the first argument to
	    the <literal moreinfo="none">xsh:map</literal> function, arranged in
	    document order, and 3) the context size is the number of
	    nodes passed as the first argument to the dyn:map function.
	  </para>
	  <para>
	    If the expression string passed as the second argument is
	    an invalid XPath expression (including an empty string),
	    this function returns an empty node set.
	  </para>
	  <para>
	    If <literal moreinfo="none">XPATH</literal> evaluates as a node set, the
	    <literal moreinfo="none">xsh:map</literal> function returns the union of
	    the node sets returned by evaluating the expression for
	    each of the nodes in the first argument. Note that this
	    may mean that the node set resulting from the call to the
	    <literal moreinfo="none">xsh:map</literal> function contains a different
	    number of nodes from the number in the node set passed as
	    the first argument to the function.
	  </para>
	  <para>
	    If <literal moreinfo="none">XPATH</literal> evaluates as a number, the
	    <literal moreinfo="none">xsh:map</literal> function returns a node set
	    containing one <literal moreinfo="none">xsh:number</literal> element
	    (namespace
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal>) for
	    each node in the node set passed as the first argument to
	    the dyn:map function, in document order. The string value
	    of each <literal moreinfo="none">xsh:number</literal> element is the same
	    as the result of converting the number resulting from
	    evaluating the expression to a string as with the number
	    function, with the exception that Infinity results in an
	    <literal moreinfo="none">xsh:number</literal> holding the highest number
	    the implementation can store, and -Infinity results in an
	    <literal moreinfo="none">xsh:number</literal> holding the lowest number
	    the implementation can store.
	  </para>
	  <para>
	    If <literal moreinfo="none">XPATH</literal> evaluates as a boolean, the
	    <literal moreinfo="none">xsh:map</literal> function returns a node set
	    containing one <literal moreinfo="none">xsh:boolean</literal> element
	    (namespace
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal>) for
	    each node in the node set passed as the first argument to
	    the <literal moreinfo="none">xsh:map</literal> function, in document
	    order. The string value of each
	    <literal moreinfo="none">xsh:boolean</literal> element is
	    <literal moreinfo="none">true</literal> if the expression evaluates as
	    true for the node, and is empty if the expression evaluates as
	    false.
	  </para>
	  <para>
	    Otherwise, the <literal moreinfo="none">xsh:map</literal> function returns
	    a node set containing one <literal moreinfo="none">xsh:string</literal>
	    element (namespace
	    <literal moreinfo="none">http://xsh.sourceforge.net/xsh/</literal>) for
	    each node in the node set passed as the first argument to
	    the <literal moreinfo="none">xsh:map</literal> function, in document
	    order. The string value of each
	    <literal moreinfo="none">xsh:string</literal> element is the same as the
	    result of converting the result of evaluating the
	    expression for the relevant node to a string as with the
	    string function.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="evaluate_function">xsh:evaluate</link></para></simplesect></section><section id="match_function" role="function"><title>xsh:match</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:match(string STR,string PATTERN,string OPTIONS)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Searches a given string for a pattern match
	    specified by a regular expression <literal moreinfo="none">PATTERN</literal>
	    and returns a node-set consisting of
	    <literal moreinfo="none">&lt;xsh:string&gt;</literal>
	    elements containing portions of the string matched
	    by the pattern subexpressions enclosed in parentheses.
	    The OPTIONS string may contain the following flags:
	    <literal moreinfo="none">c</literal> - do not reset search position on a failed match when /g is in effect;
	    <literal moreinfo="none">g</literal> - match globally, i.e. find all occurrences;
	    <literal moreinfo="none">i</literal> - do case insensitive search;
	    <literal moreinfo="none">m</literal> - treat string as multiple lines 
	    (change "^" and "$" from matching the start or end of the string to matching the start or end
	    of any line anywhere within the string)
	    <literal moreinfo="none">o</literal> - compile pattern only once;
	    <literal moreinfo="none">s</literal> - treat string as single line (change "." to match any character whatsoever, even a newline, which normally it would not match);
	    <literal moreinfo="none">x</literal> - extend your pattern's legibility by permitting whitespace and comments.
	  </para>
	</simplesect></section><section id="matches_function" role="function"><title>xsh:matches</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">boolean xsh:matches(string STR,string PATTERN)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns <literal moreinfo="none">true</literal> if <literal moreinfo="none">STR</literal>
	    matches the regular expression <literal moreinfo="none">PATTERN</literal>.
	    Otherwise returns <literal moreinfo="none">false</literal>.
	  </para>
	</simplesect></section><section id="max_function" role="function"><title>xsh:max</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">float xsh:max(object EXPRESSION, ...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns the maximum of numeric values
	    computed from given <literal moreinfo="none">EXPRESSION</literal>(s).
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    string values of individual nodes are used.
	  </para>
	</simplesect></section><section id="min_function" role="function"><title>xsh:min</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">float xsh:min(object EXPRESSION, ...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns the minimum of numeric values
	    computed from given <literal moreinfo="none">EXPRESSION</literal>(s).
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    string values of individual nodes are used.
	  </para>
	</simplesect></section><section id="new_attribute_function" role="function"><title>xsh:new-attribute</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-attribute(string NAME1,string
	VALUE1,[string NAME2, string VALUE2, ...])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Return a node-set consisting
	    of newly created attribute nodes
	    with given names and respective values.
	  </para>
	</simplesect></section><section id="new_cdata_function" role="function"><title>xsh:new-cdata</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-cdata(string DATA)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new cdata section node node filled with
	    given <literal moreinfo="none">DATA</literal> and return a node-set
	    containing the new node as its only member.
	  </para>
	</simplesect></section><section id="new_chunk_function" role="function"><title>xsh:new-chunk</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-chunk(string XML)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This is just an alias for <link linkend="parse_function">xsh:parse</link>.  It parses given piece of XML
	    and returns a node-set consisting of the top-level element
	    within the parsed tree.
	  </para>
	</simplesect></section><section id="new_comment_function" role="function"><title>xsh:new-comment</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-comment(string DATA)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new comment node containing given
	    <literal moreinfo="none">DATA</literal> and return a node-set containing
	    the new node as its only member.
	  </para>
	</simplesect></section><section id="new_element_function" role="function"><title>xsh:new-element</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-element(string NAME,[string ATTR1-NAME1,
	string ATTR-VALUE1, ...])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new element node with given
	    <literal moreinfo="none">NAME</literal> and optionally attributes with
	    given names and values and return a node-set containing
	    the new node as its only member.
	  </para>
	</simplesect></section><section id="new_element_ns_function" role="function"><title>xsh:new-element-ns</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-element-ns(string NAME,string NS,[string ATTR1-NAME1,
	string ATTR-VALUE1, ...])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new element node with given <literal moreinfo="none">NAME</literal> and
	    namespace-uri <literal moreinfo="none">NS</literal> and optionally attributes with given
	    names and values and return a node-set
	    containing the new node as its only member.
	  </para>
	</simplesect></section><section id="new_pi_function" role="function"><title>xsh:new-pi</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-pi(string NAME, [string DATA])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new processing instruction node node with given
	    <literal moreinfo="none">NAME</literal> and (optionally) given
	    <literal moreinfo="none">DATA</literal> and return a node-set containing
	    the new node as its only member.
	  </para>
	</simplesect></section><section id="new_text_function" role="function"><title>xsh:new-text</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:new-text(string DATA)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Create a new text node containing given
	    <literal moreinfo="none">DATA</literal> and return a node-set containing
	    the new node as its only member.
	  </para>
	</simplesect></section><section id="parse_function" role="function"><title>xsh:parse</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:parse(string XML-STRING)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function runs XML parser on <literal moreinfo="none">XML-STRING</literal>
	    and returns a node-set consisting
	    of the top-level nodes of the resulting document node.
	  </para>
	</simplesect></section><section id="path_function" role="function"><title>xsh:path</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:path(node-set NODE)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function returns a string containing
	    canonical XPath leading
	    to <literal moreinfo="none">NODE</literal>.
	  </para>
	</simplesect><simplesect role="seealso"><title>See Also</title><para><link linkend="pwd_command">pwd</link></para></simplesect></section><section id="resolve_uri_function" role="function"><title>xsh:resolve-uri</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:resolve-uri(string, string?)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function takes one or two arguments: a relative URI and an optional base URI.
	    If the first argument is a relative URI reference, 
	    this function resolves it against either the 
	    given base URI, if given (which is assumed to be an absolute URI)
	    or, if base URI not given, against the URI of the current working directory.
	    If the first argument is an absolute URI reference, it is returned unchanged. 
	  </para>
	  <para>
	    If the first argument is the zero-length string, returns 
	    the base URI if given and the URI of the current working directory otherwise.
	  </para>
	  <para>
	    Note: Resolving a URI does not dereference it (download
	    the referenced content); it is merely a syntactic
	    operation on two character strings.
	  </para>
	</simplesect></section><section id="reverse_function" role="function"><title>xsh:reverse</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:reverse(string STR)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a string value same as <literal moreinfo="none">STR</literal>
	    but with all characters in the opposite order.
	  </para>
	</simplesect></section><section id="same_function" role="function"><title>xsh:same</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">bool xsh:same(node-set N1, node-set N2)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns <literal moreinfo="none">true</literal> if the given node sets
	    both contain the same node
	    (in XPath, this can also be expressed as
	    <literal moreinfo="none">count(N1|N2)+count(N1)+count(N2)=3</literal>).
	  </para>
	</simplesect></section><section id="serialize_function" role="function"><title>xsh:serialize</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:serialize(node-set N,...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Serializes nodes of given node-set(s)
	    into XML strings and returns concatenation of
	    those strings.
	  </para>	
	</simplesect></section><section id="span_function" role="function"><title>xsh:span</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:span(node-set START,node-set END)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node-set which forms a span of sibling nodes
	    starting at START node and ending at END node (only the first node
	    of each of the nodesets is used). It is an error if the START
	    node and END node are not siblings.
	  </para>
	</simplesect></section><section id="split_function" role="function"><title>xsh:split</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:split(string PATTERN, string STRING)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function provides direct access to the very powerful
	    Perl function <literal moreinfo="none">split</literal>. It splits
	    <literal moreinfo="none">STRING</literal> to a list of
	    fields. <literal moreinfo="none">PATTERN</literal> is a regular expression
	    specifying strings delimiting individual fields of
	    <literal moreinfo="none">STRING</literal>. If <literal moreinfo="none">PATTERN</literal>
	    is empty, <literal moreinfo="none">STRING</literal> is split to individual
	    characters. If the regular expression in
	    <literal moreinfo="none">PATTERN</literal> is enclosed in brackets, then
	    strings matching <literal moreinfo="none">PATTERN</literal> are also
	    included in the resulting list.
	  </para>
	  <para>
	    The function returns a node-set consisting of
	    newly created <literal moreinfo="none">&lt;xsh:string&gt;</literal>
	    elements containing individual strings of the resulting
	    list as their only text child nodes.
	  </para>
	</simplesect></section><section id="sprintf_function" role="function"><title>xsh:sprintf</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:sprintf(string FORMAT,object EXPRESSION,...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a string formatted by the usual <literal moreinfo="none">printf</literal>
	    conventions of the C library function <literal moreinfo="none">sprintf</literal>
	    and <literal moreinfo="none">sprintf</literal> Perl function.</para>
	  <para>
	    See C documentation for an explanation of the
	    general principles and Perl documentation
	    for a list of supported formatting conversions.
	  </para>
	</simplesect></section><section id="strmax_function" role="function"><title>xsh:strmax</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:strmax(object EXPRESSION, ...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a string value computed as the maximum
	    (in lexicographical order)
	    of all string values computed from given 
	    <literal moreinfo="none">EXPRESSION</literal>(s).
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    string values of individual nodes are used.
	  </para>
	</simplesect></section><section id="strmin_function" role="function"><title>xsh:strmin</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:strmin(object EXPRESSION, ...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a string value computed as the minimum
	    (in lexicographical order)
	    of all string values computed from given 
	    <literal moreinfo="none">EXPRESSION</literal>(s).
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    string values of individual nodes are used.
	  </para>
	</simplesect></section><section id="subst_function" role="function"><title>xsh:subst</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:subst(string STR,string REGEXP,string
	REPLACEMENT, [string OPTIONS])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Acts in the very same way as perl substitution operation
	    <literal moreinfo="none">STRING =~ s/REGEXP/REPLACEMENT/OPTIONS</literal>,
	    returning the resulting string.
	    Searches a string for a pattern, and if found,
	    replaces that pattern with the replacement text.	    
	    If the <literal moreinfo="none">REPLACEMENT</literal> string
	    contains a <literal moreinfo="none">$</literal>  that looks like a variable,
	    the variable will be interpolated
	    into the </para>
	  <para><literal moreinfo="none">REPLACEMENT</literal> at run-time.
	    Options are:
	    </para>
	  <para>
	    <literal moreinfo="none">e</literal> - evaluate <literal moreinfo="none">REPLACEMENT</literal> 
	    as a Perl expression,</para>
	  <para>
	    <literal moreinfo="none">g</literal> - replace globally, i.e., all occurrences,</para>
	  <para>
	    <literal moreinfo="none">i</literal> - do case-insensitive pattern matching,</para>
	  <para>
	    <literal moreinfo="none">m</literal> - treat string as multiple lines,
	    that is, change <literal moreinfo="none">^</literal>
	    and <literal moreinfo="none">$</literal> from matching the start or end 
	    of the string to matching the start or end of any line anywhere
	    within the string,</para>
	  <para>
	    <literal moreinfo="none">s</literal> - treat string as single line,
	    that is, change <literal moreinfo="none">.</literal>
	    to match any character whatsoever, even a newline, which
	    normally it would not match,</para>
	  <para>
	    <literal moreinfo="none">x</literal> - use extended regular expressions.
	  </para>
	</simplesect></section><section id="substr_function" role="function"><title>xsh:substr</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:substr(string STR,float OFFSET,[float LENGTH])</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Extracts a substring out of <literal moreinfo="none">STR</literal> 
	    and returns it. First character is at offset 0.</para>
	  <para>
	    If <literal moreinfo="none">OFFSET</literal> is negative, starts
	    that far from the end of the string. </para>
	  <para>
	    If <literal moreinfo="none">LENGTH</literal> is
	    omitted, returns everything to the end of the
	    string.  If <literal moreinfo="none">LENGTH</literal> is negative,
	    leaves that many characters off the end of the string.</para>
	  <para>
	    If <literal moreinfo="none">OFFSET</literal> and
	    <literal moreinfo="none">LENGTH</literal> specify a substring that is
	    partly outside the string, only the part within
	    the string is returned.  If the substring is
	    beyond either end of the string, substr() returns
	    empty string and produces a warning.
	  </para>
	</simplesect></section><section id="sum_function" role="function"><title>xsh:sum</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">float xsh:sum(object EXPRESSION, ...)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns the sum of numerical value
	    computed from given 
	    <literal moreinfo="none">EXPRESSION</literal>(s).
	    If <literal moreinfo="none">EXPRESSION</literal> evaluates to a node-set,
	    string values of individual nodes are used.
	  </para>
	</simplesect></section><section id="times_function" role="function"><title>xsh:times</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:times(string STRING, float COUNT)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    This function returns a string
	    resulting from concatenation of <literal moreinfo="none">COUNT</literal>
	    copies of <literal moreinfo="none">STRING</literal>.
	    <literal moreinfo="none">COUNT</literal> must be a non-negative integer value.
	  </para>
	</simplesect></section><section id="uc_function" role="function"><title>xsh:uc</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:uc(string STR)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a uppercased version of <literal moreinfo="none">STR</literal>.
	  </para>
	</simplesect></section><section id="ucfirst_function" role="function"><title>xsh:ucfirst</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">string xsh:ucfirst(string STR)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns the value of <literal moreinfo="none">STR</literal>
	    with the first character uppercased.
	  </para>
	</simplesect></section><section id="var_function" role="function"><title>xsh:var</title><simplesect role="usage"><title>Usage</title><para><literal moreinfo="none">node-set xsh:var(string NAME)</literal></para></simplesect><simplesect role="description"><title>Description</title>
	  <para>
	    Returns a node-set consisting of nodes stored in a XSH2 node-list
	    variable named <literal moreinfo="none">NAME</literal>.
	  </para>
	</simplesect></section></section>
</article>