<?xml version='1.0'?>
<!DOCTYPE recdescent-xml SYSTEM "recdescent.dtd">
<recdescent-xml>
  <description>
    <para>
      Commands must be separated with a semicolon, or with a pipeline
      redirection. In the interactive shell, use slash in the end of
      line to indicate that the command follows on next line.
    </para>
    <para>
      Pipeline redirection may be used to redirect
      command output into 1) any unix command or 2) XSH variable.
      It consists of
    </para>
    <para>
      1) a pipeline character `|' followed by any unix command and its
         parameters (which are considered to span across the whole
         rest of the line), or
    </para>
    <example>
      <title>Count any attributes that contain string foo in its name or value.</title>
      <code>xsh> list //words/attribute() | grep foo | wc</code>
    </example>
    <para>
      2) of a pair of characters `|>' followed by an XSH variable name
    </para>
    <example>
      <title>Store the number of all words in a variable named count.</title>
      <code>xsh> count //words |> $count</code>
    </example>
    <para>
      You may navigate in documents with `cd' command followed by an
      XPath expression (much like in your filesystem).
    </para>
    <para>
      Type `help command' to get a list of all XSH commands.
    </para>
    <para>
      Type `help type' to get a list of all argument types.
    </para>
    <para>
      Type help followed by a command or type name to get more
      information on the particular command or argument type.
    </para>
  </description>
  <preamb>
<![CDATA[
package XML::XSH::Grammar;

use strict;
use Parse::RecDescent;
use vars qw/$grammar/;

$Parse::RecDescent::skip = '(\s|\n|#[^\n]*)*';
$grammar=<<'_EO_GRAMMAR_';
]]>
  </preamb>
  <postamb>
<![CDATA[

_EO_GRAMMAR_

sub compile {
  Parse::RecDescent->Precompile($grammar,"XML::XSH::Parser");
}

sub new {
  return new Parse::RecDescent ($grammar);
}

1;
]]>
  </postamb>
  <rules>
    <!-- ================== commands and options ====================== -->
    <rule id="command">
      <ruleref ref="backups"/>
      <ruleref ref="nobackups"/>
      <ruleref ref="quiet"/>
      <ruleref ref="verbose"/>
      <ruleref ref="test_mode"/>
      <ruleref ref="run_mode"/>
      <ruleref ref="debug"/>
      <ruleref ref="nodebug"/>
      <ruleref ref="version"/>
      <ruleref ref="validation"/>
      <ruleref ref="recovering"/>
      <ruleref ref="parser_expands_entities"/>
      <ruleref ref="keep_blanks"/>
      <ruleref ref="pedantic_parser"/>
      <ruleref ref="complete_attributes"/>
      <ruleref ref="indent"/>
      <ruleref ref="parser_expands_xinclude"/>
      <ruleref ref="load_ext_dtd"/>
      <ruleref ref="encoding"/>
      <ruleref ref="query_encoding"/>
      <ruleref ref="options_command"/>
      <ruleref ref="copy_command"/>
      <ruleref ref="xcopy_command"/>
      <ruleref ref="move_command"/>
      <ruleref ref="xmove_command"/>
      <ruleref ref="list_command"/>
      <ruleref ref="exit_command"/>
      <ruleref ref="prune_command"/>
      <ruleref ref="map_command"/>
      <ruleref ref="close_command"/>
      <ruleref ref="open_command"/>
      <ruleref ref="openhtml_command"/>
      <ruleref ref="openpipe_command"/>
      <ruleref ref="validate_command"/>
      <ruleref ref="valid_command"/>
      <ruleref ref="list_dtd_command"/>
      <ruleref ref="print_enc_command"/>
      <ruleref ref="cd_command"/>
      <ruleref ref="clone_command"/>
      <ruleref ref="count_command"/>
      <ruleref ref="eval_command"/>
      <ruleref ref="saveas_command"/>
      <ruleref ref="savexinclude_command"/>
      <ruleref ref="savehtml_command"/>
      <ruleref ref="save_command"/>
      <ruleref ref="files_command"/>
      <ruleref ref="xslt_command"/>
      <ruleref ref="insert_command"/>
      <ruleref ref="xinsert_command"/>
      <ruleref ref="help_command"/>
      <ruleref ref="exec_command"/>
      <ruleref ref="call_command"/>
      <ruleref ref="include_command"/>
      <ruleref ref="assign_command"/>
      <ruleref ref="print_var_command"/>
      <ruleref ref="var_command"/>
      <ruleref ref="print_command"/>
      <ruleref ref="create_command"/>
      <ruleref ref="list_defs_command"/>
      <ruleref ref="select_command"/>
      <ruleref ref="if_command"/>
      <ruleref ref="unless_command"/>
      <ruleref ref="while_command"/>
      <ruleref ref="foreach_command"/>
      <ruleref ref="def"/>
      <ruleref ref="process_xinclude_command"/>    	
      <ruleref ref="chxpath_command"/>
      <ruleref ref="pwd_command"/>
      <ruleref ref="locate_command"/>
      <ruleref ref="xupdate_command"/>
      <documentation>
	<title>List of XSH commands</title>
	<description>
	  <para><typeref types="command"/></para>
	</description>
      </documentation>
    </rule>

    <rule id="statement">
      <production>
	<group>
	  <production><ruleref ref="if"/></production>
	  <production><ruleref ref="unless"/></production>
	  <production><ruleref ref="while"/></production>
	  <production><ruleref ref="foreach"/></production>
	  <production><ruleref ref="def"/></production>
	</group>
	<action>$item[1]</action>
      </production>
      <production><directive type="error"></directive></production>
    </rule>

    <rule id="complex_command">
      <production>
	<literal>;</literal>
      </production>
      <production>
	<ruleref ref="command"/>
	<ruleref ref="trail" rep="?"/>
	<group>
	  <production>
	    <literal>;</literal>
	  </production>
	  <production>
	    <lookahead/>
	    <regexp>^\s*(}|\Z)</regexp>
	  </production>
	</group>
	<action>
	  my $r=$item[1];
	  if (scalar(@{$item[2]})) {
	    if ($item[2][0][0] eq 'pipe') {
  	      $r=[\&amp;XML::XSH::Functions::pipe_command,[$r],$item[2][0][1]]
	    } else {
   	      $r=[\&amp;XML::XSH::Functions::string_pipe_command,[$r],$item[2][0][1]]
	    }
          }
	  $r
	</action>
      </production>
      <production><directive type="error"></directive></production>
    </rule>

    <rule id="statement_or_command">
      <production><ruleref ref="statement"/></production>
      <production><ruleref ref="complex_command"/></production>
    </rule>

    <rule id="block" type="argtype" name="command-block">
      <production>
	<literal>{</literal>
	<directive type="commit"></directive>
	<ruleref ref="statement_or_command" rep="s"/>
	<literal>}</literal>
	<action>[grep ref,@{$item[3]}]</action>
      </production>
      <documentation>
	<title>command-block argument type</title>
	<description>
	  <para>
	    XSH command or a block of semicolon-separated
	    commands enclosed within curly brackets.
	  </para>
	  <example>
	    <title>Count paragraphs in each chapter</title>
	    <code>
	      $i=0;
	      foreach //chapter {
	      $c=./para;
	      $i=$i+1;
	      print "$c paragraphs in chapter no.$i";
	      }
	    </code>
	  </example>
	</description>	
      </documentation>
    </rule>



    <!-- ================== help on types ====================== -->
    <rule id="type" type="argtype">
      <production></production>
      <documentation>
	<title>List of command argument types</title>
	<description>
	  <para><typeref types="argtype"/></para>
	</description>
      </documentation>
    </rule>
    <!-- ================== terminals ====================== -->
    <rule id="TOKEN">
      <production>
	<regexp>\S+</regexp>
      </production>
    </rule>
    <rule id="STRING">
      <production>
	<regexp>([^'"\$\\ \t\n\r\|;\{\}]|\$[^{]|\$\{[^{}]*\}|]|\\.)+</regexp>
      </production>
    </rule>
    <rule id="single_quoted_string">
      <production>
	<regexp>\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\'</regexp>
	<action>
	  local $_=$item[1];
	  s/^\'|\'$//g;
	  s/\\([^\$])/$1/g;
	  $_;
	</action>
      </production>
    </rule>
    <rule id="double_quoted_string">
      <production>
	<regexp>\"([^\"\\]|\\.)*\"</regexp>
	<action>
	  local $_=$item[1];
	  s/^\"|\"$//g;
	  s/\\(.)/$1/g;
	  $_;
	</action>
      </production>
    </rule>
    <!-- ================== expressions ====================== -->
    <rule id="exp_part">
      <production>
	<ruleref ref="STRING"/>
      </production>
      <production>
	<ruleref ref="exp_inline_count"/>
      </production>
      <production>
	<ruleref ref="single_quoted_string"/>
      </production>
      <production>
	<ruleref ref="double_quoted_string"/>
      </production>
    </rule>
    <rule id="exp_inline_count">
      <production>
	<regexp>\${{([^}]|}[^}])*}}</regexp>
      </production>
    </rule>
    <rule id="expression" type="argtype">
      <production>
	<ruleref ref="exp_part"/>	
	<directive type="skip">""</directive>
	<ruleref ref="expression" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
      <documentation>
	<title>expression argument type</title>
	<description>
	  <para>
	    A string consisting of unquoted characters other than
	    whitespace or semicolon, single quote or double quote
	    characters or quoted characters of any kind. By quoting we
	    mean preceding a single character with a backslash or
	    enclosing a part of the string into single quotes '...'  or
	    double quotes "...". Quoting characters are removed from the
	    string so they must be quoted themselves if they are a part of
	    the expression: \\, \' or "'", \" or '"'.
	  </para>
	  <para>
	    Variable interpolation is performed on expressions, which
	    means that any substrings of the forms $id or ${id} where $ is
	    unquoted and id is an identifier are substituted with the
	    value of the variable named $id.
	  </para>
	  <para>
	    XPath interpolation is performed on expressions, which means
	    that any substring enclosed in between ${{ and }} is evaluated
	    in the same way as in the count command and the result of the
	    evaluation is substituted in its place.
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- ================= optional arguments =================== -->
    <rule id="ws">
      <production>
	<regexp>(\s|\n|#[^\n]*)+</regexp>
      </production>
    </rule>
    <rule id="optional_expression">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_expressions">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression" rep="s"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_xpath">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="xpath"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== encoding string ====================== -->
    <rule id="enc_string" type="argtype" name="enc-string">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation>
	<title>enc_string argument type</title>
	<description>
	  <para>
	    an expression which interpolates to a valid encoding
	    string, e.g. to utf-8, utf-16, iso-8859-1, iso-8859-2,
	    windows-1250 etc.
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- ================== identifyer ====================== -->
    <rule id="ID" type="argtype" name="id">
      <production>
	<regexp>[a-zA-Z_][a-zA-Z0-9_]*</regexp>
      </production>
      <documentation>
	<title>id argument type</title>
	<description>
	  <para>
	    an identifier, that is, a string beginning with a letter or
	    underscore, and containing letters, underscores, and
	    digits.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="id_or_var">
      <production><ruleref ref="ID"/></production>
      <production><ruleref ref="variable"/></production>
    </rule>
    <!-- ================== filename ====================== -->
    <rule id="filename" type="argtype">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation>
	<title>Filename argument type</title>
	<description>
	  <para>An expression which interpolates to a valid file name.</para>
	</description>
      </documentation>
    </rule>
    <!-- ================== XPATH ====================== -->
    <rule id="xpath" type="argtype">
      <production>
	<ruleref ref="id_or_var"/>
	<directive type="skip">""</directive>
	<regexp>:(?!:)</regexp>
	<ruleref ref="xp"/>
	<action>[$item[1],$item[4]]</action>
      </production>
      <production>
	<ruleref ref="xp"/>
	<action>[undef,$item[1]]</action>
      </production>
      <production>
	<directive type="error"></directive>
      </production>
      <documentation>
	<title>Xpath argument type</title>
	<description>
	  <para>
	    Any XPath expression as defined in W3C recommendation at
	    http://www.w3.org/TR/xpath optionally preceded with
	    a document identifier followed by colon. If no identifier
	    is used, the current document is used.
	  </para>
	  <example>
	    <title>Open a document and count all chapters containing a
	      subsection in it
	    </title>
	    <code>
	      xsh> open v = mydocument.xml;
	      xsh> count v://chapter[subsection];
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xpcont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">""</directive>
	<ruleref ref="xp" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xp">
      <production>
	<ruleref ref="xpsimple"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpcont" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
      <production>
	<ruleref ref="xpstring"/>
      </production>
    </rule>
    <rule id="xpfilters">
      <production>
	<ruleref ref="xpfilter" rep="s"/>
	<action>join("",@{$item[1]})</action>
      </production>
    </rule>
    <rule id="xpfilter">
      <production>
	<literal>[</literal>
	<ruleref ref="xpinter"/>
	<literal>]</literal>
	<action>"[$item[2]]"</action>
      </production>
    </rule>
    <rule id="xpbracket">
      <production>
	<literal>(</literal>
	<ruleref ref="xpinter"/>
	<literal>)</literal>
	<action>"($item[2])"</action>
      </production>
    </rule>
    <rule id="xpbrackets">
      <production>
	<ruleref ref="xpbracket"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpfilters" rep="?"/>
	<action>join "",$item[1],@{$item[3]}</action>
      </production>
    </rule>
    <rule id="xpintercont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">""</directive>
	<ruleref ref="xpinter" rep="?"/>
	<action>join("",$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xpinter">
      <production>
	<ruleref ref="xps"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpintercont" rep="?"/>
	<action>join("",$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xps">
      <production>
	<regexp>([^][()'"]|'[^']*'|"[^"]*")*</regexp>
      </production>
    </rule>
    <rule id="xpstring">
      <production>
	<regexp>'[^']*'|"[^"]*"</regexp>
      </production>
    </rule>
    <rule id="xpsimple">
      <production>
	<regexp>[^]|"' [();]+</regexp>
      </production>
      <production>
	<ruleref ref="xpbrackets"/>
      </production>
    </rule>
    <!-- ================== perl expression=expression ====================== -->
    <rule id="perl_expression">
      <production>
	<ruleref ref="expression"/>
      </production>
    </rule>
    <!-- ================== variables ====================== -->
    <rule id="variable">
      <production>
	<literal>$</literal>
	<directive type="skip">""</directive>
	<ruleref ref="ID"/>
	<action>"$item[1]$item[3]"</action>
      </production>
    </rule>
    <rule id="nodelistvariable">
      <production>
	<literal>%</literal>
	<directive type="skip">""</directive>
	<ruleref ref="id_or_var"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== EOF ====================== -->
    <rule id="eof">
      <production>
	<regexp>^\Z</regexp>
	<action>1;</action>
      </production>
    </rule>
    <!-- ================== STARTRULE and such ====================== -->
    <rule id="startrule">
      <production>
	<ruleref ref="shell"/>
	<directive type="commit"></directive>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1])</action>
      </production>
      <production>
	<ruleref ref="statement_or_command" rep="s"/>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1])</action>
      </production>
    </rule>
    <rule id="trail">
      <production>
	<literal>|></literal>
	<directive type="commit"></directive>
	<ruleref ref="variable"/>
	<action>['var',$item[3]]</action>
      </production>
      <production>
	<literal>|</literal>
	<directive type="commit"></directive>
	<ruleref ref="shline"/>
	<action>['pipe',$item[3]]</action>
      </production>
    </rule>
    <rule id="shline_nosc">
      <production>
	<regexp>([^;()\\"'\|]|\|[^&gt;]|\\.|\"([^\"\\]|\\.)*\"|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_inter">
      <production>
	<regexp>([^()\\"']|\\.|\"([^\"\\]|\\.)*\"|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_bracket">
      <production>
	<literal>(</literal>
	<ruleref ref="shline_inter"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_inter"/>
	<literal>)</literal>
	<action>join("",'(',$item[2],@{$item[3]},$item[4],')')</action>
      </production>      
    </rule>
    <rule id="shline">
      <production>
	<ruleref ref="shline_nosc"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_nosc"/>
	<action>join("",$item[1],@{$item[2]},$item[3])</action>
      </production>
    </rule>
    <rule id="shell">
      <production>
	<regexp>!\s*</regexp>
	<regexp>.*</regexp>
	<action>[[\&amp;XML::XSH::Functions::sh,$item[2]]]</action>
      </production>
    </rule>
    <rule id="perl_codeblock" name="perl-block">
      <production></production>
      <documentation>
	<title>Perl-block</title>
	<description>
	  <para>Perl-block is a block of arbitrary perl code
	    encosed in curly brackets: { ... }</para>
	  <example>
	    <code>map { $_=uc($_) } //chapter/title/text()</code>
	  </example>
	  <example>
	    <code>foreach { grep /A[xyz]/ glob ('*.xml') } { f=$__; select f; call process_file }</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- ================== STATEMENTS ====================== -->
    <rule id="condition">
      <production><directive type="perl_codeblock"/></production>
      <production><ruleref ref="xpath"/></production>
    </rule>
    <rule id="else_block" name="else">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="block"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- if -->
    <rule type='command' id="if" name="if">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="else_block" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,$item[3],$item[4],@{$item[5]}]</action>
      </production>
    </rule>
    <rule id="if_command" name="if" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,$item[3],[$item[4]]]</action>
      </production>
      <documentation>
	<usage>if <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/>
	  <xref linkend="command"/>

          if <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/>
	  <xref linkend="block"/> [ else <xref linkend="block"/> ]
	</usage>
	<description>
	  <para>
	    Execute <xref linkend="block"/> if the given 
	    <xref linkend="xpath"/> or <xref linkend="perl_codeblock"/>
	    expression evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or non-empty
	    literal. 
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- unless -->
    <rule type='command' id="unless" name="unless">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="else_block" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],$item[4],@{$item[5]}]</action>
      </production>
    </rule>
    <rule id="unless_command" name="unless" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],[$item[4]]]</action>
      </production>
      <documentation>
	<usage>unless <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/>
	  <xref linkend="command"/>

          unless <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/>
	  <xref linkend="block"/> [ else <xref linkend="block"/> ]
	</usage>
	<description>
	  <para>Like if but negating the result of the expression.</para>
	</description>
	<see-also>
	  <ruleref ref="if"/>
	</see-also>
      </documentation>
    </rule>
    <!-- while -->
    <rule id="while_command" name="while" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="while" type="command" name="while">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],$item[4]]</action>
      </production>
      <documentation>
	<usage>while <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/> <xref
	    linkend="block"/></usage>
	<description>
	  <para> Execute <xref linkend='block'/> as long as
	    the given <xref linkend='xpath'/> or <xref
	      linkend='perl_codeblock'/> expression evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or
	    non-empty literal.
	  </para>
	  <example>
	    <title>The commands have the same results</title>
	    <code>
	      xsh> while /table/row remove /table/row[1];
	      xsh> remove /table/row;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- foreach -->
    <rule id="foreach_command" name="foreach" inline="yes">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="foreach" type="command" name="foreach">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],$item[4]]</action>
      </production>
      <documentation>
	<usage>foreach <xref linkend="xpath"/>|<xref linkend="perl_codeblock"/> 
	  <xref linkend="command"/>
	  <xref linkend="block"/></usage>
	<description>
	  <para>
	    If the first argument is an <xref linkend="xpath"/>
	    expression, execute the command-block for each node
	    matching the expression making it temporarily the current
	    node, so that all relative XPath
	    expressions are evaluated in its context.
	  </para>
	  <para>
	    If the first argument is a <xref linkend="perl_codeblock"/>,
	    it is evaluated and the resulting perl-list is 
	    iterated setting the variable $__
	    to be each element of the list in turn. It works much
	    like perl's foreach, except that the variable used
	    consists of two underscores.
	  </para>
	  <example>
	    <title>Move all employee elements in a company element
	      into a staff subelement of the same company</title>
	    <code>xsh> foreach //company xmove ./employee into ./staff;</code>
	  </example>
	  <example>
	    <title>List content of all XML files in current directory</title>
	    <code>
	      xsh> foreach { glob('*.xml') } { open f=$__; list f:/; }
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- def -->
    <rule id="def" type="command" name="def">
      <aliases>
	<alias name="define"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="ID"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::def,$item[3],$item[4]]</action>
      </production>
      <documentation>
	<usage>def <xref linkend="ID"/> <xref linkend="block"/></usage>
	<description>
	  <para>
	    Define a new XSH routine named <xref linkend='ID'/>. The
	    <xref linkend='block'/> may be later invoked using
	    the `call <xref linkend='ID'/>' command.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="call_command"/>
	</see-also>
      </documentation>
    </rule>
    <!-- ================== COMMANDS ====================== -->
    <rule id="assign_command" type="command" name="assign"
    inline="yes">
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="variable"/>
	<directive type="commit"></directive>
	<literal>=</literal>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::xpath_assign,$item[2],$item[5]]</action>
      </production>
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="nodelistvariable"/>
	<directive type="commit"></directive>
	<literal>=</literal>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::nodelist_assign,$item[2],$item[5]]</action>
      </production>
      <documentation>
	<usage>assign $<xref linkend='ID'/>=<xref
	    linkend="expression"/> or 
	  $<xref linkend='ID'/>=<xref
	    linkend="expression"/> or
	  assign %<xref linkend='ID'/>=<xref
	    linkend="xpath"/> or 
	  %<xref linkend='ID'/>=<xref
	    linkend="xpath"/></usage>
	<description>
	  <para> 
	    In the first two cases (where dollar sign appears)
	    store the result of interpolation of the <xref
	      linkend="expression"/> in a variable named $<xref
	      linkend='ID'/>. The variable may be later used in other
	    expressions or even in perl-code as $<xref linkend='ID'/> or
	    ${<xref linkend='ID'/>}.
	  </para>
	  <para> 
	    In the other two cases (where percent sign appears)
	    find all nodes matching the given <xref linkend="xpath"/>
	    and store the resulting nodelist in the variable
	    named %<xref linkend='ID'/>. The variable may be later used
	    instead of an XPath expression.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="print_var_command" inline="yes">
      <production>
	<ruleref ref="variable"/>
	<action>[\&amp;XML::XSH::Functions::print_var,$item[1]]</action>
      </production>
    </rule>
    <rule id="options_command" type="command" name="options"
    inline="yes">
      <aliases>
	<alias name="flags"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<action>[\&amp;XML::XSH::Functions::list_flags]</action>
      </production>
      <documentation>
	<usage>options</usage>
	<description>
	  <para>List current values of all XSH flags and options (such as
	  validation flag or query-encoding).</para>
	  <example>
	    <title>Store current settings in your .xshrc</title>
	    <code>xsh> options | cat > ~/.xshrc</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="list_defs_command" type="command" name="defs"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<action>[\&amp;XML::XSH::Functions::list_defs]</action>
      </production>
      <documentation>
	<usage>defs</usage>
	<description>
	  <para>List names of all defined XSH routines.</para>
	</description>
	<see-also>
	  <ruleref ref="def"/>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="include_command" type="command" name="include"
    inline="yes">
      <aliases>
	<alias name="." regexp="\."/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::include,$item[3]]</action>
      </production>
      <documentation>
	<usage>include <xref linkend="filename"/></usage>
	<description>
	  <para>
	    Include a file named <xref linkend="filename"/> and execute all XSH
	    commands therein.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="call_command" type="command" name="call" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::call,$item[3]]</action>
      </production>
      <documentation>
	<usage>call <xref linkend='ID'/></usage>
	<description>
	  <para>
	    Call an XSH subroutine named <xref linkend='ID'/> previously
	    created using def.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="help_command" type="command" name="help" inline="yes">
      <aliases>
	<alias name="?" regexp="\?"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::help,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>help <xref linkend="command"/>|argument-type</usage>
	<description>
	  <para>Print help on a given command or argument type.</para>
	</description>
      </documentation>
    </rule>
    <rule id="exec_command" type="command" name="exec" inline="yes">
      <aliases>
	<alias name="system"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::sh,join(" ",@{$item[3]})]</action>
      </production>
      <documentation>
	<usage>exec <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<description>
	  <para>execute the system command(s) in <xref linkend="expression"/>s.
	  </para>
	  <example>
	    <title>Count words in "hallo wold" string, then print name
	      of your machine's operating system.</title>
	    <code>
	      exec echo hallo world       # prints hallo world
	      exec "echo hallo word | wc" # counts words in hallo world
	      exec uname;                 # prints operating system name
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xslt_params">
      <production>
	<regexp>(params|parameters)\s</regexp>
	<ruleref ref="param" rep="s"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="xslt_command" type="command" name="xslt" inline="yes">
      <aliases>
	<alias name="transform"/>
	<alias name="xsl"/>
	<alias name="xsltproc"/>
	<alias name="process"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="expression"/>
	<ruleref ref="xslt_params" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xslt,@item[3,4,5],@{$item[6]}]</action>
      </production>
      <documentation>
	<usage>xslt <xref linkend='ID'/> <xref
	    linkend="filename"/> [(params|parameters) name=<xref
	    linkend="expression"/> [name=<xref linkend="expression"/> ...]]</usage>
	<description>
	  <para>
	    Load an XSLT stylesheet from a file and use it to transform
	    the document of the first <xref linkend='ID'/> into a new
	    document named <xref linkend='ID'/>. Parameters
	    may be passed to a stylesheet after params keyword in the
	    form of a list of name=value pairs where name is the
	    parameter name and value is an expression interpolating to
	    its value. The resulting value is interpretted by XSLT
	    processor as an XPath expression so e.g. quotes surrounding
	    a XPath string have to be quoted themselves to preveserve
	    them during the XSH expression interpolation.           
	  </para>
	  <example>
	    <code>xslt src stylesheet.xsl rslt params font="'14pt'" color="'red'"</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="param">
      <production>
	<regexp>[^=\s]+</regexp>
	<literal>=</literal>
	<ruleref ref="expression"/>
	<action>[$item[1],$item[3]]</action>
      </production>
    </rule>
    <rule id="files_command" type="command" name="files" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::files]</action>
      </production>
      <documentation>
	<description>
	  <para>List open files and their identifiers.</para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="var_command" type="command" name="variables"
    inline="yes">
      <aliases>
	<alias name="vars"/>
	<alias name="var"/>
      </aliases>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::variables]</action>
      </production>
      <documentation>
	<usage>variables</usage>
	<description>
	  <para>List all defined variables and their values.</para>
	</description>
	<see-also>
	  <ruleref ref="files_command"/>
	  <ruleref ref="list_defs_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="copy_command" type="command" name="copy" inline="yes">
      <aliases>
	<alias name="cp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4]]</action>
      </production>
      <documentation>
	<usage>copy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<description>
	  <para>
	    Copies nodes matching the first <xref linkend='xpath'/> to
	    the destinations determined by the <xref
	      linkend='loc'/> directive relative to the second <xref
	      linkend='xpath'/>. If more than one node matches the first
	    <xref linkend='xpath'/> than it is copied to the position
	    relative to the corresponding node matched by the second
	    <xref linkend='xpath'/> according to the order in which are
	    nodes matched. Thus, the n'th node matching the first <xref
	      linkend='xpath'/> is copied to the location relative to the
	    n'th node matching the second <xref linkend='xpath'/>. The
	    possible values for <xref linkend='loc'/> are: after,
	    before, into, replace and cause copying the source nodes
	    after, before, into (as the last child-node).  the
	    destination nodes. If replace <xref linkend='loc'/> is
	    used, the source node is copied before the destination node
	    and the destination node is removed.
	  </para>
	  <para>
	    Some kind of type conversion is used when the types of the
	    source and destination nodes are not equal.  Thus, text,
	    cdata, comment or processing instruction node data prepend,
	    append or replace value of a destination attribute when
	    copied before,after/into or instead (replace) an attribute,
	    and vice versa.
	  </para>
	  <para>
	    Attributes may be copied after, before or into some other
	    attribute to append, prepend or replace the destination
	    attribute value. They may also replace the destination
	    attribute completely (both its name and value).
	  </para>
	  <para>
	    To simply copy an attribute from one element to another,
	    simply copy the attribute node into the destination element.
	  </para>
	  <para>
	    Elements may be copied into other elements (which results in
	    appending the child-list of the destination element), or
	    before, after or instead (replace) other nodes of any type
	    except attributes.
	  </para>
	  <example>
	    <title>Replace living-thing elements in the document b with
	      the coresponding creature elements of the document a.</title>
	    <code>xsh> copy a://creature replace b://living-thing</code>             
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xcopy_command" type="command" name="xcopy" inline="yes">
      <aliases>
	<alias name="xcp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4],1]</action>
      </production>
      <documentation>
	<usage>xcopy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<description>
	  <para>
	    xcopy is similar to copy, but copies *all* nodes matching
	    the first <xref linkend='xpath'/> to *all* destinations determined by the
	    <xref linkend='loc'/> directive relative to the
	    second <xref linkend='xpath'/>. See copy
	    for detailed description of xcopy arguments.
	  </para>
	  <example>
	    <title>Copy all middle-earth creatures within the document a
	      into every world of the document b.</title>
	    <code>xsh> xcopy a:/middle-earth/creature into b://world</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="cd_command" type="command" name="lcd" inline="yes">
      <aliases>
	<alias name="chdir"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::cd,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>lcd <xref linkend="expression"/></usage>
	<description>
	  <para>
	    Changes the filesystem working directory to <xref
	      linkend='expression'/>, if possible.  If <xref
	      linkend='expression'/> is omitted, changes to the directory
	    specified in HOME environment variable, if set; if not,
	    changes to the directory specified by LOGDIR environment
	    variable.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="insert_command" type="command" name="insert"
    inline="yes">
      <aliases>
	<alias name="add"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],0]</action>
      </production>
      <documentation>
	<usage>insert <xref linkend="nodetype"/> <xref
	    linkend="expression"/> [namespace <xref linkend="expression"/>] <xref linkend='loc'/><xref
	    linkend="xpath"/>
	</usage>
	<description>
	  <para>
	    Works just like xadd, except that the new node is attached
	    only the first node matched.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="xinsert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xinsert_command" type="command" name="xinsert"
    inline="yes">
      <aliases>
	<alias name="xadd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],1]</action>
      </production>
      <documentation>
	<usage>xinsert <xref linkend="nodetype"/> <xref
	    linkend="expression"/> [namespace <xref linkend="expression"/>] <xref linkend='loc'/><xref
	    linkend="xpath"/>
	</usage>
	<description>
	  <para>
	    Use the <xref linkend='expression'/> to create a new node of a given
	    <xref linkend='nodetype'/> in the <xref linkend='loc'/> relative to the given
	    <xref linkend='xpath'/>.
	  </para>
	  <para>
	    For element nodes, the format of the <xref
	      linkend='expression'/> should look like "&lt;element-name
	    att-name='attvalue' ...&gt;".  The `&lt;' and `&gt;'
	    characters are optional. If no attributes are used, the
	    expression may simply consist the element name. Note, that
	    in the first case, the quotes are required since the
	    expression contains spaces.
	  </para>
	  <para>
	    Attribute nodes use the following syntax:
	    "att-name='attvalue' [...]".
	  </para>
	  <para>
	    For the other types of nodes (text, cdata, comments) the
	    expression should contain the node's literal content. Again,
	    it is necessary to quote all whitespace and special
	    characters as in any expression argument.
	  </para>
	  <para>
	    The <xref linkend='loc'/> argument should be one of:
	    `after', `before', `into' and `replace'. You may use `into'
	    location also to attach an attribute to an element or to
	    append some data to a text, cdata or comment node. Note
	    also, that `after' and `before' locations may be used to
	    append or prepend a string to a value of an existing
	    attribute. In that case, attribute name is ignored.
	  </para>
	  <para>
	    The namespace <xref linkend='expression'/> is only valid for
	    elements and attributes and must evaluate to the namespace
	    URI. In that case, the element or attribute name must have a
	    prefix. The created node is associated with the given
	    namespace.
	  </para>
	  <example>
	    <title>Append a new Hobbit element to the list of
	      middle-earth creatures and name him Bilbo.</title>
	    <code>
	      xsh> xadd element "&lt;creature race='hobbit' manner='good'> \
	      into /middle-earth/creatures
	      xsh> xadd attribute "name='Bilbo'" \
	      into /middle-earth/creatures/creature[@race='hobbit'][last()]
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodetype" name="node-type">
      <production>
	<regexp>element|attribute|attributes|text|cdata|pi|comment|chunk|entity_reference</regexp>
      </production>
      <documentation>
	<title>Node-type argument type</title>
	<description>
	  <para>
	    One of: element, attribute, text, cdata, comment, chunk
	    and (EXPERIMENTALLY!) entity_reference.  A
	    chunk is a character string which forms a well-balanced
	    peace of XML.
	  </para>
	  <example>
	    <code>
	      add element hobbit into //middle-earth/creatures;
	      add attribute 'name="Bilbo"' into //middle-earth/creatures/hobbit[last()];
	      add chunk '&lt;hobbit name="Frodo">A small guy from &lt;place>Shire&lt;/place>.&lt;/hobbit>' \
	      into //middle-earth/creatures;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="namespace">
      <production>
	<regexp>namespace\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="loc" type="argtype" name="location">
      <production><regexp>after\s</regexp>
	<action>"after"</action>
</production>
      <production><regexp>before\s</regexp>
	<action>"before"</action>
</production>
      <production><regexp>(to|into|as child( of)?)\s</regexp>
	<action>"as_child"</action>
      </production>
      <production><regexp>(replace|instead( of)?)\s</regexp>
	<action>"replace"</action>
      </production>
      <documentation>
	<title>Location argument type</title>
	<description>
	  <para>One of: 
	    after, 
	    before, 
	    into/to/as child/as child of, 
	    replace/instead/instead of.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="move_command" type="command" name="move" inline="yes">
      <aliases>
	<alias name="mv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4]]</action>
      </production>
      <documentation>
	<usage>move <xref linkend="xpath"/> <xref linkend="loc"/> <xref
	    linkend="xpath"/></usage>
	<description>
	  <para>Like copy, except that move removes the source nodes
	    after a succesfull copy. See copy for more detail.</para>
	</description>
	<see-also>
	  <ruleref ref="copy_command"/>
	  <ruleref ref="xmove_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xmove_command" type="command" name="xmove" inline="yes">
      <aliases>
	<alias name="xmv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4],1]</action>
      </production>
      <documentation>
	<usage>xmove <xref linkend="xpath"/> <xref linkend="loc"/> <xref
	    linkend="xpath"/></usage>
	<description>
	  <para>Like xcopy, except that xmove removes the source nodes
	    after a succesfull copy. See copy for more detail.</para>
	</description>
	<see-also>
	  <ruleref ref="xcopy_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="clone_command" type="command" name="clone" inline="yes">
      <aliases>
	<alias name="dup"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::clone,@item[3,5]]</action>
      </production>
      <documentation>
	<usage>clone <xref linkend='ID'/>=<xref linkend='ID'/></usage>
	<description>
	  <para>
	    Make a copy of the document identified by the <xref
	      linkend='ID'/> following the equal sign assigning it the
	    identifier of the first <xref linkend='ID'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="list_command" type="command" name="list" inline="yes">
      <aliases>
	<alias name="ls"/>
      </aliases>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],$item[3]]</action>
      </production>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],-1]</action>
      </production>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::list,[undef,'.'],1]</action>
      </production>
      <documentation>
	<usage>list <xref linkend="xpath"/> [<xref linkend="expression"/>]</usage>
	<description>
	  <para>
	    List the XML representation of all nodes matching <xref
	      linkend='xpath'/>. The optional expression argument may be
	    provided to specify the depth of XML tree listing. If
	    negative, the tree will be listed to arbitrary depth.
	    Unless in quiet mode, this command prints number of nodes
	    matched on stderr.	   
	  </para>
	  <para>
	    If the <xref linkend="xpath"/> parameter is omitted,
	    current context node is listed to the depth of 1.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	</see-also>
      </documentation>    
    </rule>
    <rule id="count_command" type="command" name="count" inline="yes">
      <aliases>
	<alias name="print_value"/>
	<alias name="get"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::print_count,$item[3]]</action>
      </production>
      <documentation>
	<usage>count <xref linkend="xpath"/></usage>
	<description>
	  <para>
	    Calculate the given <xref linkend='xpath'/> expression. If
	    the result is a node-list, return number of nodes in the
	    node-list.  If the <xref linkend='xpath'/> results in a
	    boolean, numeric or literal value, return the value.
	  </para>
	  <para>WARNING: Evaluation of <xref linkend='xpath'/> is done
	    by means of XML::LibXML library. If the expression is not a
	    valid XPath expression, the library in its present version
	    causes segmentation fault (unless patched). This may result
	    in loss of any unsaved data opened in XSH. I've sent a patch
	    to the author of XML::LibXML port and he approved it. Let's
	    see if it appears in the next version and when that will be
	    released.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="perl_code" type="argtype" name="perl-code">
      <production>
	<directive type="perl_codeblock"></directive>
      </production>
      <production>
	<ruleref ref="perl_expression"/>
      </production>
      <documentation>
	<title>Perl-code argument type</title>
	<description>
	  <para>
	    A block of perl code enclosed in curly brackets or an
	    expression which interpolates to a perl
	    expression. Variables defined in XSH are visible in perl
	    code as well. Since XSH redirects output to the terminal,
	    you cannot simply use perl print function for output if you
	    want to filter the result with a shell command. Instead use
	    predefined perl routine `echo ...'  which is equivalent to
	    `print $::OUT ...'. The $::OUT perl-variable stores the
	    referenc to the terminal file handle.
	  </para>
	  <example>
	    <code>
	      $i="foo";

	      eval { echo "$i-bar\n"; } # prints foo-bar

	      eval 'echo "\$i-bar\n";'  # exactly the same as above

	      eval 'echo "$i-bar\n";'   # prints foo-bar too, but $i is
	      # interpolated by XSH, so perl
	      # actually evaluates
	      #  echo "foo-bar\n";
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="eval_command" type="command" name="eval" inline="yes">
      <aliases>
	<alias name="perl"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="perl_code"/>
	<action>[\&amp;XML::XSH::Functions::print_eval,$item[3]]</action>
      </production>
      <documentation>
	<usage>eval <xref linkend="perl_code"/></usage>
	<description>
	  <para>Evaluate the given perl expression and print the return value.</para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="prune_command" type="command" name="remove" inline="yes">
      <aliases>
	<alias name="rm"/>
	<alias name="prune"/>
	<alias name="delete"/>
	<alias name="del"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::prune,$item[3]]</action>
      </production>
      <documentation>
	<usage>remove <xref linkend="xpath"/></usage>
	<description>
	  <para>Remove all nodes matching <xref
	      linkend='xpath'/>.</para>
	  <example>
	    <title>Get rid of all evil creatures.</title>
	    <code>xsh> del //creature[@manner='evil']</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="print_command" type="command" name="print" inline="yes">
      <aliases>
	<alias name="echo"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression" rep="s?"/>
	<action>[\&amp;XML::XSH::Functions::echo,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>print <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<description>
	  <para>Interpolate and print given expression(s).</para>
	</description>
      </documentation>
    </rule>
    <rule id="map_command" type="command" name="map" inline="yes">
      <aliases>
	<alias name="sed"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="perl_code"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::perlmap,@item[4,3]]</action>
      </production>
      <documentation>
	<usage>map <xref linkend="perl_code"/> <xref
	    linkend="xpath"/></usage>
	<description>
	  <para>
	    Each of the nodes matching <xref linkend='xpath'/> is
	    processed with the <xref linkend='perl_code'/> in the
	    following way: if the node is an element, its name is
	    processed, if it is an attribute, its value is used, if it
	    is a cdata section, text node, comment or processing
	    instruction, its data is used.  The expression should expect
	    the data in the $_ variable and should use the same variable
	    to store the modified data.
	  </para>
	  <example>
	    <title>Renames all hobbits to halflings</title>
	    <code>xsh> map $_='halfling' //hobbit</code>
	  </example>
	  <example>
	    <title>Capitalises all hobbit names</title>
	    <code>xsh> map { $_=ucfirst($_) } //hobbit/@name</code>	  
	  </example>
	  <example>
	    <title>Changes goblins to orcs in all hobbit tales.</title>
	    <code>xsh> on s/goblin/orc/gi //hobbit/tale/text()</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="close_command" type="command" name="close" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::close_doc,$item[3]]</action>
      </production>
      <documentation>
	<usage>close <xref linkend='ID'/></usage>
	<description>
	  <para>
	    Close the document identified by <xref linkend='ID'/>, removing its
	    parse-tree from memory.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="select_command" type="command" name="select"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,[$item[3],"/"]]</action>
      </production>
      <documentation>
	<usage>select <xref linkend='ID'/></usage>
	<description>
	  <para>
	    Make <xref linkend='ID'/> the document identifier to be used in the next
	    xpath evaluation without identifier prefix.
	  </para>
	  <example>
	    <code>
	      xsh> a=mydoc1.xml       # opens and selects a
	      xsh> list /             # lists a
	      xsh> b=mydoc2.xml       # opens and selects b
	      xsh> list /             # lists b
	      xsh> list a:/           # lists and selects a
	      xsh> select b           # does nothing except selecting b
	      xsh> list /             # lists b
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="open_command" type="command" name="open" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5]]</action>
      </production>
      <production>
	<ruleref ref="ID"/>
	<regexp>\s*=\s*</regexp>
	<directive type="commit"></directive>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[1,4]]</action>
      </production>
      <documentation>
	<usage>[open] <xref linkend='ID'/>=<xref
	    linkend='filename'/></usage>
	<description>
	  <para>
	    Open a new document assigning it a symbolic name of <xref linkend='ID'/>.
	    To identify the document, use simply <xref linkend='ID'/> in commands like
	    close, save, validate, dtd or enc. In commands which work on
	    document nodes, use <xref linkend='ID'/>: prefix is XPath expressions to
	    point the XPath into the document.
	  </para>
	  <example>
	    <code>
	      xsh> open x=mydoc.xml # open a document

	      # quote file name if it contains whitespace
	      xsh> open y="document with a long name with spaces.xml"

	      # you may omit the word open (I'm clever enough to find out).
	      xsh> z=mybook.xml

	      # use z: prefix to identify the document opened with the
	      # previous comand in an XPath expression.
	      xsh> list z://chapter/title	    
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="openhtml_command" type="command" name="open_HTML"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5],'html']</action>
      </production>
      <documentation>
	<usage>open_HTML <xref linkend='ID'/>=<xref
	    linkend='filename'/></usage>
	<description>
	  <para>
	    Open a new HTML document assigning it a symbolic name of
	    <xref linkend='ID'/>. To save it as HTML, use save_HTML
	    command (use of just save or saveas would change it to
	    XHTML without changing the DOCTYPE declaration).
	  </para>
	</description>
	<see-also>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="openpipe_command" type="command" name="open_PIPE"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5],'pipe']</action>
      </production>
      <documentation>
	<usage>open_PIPE <xref linkend='ID'/>=<xref
	    linkend='expression'/></usage>
	<description>
	  <para>
	    Run the system command resluting from interpoation of the <xref
	    linkend='expression'/> and parse its output as XML,
	    associating the resulting DOM tree with the given <xref
	    linkend="ID"/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="openhtml_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="create_command" type="command" name="create"
    inline="yes">
      <aliases>
	<alias name="new"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::create_doc,@item[3,4]]</action>
      </production>
      <documentation>
	<usage>create <xref linkend='ID'/> <xref
	    linkend="expression"/></usage>
	<description>
	  <para>
	    Create a new document using <xref linkend='expression'/> to
	    form the root element and associate it with the given
	    identifier.
	  </para>
	  <example>
	    <code>
	      xsh> create t1 root
	      xsh> ls /
	      &lt;?xml version="1.0" encoding="utf-8"?>
	      &lt;root/>

	      xsh> create t2 "&lt;root id='r0'>Just a &lt;b>test&lt;/b>&lt;/root>"
	      xsh> ls /
	      &lt;?xml version="1.0" encoding="utf-8"?>
	      &lt;root id='r0'>Just a &lt;b>test&lt;/b>&lt;/root>
	      xsh> files
	      scratch = new_document.xml
	      t1 = new_document1.xml
	      t2 = new_document2.xml
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="clone_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="encoding_param">
      <production>
	<regexp>encoding\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="save_command" type="command" name="save" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as,$item[3],@{$item[4]}]</action>
      </production>
      <documentation>
	<usage>save <xref linkend='ID'/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> to its
	    original XML file, optionally converting it from its original
	    encoding to <xref linkend='enc_string'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="saveas_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="savehtml_command" type="command" name="save_HTML"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as_html,@item[3,4],@{$item[5]}]</action>
      </production>
      <documentation>
	<usage>save_HTML <xref linkend='ID'/> <xref linkend="filename"/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> as a
	    HTML file named <xref linkend='filename'/>, optionally
	    converting it from its original encoding to <xref
	      linkend='enc_string'/> Note, that this does just
	    the character conversion, so you
	    must specify the correct encoding in the META tag yourself.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="openhtml_command"/>
	  <ruleref ref="saveas_command"/>
	  <ruleref ref="save_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="saveas_command" type="command" name="saveas"
    inline="yes">
      <aliases>
	<alias name="save_as"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as,@item[3,4],@{$item[5]}]</action>
      </production>
      <documentation>
	<usage>saveas <xref linkend='ID'/> <xref linkend="filename"/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> as a
	    XML file named <xref linkend='filename'/>, optionally
	    converting it from its original encoding to <xref
	      linkend='enc_string'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="save_command"/>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="savexinclude_command" type="command"
    name="save_xinclude" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_xinclude,@item[3],@{$item[4]}]</action>
      </production>
      <documentation>
	<usage>save_xinclude <xref linkend='ID'/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> while
	    saving all expanded XInclude sections to the original
	    files (optionally converting it from its original encoding
	    to <xref linkend='enc_string'/>).  Once expanded, sections
	    included with XInclude mechanism cannot be normally
	    distinguished from other parts of the DOM tree by any
	    XPath expression or XSH command. Internally, however, they
	    are marked with special DOM nodes. This command uses these
	    nodes to find the sections and save them to their original
	    documents while restoring the &lt;xi:include&gt; tags in
	    the root document. More over, this command may be used to
	    split the document to new fragments included back by means
	    of XInclude, since all non-empty fragments containded
	    within
	  </para>
	  <para>
	    &lt;xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
   	    href='output-file'&gt;&lt;xi:include/&gt;
	  </para>
	  <para>
	    elements are saved to separate files too, leaving only
	    empty xi:include element in the root file.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="save_command"/>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="list_dtd_command" type="command" name="dtd" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::list_dtd,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>dtd [<xref linkend='ID'/>]</usage>
	<description>
	  <para>
	    Print external or internal DTD for the given document.  If
	    no document identifier is given, the current document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="validate_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="print_enc_command" type="command"
    name="print_enc_command" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::print_enc,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>enc [<xref linkend='ID'/>]</usage>
	<description>
	  <para>
	    Print the original document encoding string.
	    If no document identifier is given, the current document is
	    used.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="validate_command" type="command" name="validate"
    inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>validate [<xref linkend='ID'/>]</usage>
	<description>
	  <para>
	    Try to validate the document identified with <xref
	      linkend='ID'/> according to its DTD, report all validity
	    errors.  If no document identifier is given, the current
	    document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="valid_command" type="command" name="valid" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::valid_doc,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>valid [<xref linkend='ID'/>]</usage>
	<description>
	  <para>
	    Check and report the validity of a document.  Prints "yes"
	    if the document is valid and "no" otherwise.  If no document
	    identifier is given, the current document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="validate_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="exit_command" type="command" name="exit" inline="yes">
      <aliases>
	<alias name="quit"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::quit,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>exit [<xref linkend='expression'/>]</usage>
	<description>
	  <para>
	    Exit xsh immediately, optionally with the exit-code
	    resulting from the given expression.
	  </para>
	  <para>
	    WARNING: No files are saved on exit.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="process_xinclude_command" type="command"
    name="process_xinclude" inline="yes">
      <aliases>
	<alias name="process_xincludes"/>
	<alias name="xinclude"/>
	<alias name="xincludes"/>
	<alias name="load_xincludes"/>
	<alias name="load_xinclude"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>	
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::process_xinclude,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>process_xinclude [<xref linkend='ID'/>]</usage>
	<description>
	  <para>
	    Process any xinclude tags in the document <xref linkend='ID'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="parser_expands_xinclude"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="chxpath_command" type="command" name="cd" inline="yes">
      <aliases>
	<alias name="chxpath"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>cd [<xref linkend="xpath"/>]</usage>
	<description>
	  <para>Change current context node (and current document) to
	    the first node matching the given <xref linkend="xpath"/>
	    argument.
          </para>
	</description>
      </documentation>
    </rule>
    <rule id="pwd_command" type="command" name="pwd" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_pwd]</action>
      </production>
      <documentation>
	<usage>pwd</usage>
	<description>
	  <para>Print XPath leading to the current context node.
	    This is equivalent to `locate .'.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="locate_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="locate_command" type="command" name="locate"
    inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::locate,@{$item[3]}]</action>
      </production>
      <documentation>
	<usage>locate <xref linkend="xpath"/></usage>
	<description>
	  <para>Print canonical XPaths leading to nodes matched by
	    the <xref linkend="xpath"/> given.</para>
	</description>
	<see-also>
	  <ruleref ref="pwd_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="xupdate_command" type="command" name="xupdate"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xupdate,$item[3],@{$item[4]}]</action>
      </production>
      <documentation>
	<usage>xupdate <xref linkend="ID"/> [<xref linkend="ID"/>]</usage>
	<description>
	  <para>Modify the current document or the document specified
	    by the second <xref linkend="ID"/> argument according to
	    XUpdate commands of the first <xref linkend="ID"/>
	    document. XUpdate is a XML Update Language which aims to
	    be a language for updating XML documents.
	  </para>
	  <para>
	    XUpdate langauge is described in XUpdate Working Draft at
            http://www.xmldb.org/xupdate/xupdate-wd.html.	    	    
	  </para>
	  <para>XUpdate output can be generated for example by
            Python xmldiff utility from
	    http://www.logilab.org/xmldiff/. Unfortunatelly,
	    there are few bugs (or, as I tend to say In case of
            Python, white-space problems) in their code, so its 
            XUpdate output is not always correct.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="verbose" type="command" name="verbose" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_q,0]</action>
      </production>
      <documentation>
	<usage>verbose</usage>
	<description>
	  <para>Turn on verbose messages.</para>
	</description>
	<see-also>
	  <ruleref ref="quiet"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="test_mode" type="command" name="test-mode" inline="yes">
      <production>
	<selfref/>
	<action>["test-mode"]</action>
      </production>
      <documentation>
	<usage>test-mode</usage>
	<description>
	  <para>
	    Switch into test mode in which no commands are actually
	    executed and only command syntax is checked.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="run_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="run_mode" type="command" name="run-mode" inline="yes">
      <production>
	<selfref/>
	<action>["run-mode"]</action>
      </production>
      <documentation>
	<usage>run-mode</usage>
	<description>
	  <para>
	    Switch into normal XSH mode in which all commands are
	    executed.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="test_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="debug" type="command" name="debug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_d,1]</action>
      </production>
      <documentation>
	<usage>debug</usage>
	<description>
	  <para>Turn on debugging messages.</para>
	</description>
	<see-also>
	  <ruleref ref="nodebug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodebug" type="command" name="nodebug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_d,0]</action>
      </production>
      <documentation>
	<usage>nodebug</usage>
	<description>
	  <para>Turn off debugging messages.</para>
	</description>
	<see-also>
	  <ruleref ref="debug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="version" type="command" name="version" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_version,0]</action>
      </production>
      <documentation>
	<usage>version</usage>
	<description>
	  <para>
	    Prints program version as well as versions of
	    XML::XSH::Functions, XML::LibXML, and XML::LibXSLT modules
	    used.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="validation" type="command" name="validation"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_validation,$item[3]]</action>
      </production>
      <documentation>
	<usage>validation <xref linkend="expression"/></usage>
	<description>
	  <para>
	    Turn on validation during the parse process if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    Defaults to on.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="recovering" type="command" name="recovering"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_recovering,$item[3]]</action>
      </production>
      <documentation>
	<usage>recovering <xref linkend="expression"/></usage>
	<description>
	  <para>
	    Turn on recovering parser mode if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    Defaults to off. Note, that the in the recovering mode,
            validation is not performed by the parser even if
	    the validation flag is on and that recovering mode flag
            only influences parsing of XML documents (not HTML).
	  </para>
	  <para>The recover mode helps to efficiently recover
	  documents that are almost well-formed. This for example
	  includes documents without a close tag for the document
	  element (or any other element inside the document).</para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_entities" type="command"
    name="parser_expands_entities" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_entities,$item[3]]</action>
      </production>
      <documentation>
	<usage>parser_expands_entities <xref linkend="expression"/></usage>
	<description>
	  <para>
	    Turn on the entity expansion during the parse process if the
	    <xref linkend="expression"/> is non-zero on or off otherwise.  If entity
	    expansion is off, any external parsed entities in the
	    document are left as entities. Defaults to on.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="keep_blanks" type="command" name="keep_blanks"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_keep_blanks,$item[3]]</action>
      </production>
      <documentation>
	<usage>keep_blanks <xref linkend="expression"/></usage>
	<description>
	  <para>
	    Allows you to turn off XML::LibXML's default behaviour of
	    maintaining whitespace in the document. Non-zero expression
	    forces the XML parser to preserve all whitespace.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="pedantic_parser" type="command" name="pedantic_parser"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_pedantic_parser,$item[3]]</action>
      </production>
      <documentation>
	<usage>pedantic_parser <xref linkend="expression"/></usage>
	<description>
	  <para>
	    If you wish, you can make XML::LibXML more pedantic by passing
	    a non-zero <xref linkend="expression"/> to this command.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="complete_attributes" type="command"
    name="complete_attributes" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_complete_attributes,$item[3]]</action>
      </production>
      <documentation>
	<usage>complete_attributes <xref linkend="expression"/></usage>
	<description>
	  <para>
	    If the expression is non-zero, this command allows XML parser
	    to complete the elements attributes lists with the ones
	    defaulted from the DTDs.  By default, this option is enabled.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="indent" type="command" name="indent" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_indent,$item[3]]</action>
      </production>
      <documentation>
	<usage>indent <xref linkend="expression"/></usage>
	<description>
	  <para>Format the XML output while saving a document.</para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_xinclude" type="command"
    name="parser_expands_xinclude" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_xinclude,$item[3]]</action>
      </production>
      <documentation>
	<usage>parser_expands_xinclude <xref
	    linkend="expression"/></usage>
	<description>
	  <para>
	    If the <xref linkend="expression"/> is non-zero, the parser is
	    allowed to expand XIinclude tags imidiatly while parsing the
	    document.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="process_xinclude_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="load_ext_dtd" type="command" name="load_ext_dtd"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_load_ext_dtd,$item[3]]</action>
      </production>
      <documentation>
	<usage>load_ext_dtd <xref linkend="expression"/></usage>
	<description>
	  <para>
	    If the expression is non-zero, XML parser loads external DTD
	    subsets while parsing. By default, this option is enabled.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="encoding" type="command" name="encoding" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_encoding,$item[3]]</action>
      </production>
      <documentation>
	<usage>encoding <xref linkend="enc_string"/></usage>
	<description>
	  <para>Set the default output character encoding.</para>
	</description>
      </documentation>
    </rule>
    <rule id="query_encoding" type="command" name="query-encoding"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_qencoding,$item[3]]</action>
      </production>
      <documentation>
	<usage>query-encoding <xref linkend="enc_string"/></usage>
	<description>
	  <para>Set the default query character encoding.</para>
	</description>
      </documentation>
    </rule>
    <rule id="quiet" type="command" name="quiet" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_q,1]</action>
      </production>
      <documentation>
	<usage>quiet</usage>
	<description>
	  <para>Turn off verbose messages.</para>
	</description>
	<see-also>
	  <ruleref ref="verbose"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="backups" type="command" name="backups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,1]</action>
      </production>
      <documentation>
	<usage>backups</usage>
	<description>
	  <para>Enable creating backup files on save (default).</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nobackups" type="command" name="nobackups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,0]</action>
      </production>
      <documentation>
	<usage>nobackups</usage>
	<description>
	  <para>Disable creating backup files on save.</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
  </rules>  
</recdescent-xml>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml-tools/dtd/catalog /home/pajas/lib/sgml/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/docbook/3.1/docbook.cat /home/pajas/share/sgml/stylesheets/docbook/catalog /home/pajas/share/sgml/entities/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/jade/dsssl.cat /home/pajas/share/sgml/stylesheets/sgmltools/sgmltools.cat /home/pajas/share/sgml/dtd/sgmltools/catalog")
sgml-local-ecat-files:nil
End:
-->
