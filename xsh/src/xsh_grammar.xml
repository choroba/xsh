<?xml version='1.0'?>
<!DOCTYPE recdescent-xml SYSTEM "recdescent.dtd">
<recdescent-xml>
  <doc>
    <title>XSH</title>
    <shortdesc>XML Editing Shell</shortdesc>
    <description>
      <para>
	XSH acts as a shell interpreter.  Individual commands must be
	separated with a semicolon. Each command may be followed by a
	pipeline redirection used to trap the command's output. In the
	interactive shell, slash may be used at the end of line to
	indicate that the command follows on the next line.
      </para>
      <para>
	Pipeline redirection may be used either to feed the command's
	output to a unix command or to store it into a XSH string
	variable.</para>
      <para> In the first case, a pipeline is simply the pipeline
	character `|' followed by any unix shell command and possibly
	its parameters (if you need to pass a semicolon as a command
	argument, use \;). Brackets may be used to join more shell
	commands.
      </para>
      <example>
	<title>Count any attributes that contain string foo in its name or value.</title>
	<code>xsh> list //words/attribute() | grep foo | wc</code>
      </example>
      <para>
	In the case of storing command's output in a string variable,
	a pipeline consists of characters `|>' followed by any valid
	XSH variable name.
      </para>
      <example>
	<title>Store the number of all words in a variable named count.</title>
	<code>xsh> count //words |> $count</code>
      </example>
      <para>
	To navigate documents, `cd' command may be used followed by an
	XPath expression (much like in the usual filesystem).
      </para>
      <para>
	`help command' gives a list of all XSH commands.
      </para>
      <para>
	`help type' gives a list of all argument types.
      </para>
      <para>
	`help' followed by a command or type name gives more
	information on the particular command or argument type.
      </para>
    </description>
    <section id="documents">
      <title>Files/Documents</title>
      <para>
	XSH is intended to query and manipulate XML and HTML
	documents. Use one of the 'open'/'create' commands to load an
	XML or HTML document from a local file, external URL (such as
	http:// or ftp://), string or pipe.  While loading, XSH parses
	and optionally validates (see <xref linkend="validation"/> and
	<xref linkend="load_ext_dtd"/>) the document. Parsed documents
	are stored in memory as
	<ulink url="http://www.w3.org/DOM/">DOM</ulink> trees,
	that can be <link linkend="navigation">navigated</link>
	and <link linkend="manipulation">manipulated</link>
	quite similarly as a local filesystem.
      </para>
      <para>
	Every opened document is associated with an identifier (<xref
	  linkend="ID"/>), that is a symbolic name for the document in
	  XSH and can be used for example as a prefix of <link
	  linkend="xpath">XPath expressions</link>.
      </para>
      <para>
	In the current version, XSH is only able to save documents
	locally.  To store a document on any other location, use <xref
	linkend="list_command"/> command and pipe redirection to feed
	the XML representation of the document to any external program
	that is able to store it on a remote location.
      </para>
      <example>
	<title>Store XSH document DOC on a remote machine using Secure Shell</title>
	<code>xsh> <userinput>list DOC:/ | ssh my.remote.org 'cat > test.xml'</userinput></code>
      </example>
    </section>
    <section id="navigation">
      <title>Tree navigation</title>
      <para>
	It is possible to browse <link linkend="documents">document
	trees</link> as if they were a local filesystem, except that
	<link linkend="xpath">XPath</link> expressions are used
	instead of ordinary UNIX paths.</para> <para>Current position
	in the document tree is called <emphasis>current
	node</emphasis>.  Current node's XPath may be queried with
	<xref linkend="pwd_command"/> command.  In the interactive
	shell, current node is also displayed in the command line
	prompt. Remember, that beside <xref
	linkend="chxpath_command"/> command, current node (and
	document) is silently changed by all variant of <xref
	linkend="open_command"/> command, <xref
	linkend="create_command"/> command and temporarily also by the
	node-list variant of the <xref linkend="foreach_command"/>
	statement.
      </para>
      <para>Documents are specified
	in a similar way as harddrives on DOS/Windows(TM) systems
	(except that their names are not limitted to one letter in
	XSH), i.e. by a prefix of the form doc: where doc is the
	<xref linkend="ID"/> associated with the document.
      </para>
      <para>
	To mimic the filesystem navigation as closely as
	possible, XSH contains several commands named by analogy of
	UNIX filesystem commands, such as <xref
	  linkend="chxpath_command"/>, <xref linkend="list_command"/> and
	<xref linkend="pwd_command"/>.	
      </para>
      <example>
	<code>xsh scratch:/> <userinput>open docA="testA.xml"</userinput>
	  xsh docB:/> <userinput>open docB="testB.xml"</userinput>
	  xsh> <userinput>pwd</userinput>
	  docB:/
	  xsh docB:/> <userinput>cd docA:/article/chapter[title='Conclusion']</userinput>
	  xsh docA:/article/chapter[5]> <userinput>pwd</userinput>
	  docA:/article/chapter[5]
	  xsh docA:/article/chapter[5]> <userinput>cd previous-sibling::chapter</userinput>
	  xsh docA:/article/chapter[4]> <userinput>cd ..</userinput>
	  xsh docA:/article> <userinput>select docB</userinput>
	  xsh docB:/>
	</code>
      </example>
    </section>
    <section id="manipulation">
      <title>Tree modification</title>
      <para>
	XSH provides mechanisms not only to browse and inspect the DOM
	tree but also to modify its content by providing commands for
	copying, moving, deleting its nodes or add new nodes or
	XML fragments to it. It is quite easy to learn these commands
	since their names or aliases mimic their usual filesystem analogies.
	However, many of these commands have two versions one of which
	is prefixed with a letter "x". This "x" stands for "cross",
	thus e.g. <xref linkend="xcopy_command"/> should be read as
	"cross copy". Let's explain the difference on this example.</para>
      <para>
	When you copy, you have to specify what are you copying and
	where are you copying to, so you have to specify the
	<emphasis>source</emphasis> and the
	<emphasis>target</emphasis>.  XSH is very much XPath-based so,
	XPath is used here to specify both of them. However, there
	might be more than one node that satisfies a given XPath expression. So,
	the rule of thumb is that the "cross" variant of a
	command places <emphasis>one and every</emphasis> of the source nodes
	to the location of <emphasis>one and every</emphasis> destination
	node, while the plain variant works one-by-one, placing the
	first source node to the first destination, the second source
	node to the second destination, and so on (as long as there
	are some source nodes and free destinations left).
      </para>
      <example>
	<code>xsh> <userinput>create a "&lt;X>&lt;A/>&lt;Y/>&lt;A/>&lt;/X>";</userinput>
	  xsh> <userinput>create b "&lt;X>&lt;B/>&lt;C/>&lt;B/>&lt;C/>&lt;B/>&lt;/X>";</userinput>
	  xsh> <userinput>xcopy a://A replace b://B;</userinput>
	  xsh> <userinput>copy b://C before a://A;</userinput>
	  xsh> <userinput>ls a:/;</userinput>
	  &lt;?xml version="1.0" encoding="utf-8"?>
	  &lt;X>&lt;C/>&lt;A/>&lt;Y/>&lt;C/>&lt;A/>&lt;/X>

	  xsh> <userinput>ls b:/;</userinput>
	  &lt;?xml version="1.0" encoding="utf-8"?>
	  &lt;X>&lt;A/>&lt;A/>&lt;C/>&lt;A/>&lt;A/>&lt;C/>&lt;A/>&lt;A/>&lt;/X>
	</code>
      </example>
      <para>
	As already indicated by the example, another issue of tree
	modification is the way in which the destination node
	determines the target location. Should the source node be
	placed before, after, or into the resulting node? Should it
	replace it completely? This information has to be given in the
	<xref linkend="loc"/> argument that usually precedes the
	destination XPath.
      </para>
      <para>
	Finally, what happens if source and destination nodes are of
	incompatible types? XSH tries to avoid this by implicitly
	converting between node types when necessary.  For example, if
	a text, comment, and attribute node is copied into, before or
	after an attribute node, the original attribute value of the
	attribute is replaced, prepended or appended respectively with
	the textual content of the source node. Note however, that
	<emphasis>element nodes are never converted</emphasis> into
	text, attribute or any other textual node.  There
	are many combinations here, so try yourself and see the
	results.
      </para>
      <para>You may even use some more sofisticated way to convert
	between node types, as shown in the following example, where
	an element is first commented out and than again uncommented.
	Note, that the particular approach used for resurrecting the
	commented XML material works only for well-balanced chunks of
	XML.
      </para>
      <example>
	<title>Using string variables to convert between different
	  types of nodes</title>
	<code>
	  xsh> <userinput>create doc "&lt;?xml version='1.0'?>
&lt;book>
  &lt;chapter>
    &lt;title>Intro&lt;/title>
  &lt;/chapter>
  &lt;chapter>
    &lt;title>Rest&lt;/title>
  &lt;/chapter>
&lt;/book>";</userinput>

	  # comment out the first chapter
	  xsh> <userinput>ls //chapter[1] |> $chapter_xml;</userinput>
	  xsh> <userinput>add comment $chapter_xml replace //chapter[1];</userinput>

# show the result
	  xsh> <userinput>ls / 0;</userinput>
&lt;?xml version="1.0"?>
&lt;book>
  &lt;!--&lt;chapter>
    &lt;title>Intro&lt;/title>
  &lt;/chapter>
-->
  &lt;chapter>
    &lt;title>Rest&lt;/title>
  &lt;/chapter>
&lt;/book>


# un-comment the chapter
	  xsh> <userinput>$comment = string(//comment()[1]);</userinput>
	  xsh> <userinput>add chunk $comment replace //comment()[1];</userinput>

# show the result
	  xsh> <userinput>ls / 0;</userinput>
&lt;?xml version="1.0"?>
&lt;book>
  &lt;chapter>
    &lt;title>Intro&lt;/title>
  &lt;/chapter>

  &lt;chapter>
    &lt;title>Rest&lt;/title>
  &lt;/chapter>
&lt;/book>
	</code>
      </example>
    </section>
    <section id="flow">
      <title>Flow control</title>
      <para>
	What a scripting language XSH would be had it not some kind of
	conditional statements, loops and other stuff that
	influences the way in which XSH commands are processed.
      </para>
      <para>
	Most notable XSH's feature in this area is that some of the
	basic flow control statements, namely <xref linkend="if"/>,
	<xref linkend="unless"/>, <xref linkend="while"/> and <xref
	linkend="foreach_command"/> have two variants, an XPath-based
	one and a Perl-based one.  The XPath-based variants use <xref
	linkend="xpath"/> expressions to specify the condition or
	node-lists to iterate, while the other one utilizes <xref
	linkend="perl_code"/> for this purpose. See 
	descriptions of the individual statements for more detail.
      </para>
    </section>
    <section id="information">
      <title>Retrieving more information</title>
      <para> Beside the possibility to browse the DOM tree and
	list some parts of it (as described in <xref
	  linkend="navigation"/>), XSH provides commands to obtain other
	kind information related to open documents as well as the XSH
	interpreter itself. These commands are listed bellow.
      </para>
    </section>
    <section id="argtypes">
      <title>Argument Types</title>
    </section>
    <section id="variables">
      <title>Variables</title>
    </section>
    <section id="configuration">
      <title>Options</title> <para>The following commands are used to
	modify the default behaviour of the XML parser or XSH itself.
	Some of the commands are switch between two different modes
	according to a given expression (which is expected to result
	either in zero or non-zero value). Other commands also working
	as a flip-flop have their own explicit counterpart (e.g. 
	<xref linkend="verbose"/> and <xref linkend="quiet"/> or
	<xref linkend="debug"/> and <xref linkend="nodebug"/>).
	This misconsistency is due to historical reasons.
      </para>
      <para>
	The <xref linkend="encoding"/> and <xref
	linkend="query_encoding"/> options allow to specify character
	encoding that should be expected from user as well as the
	encoding to be used by XSH on output. This is particularly
	useful when you work with UTF-8 encoded documents on a console
	which supports only 8-bit characters.
      </para>
      <para>
	The <xref linkend="options_command"/> command
	displays current settings by means of XSH commands.
	Thus it can not only be used to review current values, but
	also to store them future use, e.g. in ~/.xshrc file.
      </para>
      <example>
	<code>xsh> <userinput>options > cat > ~/.xshrc</userinput></code>
      </example>
    </section>
    <section id="binding">
      <title>Interacting with Shell and Perl</title>
    </section>
  </doc>
  <preamb>
<![CDATA[
package XML::XSH::Grammar;

use strict;
use Parse::RecDescent;
use vars qw/$grammar/;

$Parse::RecDescent::skip = '(\s|\n|#[^\n]*)*';
$grammar=<<'_EO_GRAMMAR_';
]]>
  </preamb>
  <postamb>
<![CDATA[

_EO_GRAMMAR_

sub compile {
  Parse::RecDescent->Precompile($grammar,"XML::XSH::Parser");
}

sub new {
  return new Parse::RecDescent ($grammar);
}

1;
]]>
  </postamb>
  <rules>
    <!-- ================== commands and options ====================== -->
    <rule id="command" type="list">
      <ruleref ref="backups"/>
      <ruleref ref="nobackups"/>
      <ruleref ref="quiet"/>
      <ruleref ref="verbose"/>
      <ruleref ref="test_mode"/>
      <ruleref ref="run_mode"/>
      <ruleref ref="debug"/>
      <ruleref ref="nodebug"/>
      <ruleref ref="version"/>
      <ruleref ref="validation"/>
      <ruleref ref="recovering"/>
      <ruleref ref="parser_expands_entities"/>
      <ruleref ref="keep_blanks"/>
      <ruleref ref="pedantic_parser"/>
      <ruleref ref="complete_attributes"/>
      <ruleref ref="indent"/>
      <ruleref ref="parser_expands_xinclude"/>
      <ruleref ref="load_ext_dtd"/>
      <ruleref ref="encoding"/>
      <ruleref ref="query_encoding"/>
      <ruleref ref="options_command"/>
      <ruleref ref="copy_command"/>
      <ruleref ref="xcopy_command"/>
      <ruleref ref="move_command"/>
      <ruleref ref="xmove_command"/>
      <ruleref ref="list_command"/>
      <ruleref ref="exit_command"/>
      <ruleref ref="prune_command"/>
      <ruleref ref="map_command"/>
      <ruleref ref="sort_command"/>
      <ruleref ref="close_command"/>
      <ruleref ref="openhtml_command"/>
      <ruleref ref="openpipe_command"/>
      <ruleref ref="validate_command"/>
      <ruleref ref="valid_command"/>
      <ruleref ref="list_dtd_command"/>
      <ruleref ref="print_enc_command"/>
      <ruleref ref="cd_command"/>
      <ruleref ref="clone_command"/>
      <ruleref ref="count_command"/>
      <ruleref ref="eval_command"/>
      <ruleref ref="saveas_command"/>
      <ruleref ref="savexinclude_command"/>
      <ruleref ref="savehtml_command"/>
      <ruleref ref="save_command"/>
      <ruleref ref="files_command"/>
      <ruleref ref="xslt_command"/>
      <ruleref ref="insert_command"/>
      <ruleref ref="xinsert_command"/>
      <ruleref ref="help_command"/>
      <ruleref ref="exec_command"/>
      <ruleref ref="call_command"/>
      <ruleref ref="include_command"/>
      <ruleref ref="assign_command"/>
      <ruleref ref="print_var_command"/>
      <ruleref ref="var_command"/>
      <ruleref ref="print_command"/>
      <ruleref ref="create_command"/>
      <ruleref ref="list_defs_command"/>
      <ruleref ref="select_command"/>
      <ruleref ref="if_command"/>
      <ruleref ref="unless_command"/>
      <ruleref ref="while_command"/>
      <ruleref ref="foreach_command"/>
      <ruleref ref="def"/>
      <ruleref ref="process_xinclude_command"/>    	
      <ruleref ref="chxpath_command"/>
      <ruleref ref="pwd_command"/>
      <ruleref ref="locate_command"/>
      <ruleref ref="xupdate_command"/>
      <ruleref ref="open_command"/>
      <documentation>
	<title>List of XSH commands</title>
	<description>
	  <para><typeref types="command"/></para>
	</description>
      </documentation>
    </rule>

    <rule id="statement">
      <production>
	<group>
	  <production><ruleref ref="if"/></production>
	  <production><ruleref ref="unless"/></production>
	  <production><ruleref ref="while"/></production>
	  <production><ruleref ref="foreach"/></production>
	  <production><ruleref ref="def"/></production>
	</group>
	<action>$item[1]</action>
      </production>
      <production><directive type="error"></directive></production>
    </rule>

    <rule id="complex_command">
      <production>
	<literal>;</literal>
      </production>
      <production>
	<ruleref ref="command"/>
	<ruleref ref="trail" rep="?"/>
	<group>
	  <production>
	    <literal>;</literal>
	  </production>
	  <production>
	    <lookahead/>
	    <regexp>^\s*(}|\Z)</regexp>
	  </production>
	</group>
	<action>
	  my $r=$item[1];
	  if (scalar(@{$item[2]})) {
	    if ($item[2][0][0] eq 'pipe') {
  	      $r=[\&amp;XML::XSH::Functions::pipe_command,[$r],$item[2][0][1]]
	    } else {
   	      $r=[\&amp;XML::XSH::Functions::string_pipe_command,[$r],$item[2][0][1]]
	    }
          }
	  $r
	</action>
      </production>
      <production><directive type="error"></directive></production>
    </rule>

    <rule id="statement_or_command">
      <production><ruleref ref="statement"/></production>
      <production><ruleref ref="complex_command"/></production>
    </rule>

    <rule id="block" type="argtype" name="command-block">
      <production>
	<literal>{</literal>
	<directive type="commit"></directive>
	<ruleref ref="statement_or_command" rep="s"/>
	<literal>}</literal>
	<action>[grep ref,@{$item[3]}]</action>
      </production>
      <documentation sections="argtypes">
	<title>command-block argument type</title>
	<shortdesc>single XSH command or a block of XSH commands</shortdesc>
	<description>
	  <para>
	    XSH command or a block of semicolon-separated
	    commands enclosed within curly brackets.
	  </para>
	  <example>
	    <title>Count paragraphs in each chapter</title>
	    <code>
	      $i=0;
	      foreach //chapter {
	      $c=./para;
	      $i=$i+1;
	      print "$c paragraphs in chapter no.$i";
	      }
	    </code>
	  </example>
	</description>	
      </documentation>
    </rule>



    <!-- ================== help on types ====================== -->
    <rule id="type" type="list">
      <production></production>
      <documentation>
	<title>List of command argument types</title>
	<description>
	  <para><typeref types="argtype"/></para>
	</description>
      </documentation>
    </rule>
    <!-- ================== terminals ====================== -->
    <rule id="TOKEN">
      <production>
	<regexp>\S+</regexp>
      </production>
    </rule>
    <rule id="STRING">
      <production>
	<regexp>([^'"\$\\ \t\n\r\|;\{\}]|\$[^{]|\$\{[^{}]*\}|]|\\.)+</regexp>
      </production>
    </rule>
    <rule id="single_quoted_string">
      <production>
	<regexp>\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\'</regexp>
	<action>
	  local $_=$item[1];
	  s/^\'|\'$//g;
	  s/\\([^\$])/$1/g;
	  $_;
	</action>
      </production>
    </rule>
    <rule id="double_quoted_string">
      <production>
	<regexp>\"([^\"\\]|\\.)*\"</regexp>
	<action>
	  local $_=$item[1];
	  s/^\"|\"$//g;
	  s/\\(.)/$1/g;
	  $_;
	</action>
      </production>
    </rule>
    <!-- ================== expressions ====================== -->
    <rule id="exp_part">
      <production>
	<ruleref ref="STRING"/>
      </production>
      <production>
	<ruleref ref="exp_inline_count"/>
      </production>
      <production>
	<ruleref ref="single_quoted_string"/>
      </production>
      <production>
	<ruleref ref="double_quoted_string"/>
      </production>
    </rule>
    <rule id="exp_inline_count">
      <production>
	<regexp>\${{([^}]|}[^}])*}}</regexp>
      </production>
    </rule>
    <rule id="expression" type="argtype">
      <production>
	<ruleref ref="exp_part"/>	
	<directive type="skip">""</directive>
	<ruleref ref="expression" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
      <documentation sections="argtypes variables">
	<title>expression argument type</title>
	<shortdesc>string-like expression</shortdesc>
	<description>
	  <para>
	    A string consisting of unquoted characters other than
	    whitespace or semicolon, single quote or double quote
	    characters or quoted characters of any kind. By quoting we
	    mean preceding a single character with a backslash or
	    enclosing a part of the string into single quotes '...'  or
	    double quotes "...". Quoting characters are removed from the
	    string so they must be quoted themselves if they are a part of
	    the expression: \\, \' or "'", \" or '"'.
	  </para>
	  <para>
	    Variable interpolation is performed on expressions, which
	    means that any substrings of the forms $id or ${id} where $ is
	    unquoted and id is an identifier are substituted with the
	    value of the variable named $id.
	  </para>
	  <para>
	    XPath interpolation is performed on expressions, which means
	    that any substring enclosed in between ${{ and }} is evaluated
	    in the same way as in the count command and the result of the
	    evaluation is substituted in its place.
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- ================= optional arguments =================== -->
    <rule id="ws">
      <production>
	<regexp>(\s|\n|#[^\n]*)+</regexp>
      </production>
    </rule>
    <rule id="optional_expression">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_expressions">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression" rep="s"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_xpath">
      <production>
	<directive type="skip">""</directive>
	<ruleref ref="ws"/>
	<ruleref ref="xpath"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== encoding string ====================== -->
    <rule id="enc_string" type="argtype" name="enc-string">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation sections="argtypes">
	<title>enc_string argument type</title>
	<shortdesc>character encoding (codepage) identifier</shortdesc>
	<description>
	  <para>
	    An <xref linkend="expression"/> which interpolates to a valid encoding
	    string, e.g. to utf-8, utf-16, iso-8859-1, iso-8859-2,
	    windows-1250 etc.
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- ================== identifyer ====================== -->
    <rule id="ID" type="argtype" name="id">
      <production>
	<regexp>[a-zA-Z_][a-zA-Z0-9_]*</regexp>
      </production>
      <documentation sections="argtypes variables">
	<title>id argument type</title>
	<shortdesc>identifier</shortdesc>
	<description>
	  <para>
	    An identifier, that is, a string beginning with a letter or
	    underscore, and containing letters, underscores, and
	    digits.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="id_or_var">
      <production><ruleref ref="ID"/></production>
      <production><ruleref ref="variable"/></production>
    </rule>
    <!-- ================== filename ====================== -->
    <rule id="filename" type="argtype">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation sections="argtypes">
	<title>Filename argument type</title>
	<shortdesc>file name</shortdesc>
	<description>
	  <para>An <xref linkend="expression"/> which interpolates to a valid file name.</para>
	</description>
      </documentation>
    </rule>
    <!-- ================== XPATH ====================== -->
    <rule id="xpath" type="argtype">
      <production>
	<ruleref ref="id_or_var"/>
	<directive type="skip">""</directive>
	<regexp>:(?!:)</regexp>
	<ruleref ref="xp"/>
	<action>[$item[1],$item[4]]</action>
      </production>
      <production>
	<ruleref ref="xp"/>
	<action>[undef,$item[1]]</action>
      </production>
      <production>
	<directive type="error"></directive>
      </production>
      <documentation sections="argtypes">
	<title>Xpath argument type</title>
	<shortdesc>XPath expression</shortdesc>
	<description>
	  <para>
	    Any XPath expression as defined in W3C recommendation at
	    http://www.w3.org/TR/xpath optionally preceded with
	    a document identifier followed by colon. If no identifier
	    is used, the current document is used.
	  </para>
	  <example>
	    <title>Open a document and count all sections containing a
	      subsection in it
	    </title>
	    <code>
	      xsh> open v = mydocument.xml;
	      xsh> count v://section[subsection];
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xpcont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">""</directive>
	<ruleref ref="xp" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xp">
      <production>
	<ruleref ref="xpsimple"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpcont" rep="?"/>
	<action>$item[1].join("",@{$item[3]})</action>
      </production>
      <production>
	<ruleref ref="xpstring"/>
      </production>
    </rule>
    <rule id="xpfilters">
      <production>
	<ruleref ref="xpfilter" rep="s"/>
	<action>join("",@{$item[1]})</action>
      </production>
    </rule>
    <rule id="xpfilter">
      <production>
	<literal>[</literal>
	<ruleref ref="xpinter"/>
	<literal>]</literal>
	<action>"[$item[2]]"</action>
      </production>
    </rule>
    <rule id="xpbracket">
      <production>
	<literal>(</literal>
	<ruleref ref="xpinter"/>
	<literal>)</literal>
	<action>"($item[2])"</action>
      </production>
    </rule>
    <rule id="xpbrackets">
      <production>
	<ruleref ref="xpbracket"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpfilters" rep="?"/>
	<action>join "",$item[1],@{$item[3]}</action>
      </production>
    </rule>
    <rule id="xpintercont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">""</directive>
	<ruleref ref="xpinter" rep="?"/>
	<action>join("",$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xpinter">
      <production>
	<ruleref ref="xps"/>
	<directive type="skip">""</directive>
	<ruleref ref="xpintercont" rep="?"/>
	<action>join("",$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xps">
      <production>
	<regexp>([^][()'"]|'[^']*'|"[^"]*")*</regexp>
      </production>
    </rule>
    <rule id="xpstring">
      <production>
	<regexp>'[^']*'|"[^"]*"</regexp>
      </production>
    </rule>
    <rule id="xpsimple">
      <production>
	<regexp>[^]|"' [();]+</regexp>
      </production>
      <production>
	<ruleref ref="xpbrackets"/>
      </production>
    </rule>
    <!-- ================== perl expression=expression ====================== -->
    <rule id="perl_expression">
      <production>
	<ruleref ref="expression"/>
      </production>
    </rule>
    <!-- ================== variables ====================== -->
    <rule id="variable">
      <production>
	<literal>$</literal>
	<directive type="skip">""</directive>
	<ruleref ref="ID"/>
	<action>"$item[1]$item[3]"</action>
      </production>
    </rule>
    <rule id="nodelistvariable">
      <production>
	<literal>%</literal>
	<directive type="skip">""</directive>
	<ruleref ref="id_or_var"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== EOF ====================== -->
    <rule id="eof">
      <production>
	<regexp>^\Z</regexp>
	<action>1;</action>
      </production>
    </rule>
    <!-- ================== STARTRULE and such ====================== -->
    <rule id="startrule">
      <production>
	<ruleref ref="shell"/>
	<directive type="commit"></directive>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1])</action>
      </production>
      <production>
	<ruleref ref="statement_or_command" rep="s"/>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1])</action>
      </production>
    </rule>
    <rule id="trail">
      <production>
	<literal>|></literal>
	<directive type="commit"></directive>
	<ruleref ref="variable"/>
	<action>['var',$item[3]]</action>
      </production>
      <production>
	<literal>|</literal>
	<directive type="commit"></directive>
	<ruleref ref="shline"/>
	<action>['pipe',$item[3]]</action>
      </production>
    </rule>
    <rule id="shline_nosc">
      <production>
	<regexp>([^;()\\"'\|]|\|[^&gt;]|\\.|\"([^\"\\]|\\.)*\"|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_inter">
      <production>
	<regexp>([^()\\"']|\\.|\"([^\"\\]|\\.)*\"|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_bracket">
      <production>
	<literal>(</literal>
	<ruleref ref="shline_inter"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_inter"/>
	<literal>)</literal>
	<action>join("",'(',$item[2],@{$item[3]},$item[4],')')</action>
      </production>      
    </rule>
    <rule id="shline">
      <production>
	<ruleref ref="shline_nosc"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_nosc"/>
	<action>join("",$item[1],@{$item[2]},$item[3])</action>
      </production>
    </rule>
    <rule id="shell">
      <production>
	<regexp>!\s*</regexp>
	<regexp>.*</regexp>
	<action>[[\&amp;XML::XSH::Functions::sh,$item[2]]]</action>
      </production>
    </rule>
    <!-- ================== STATEMENTS ====================== -->
    <rule id="condition">
      <production><directive type="perl_codeblock"/></production>
      <production><ruleref ref="xpath"/></production>
    </rule>
    <rule id="else_block" name="else">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="block"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- if -->
    <rule type='command' id="if" name="if">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="else_block" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,$item[3],$item[4],@{$item[5]}]</action>
      </production>
      <documentation sections="flow">
	<usage>if <xref linkend="xpath"/>|<xref linkend="perl_code"/> <xref linkend="command"/>
	</usage>
	<usage>
          if <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="block"/> [ else <xref linkend="block"/> ]
	</usage>
	<shortdesc>if statement</shortdesc>
	<description>
	  <para>
	    Execute <xref linkend="block"/> if the given 
	    <xref linkend="xpath"/> or <xref linkend="perl_code"/>
	    expression evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or non-empty
	    literal. 
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="if_command" name="if" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <!-- unless -->
    <rule type='command' id="unless" name="unless">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="else_block" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],$item[4],@{$item[5]}]</action>
      </production>
      <documentation sections="flow">
	<usage>unless <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="command"/>
	</usage>
	<usage>
          unless <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="block"/> [ else <xref linkend="block"/> ]
	</usage>
	<shortdesc>negated if statement</shortdesc>
	<description>
	  <para>Like if but negating the result of the expression.</para>
	</description>
	<see-also>
	  <ruleref ref="if"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="unless_command" name="unless" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <!-- while -->
    <rule id="while_command" name="while" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="while" type="command" name="while">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],$item[4]]</action>
      </production>
      <documentation sections="flow">
	<usage>while <xref linkend="xpath"/>|<xref linkend="perl_code"/> <xref
	    linkend="block"/></usage>
	<shortdesc>simple while loop</shortdesc>
	<description>
	  <para> Execute <xref linkend='block'/> as long as
	    the given <xref linkend='xpath'/> or <xref
	      linkend='perl_code'/> expression evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or
	    non-empty literal.
	  </para>
	  <example>
	    <title>The commands have the same results</title>
	    <code>
	      xsh> while /table/row remove /table/row[1];
	      xsh> remove /table/row;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- foreach -->
    <rule id="foreach_command" name="foreach" inline="yes">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="foreach" type="command" name="foreach">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],$item[4]]</action>
      </production>
      <documentation sections="flow">
	<usage>foreach <xref linkend="xpath"/>|<xref linkend="perl_code"/> 
	  <xref linkend="command"/>
	  <xref linkend="block"/></usage>
	<shortdesc>loop iterating over a node-list or perl array</shortdesc>
	<description>
	  <para>
	    If the first argument is an <xref linkend="xpath"/>
	    expression, execute the command-block for each node
	    matching the expression making it temporarily the current
	    node, so that all relative XPath
	    expressions are evaluated in its context.
	  </para>
	  <para>
	    If the first argument is a <xref linkend="perl_code"/>,
	    it is evaluated and the resulting perl-list is 
	    iterated setting the variable $__
	    to be each element of the list in turn. It works much
	    like perl's foreach, except that the variable used
	    consists of two underscores.
	  </para>
	  <example>
	    <title>Move all employee elements in a company element
	      into a staff subelement of the same company</title>
	    <code>xsh> foreach //company xmove ./employee into ./staff;</code>
	  </example>
	  <example>
	    <title>List content of all XML files in current directory</title>
	    <code>
	      xsh> foreach { glob('*.xml') } { open f=$__; list f:/; }
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- def -->
    <rule id="def" type="command" name="def">
      <aliases>
	<alias name="define"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="ID"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::def,$item[3],$item[4]]</action>
      </production>
      <documentation sections="flow">
	<usage>def <xref linkend="ID"/> <xref linkend="block"/></usage>
	<shortdesc>sub-routine (macro) declaration</shortdesc>
	<description>
	  <para>
	    Define a new XSH routine named <xref linkend='ID'/>. The
	    <xref linkend='block'/> may be later invoked using
	    the `call <xref linkend='ID'/>' command.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="call_command"/>
	</see-also>
      </documentation>
    </rule>
    <!-- ================== COMMANDS ====================== -->
    <rule id="assign_command" type="command" name="assign"
    inline="yes">
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="variable"/>
	<literal>=</literal>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::xpath_assign,$item[2],$item[4]]</action>
      </production>
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="nodelistvariable"/>
	<literal>=</literal>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::nodelist_assign,$item[2],$item[4]]</action>
      </production>
      <documentation sections="variables">
	<usage>assign $<xref linkend='ID'/>=<xref
	    linkend="expression"/>
	</usage>
	<usage>
	  $<xref linkend='ID'/>=<xref
	    linkend="expression"/></usage>
	<usage>
	  assign %<xref linkend='ID'/>=<xref
	    linkend="xpath"/></usage>
	<usage>
	  %<xref linkend='ID'/>=<xref
	    linkend="xpath"/></usage>
	<shortdesc>variable assignment</shortdesc>
	<description>
	  <para> 
	    In the first two cases (where dollar sign appears)
	    store the result of interpolation of the <xref
	      linkend="expression"/> in a variable named $<xref
	      linkend='ID'/>. The variable may be later used in other
	    expressions or even in perl-code as $<xref linkend='ID'/> or
	    ${<xref linkend='ID'/>}.
	  </para>
	  <para> 
	    In the other two cases (where percent sign appears)
	    find all nodes matching the given <xref linkend="xpath"/>
	    and store the resulting node-list in the variable
	    named %<xref linkend='ID'/>. The variable may be later used
	    instead of an XPath expression.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="print_var_command" inline="yes">
      <production>
	<ruleref ref="variable"/>
	<action>[\&amp;XML::XSH::Functions::print_var,$item[1]]</action>
      </production>
    </rule>
    <rule id="options_command" type="command" name="options"
    inline="yes">
      <aliases>
	<alias name="flags"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<action>[\&amp;XML::XSH::Functions::list_flags]</action>
      </production>
      <documentation sections="information options">
	<usage>options</usage>
	<shortdesc>list current settings using XSH syntax</shortdesc>
	<description>
	  <para>List current values of all XSH flags and options (such as
	  validation flag or query-encoding).</para>
	  <example>
	    <title>Store current settings in your .xshrc</title>
	    <code>xsh> options | cat > ~/.xshrc</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="list_defs_command" type="command" name="defs"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<action>[\&amp;XML::XSH::Functions::list_defs]</action>
      </production>
      <documentation sections="information">
	<usage>defs</usage>
	<shortdesc>list all user-defined routines (macros)</shortdesc>
	<description>
	  <para>List names of all defined XSH routines.</para>
	</description>
	<see-also>
	  <ruleref ref="def"/>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="include_command" type="command" name="include"
    inline="yes">
      <aliases>
	<alias name="." regexp="\."/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::include,$item[3]]</action>
      </production>
      <documentation sections="flow">
	<usage>include <xref linkend="filename"/></usage>
	<shortdesc>include another XSH source in current position</shortdesc>
	<description>
	  <para>
	    Include a file named <xref linkend="filename"/> and execute all XSH
	    commands therein.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="call_command" type="command" name="call" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::call,$item[3]]</action>
      </production>
      <documentation sections="flow">
	<usage>call <xref linkend='ID'/></usage>
	<shortdesc>call user-defined routine (macro)</shortdesc>
	<description>
	  <para>
	    Call an XSH subroutine named <xref linkend='ID'/> previously
	    created using def.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="help_command" type="command" name="help" inline="yes">
      <aliases>
	<alias name="?" regexp="\?"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::help,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>help <xref linkend="command"/>|argument-type</usage>
	<shortdesc>on-line documentation</shortdesc>
	<description>
	  <para>Print help on a given command or argument type.</para>
	</description>
      </documentation>
    </rule>
    <rule id="exec_command" type="command" name="exec" inline="yes">
      <aliases>
	<alias name="system"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::sh,join(" ",@{$item[3]})]</action>
      </production>
      <documentation sections="binding">
	<usage>exec <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<shortdesc>execute a shell command</shortdesc>
	<description>
	  <para>execute the system command(s) in <xref linkend="expression"/>s.
	  </para>
	  <example>
	    <title>Count words in "hallo wold" string, then print name
	      of your machine's operating system.</title>
	    <code>
	      exec echo hallo world       # prints hallo world
	      exec "echo hallo word | wc" # counts words in hallo world
	      exec uname;                 # prints operating system name
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xslt_params">
      <production>
	<regexp>(params|parameters)\s</regexp>
	<ruleref ref="param" rep="s"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="xslt_command" type="command" name="xslt" inline="yes">
      <aliases>
	<alias name="transform"/>
	<alias name="xsl"/>
	<alias name="xsltproc"/>
	<alias name="process"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="expression"/>
	<ruleref ref="xslt_params" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xslt,@item[3,4,5],@{$item[6]}]</action>
      </production>
      <documentation sections="manipulation">
	<usage>xslt <xref linkend='ID'/> <xref
	    linkend="filename"/> <xref linkend='ID'/> [(params|parameters) name=<xref
	    linkend="expression"/> [name=<xref linkend="expression"/> ...]]</usage>
	<shortdesc>transform document with XSLT</shortdesc>
	<description>
	  <para>
	    Load an XSLT stylesheet from a file and use it to transform
	    the document of the first <xref linkend='ID'/> into a new
	    document named <xref linkend='ID'/>. Parameters
	    may be passed to a stylesheet after params keyword in the
	    form of a list of name=value pairs where name is the
	    parameter name and value is an <xref linkend="expression"/> interpolating to
	    its value. The resulting value is interpretted by XSLT
	    processor as an XPath expression so e.g. quotes surrounding
	    a XPath string have to be quoted themselves to preveserve
	    them during the XSH expression interpolation.           
	  </para>
	  <example>
	    <code>xslt src stylesheet.xsl rslt params font="'14pt'" color="'red'"</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="param">
      <production>
	<regexp>[^=\s]+</regexp>
	<literal>=</literal>
	<ruleref ref="expression"/>
	<action>[$item[1],$item[3]]</action>
      </production>
    </rule>
    <rule id="files_command" type="command" name="files" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::files]</action>
      </production>
      <documentation sections="information">
	<usage>files</usage>
	<shortdesc>display a list of open files</shortdesc>
	<description>
	  <para>List open files and their identifiers.</para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="var_command" type="command" name="variables"
    inline="yes">
      <aliases>
	<alias name="vars"/>
	<alias name="var"/>
      </aliases>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::variables]</action>
      </production>
      <documentation sections="information">
	<usage>variables</usage>
	<shortdesc>display a list of defined variables</shortdesc>
	<description>
	  <para>List all defined variables and their values.</para>
	</description>
	<see-also>
	  <ruleref ref="files_command"/>
	  <ruleref ref="list_defs_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="copy_command" type="command" name="copy" inline="yes">
      <aliases>
	<alias name="cp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4]]</action>
      </production>
      <documentation sections="manipulation">
	<usage>copy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>copy nodes (in the one-to-one mode)</shortdesc>
	<description>
	  <para>
	    Copies nodes matching the first <xref linkend='xpath'/> to
	    the destinations determined by the <xref
	      linkend='loc'/> directive relative to the second <xref
	      linkend='xpath'/>. If more than one node matches the first
	    <xref linkend='xpath'/> than it is copied to the position
	    relative to the corresponding node matched by the second
	    <xref linkend='xpath'/> according to the order in which are
	    nodes matched. Thus, the n'th node matching the first <xref
	      linkend='xpath'/> is copied to the location relative to the
	    n'th node matching the second <xref linkend='xpath'/>. The
	    possible values for <xref linkend='loc'/> are: after,
	    before, into, replace and cause copying the source nodes
	    after, before, into (as the last child-node).  the
	    destination nodes. If replace <xref linkend='loc'/> is
	    used, the source node is copied before the destination node
	    and the destination node is removed.
	  </para>
	  <para>
	    Some kind of type conversion is used when the types of the
	    source and destination nodes are not equal.  Thus, text,
	    cdata, comment or processing instruction node data prepend,
	    append or replace value of a destination attribute when
	    copied before,after/into or instead (replace) an attribute,
	    and vice versa.
	  </para>
	  <para>
	    Attributes may be copied after, before or into some other
	    attribute to append, prepend or replace the destination
	    attribute value. They may also replace the destination
	    attribute completely (both its name and value).
	  </para>
	  <para>
	    To simply copy an attribute from one element to another,
	    simply copy the attribute node into the destination element.
	  </para>
	  <para>
	    Elements may be copied into other elements (which results in
	    appending the child-list of the destination element), or
	    before, after or instead (replace) other nodes of any type
	    except attributes.
	  </para>
	  <example>
	    <title>Replace living-thing elements in the document b with
	      the coresponding creature elements of the document a.</title>
	    <code>xsh> copy a://creature replace b://living-thing</code>             
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xcopy_command" type="command" name="xcopy" inline="yes">
      <aliases>
	<alias name="xcp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4],1]</action>
      </production>
      <documentation sections="manipulation">
	<usage>xcopy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>copy nodes (in the all-to-every mode)</shortdesc>
	<description>
	  <para>
	    xcopy is similar to copy, but copies *all* nodes matching
	    the first <xref linkend='xpath'/> to *all* destinations determined by the
	    <xref linkend='loc'/> directive relative to the
	    second <xref linkend='xpath'/>. See copy
	    for detailed description of xcopy arguments.
	  </para>
	  <example>
	    <title>Copy all middle-earth creatures within the document a
	      into every world of the document b.</title>
	    <code>xsh> xcopy a:/middle-earth/creature into b://world</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="cd_command" type="command" name="lcd" inline="yes">
      <aliases>
	<alias name="chdir"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::cd,@{$item[3]}]</action>
      </production>
      <documentation sections="binding">
	<usage>lcd <xref linkend="expression"/></usage>
	<shortdesc>change system working directory</shortdesc>
	<description>
	  <para>
	    Changes the filesystem working directory to <xref
	      linkend='expression'/>, if possible.  If <xref
	      linkend='expression'/> is omitted, changes to the directory
	    specified in HOME environment variable, if set; if not,
	    changes to the directory specified by LOGDIR environment
	    variable.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="insert_command" type="command" name="insert"
    inline="yes">
      <aliases>
	<alias name="add"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],0]</action>
      </production>
      <documentation sections="manipulation">
	<usage>insert <xref linkend="nodetype"/> <xref
	    linkend="expression"/> [namespace <xref linkend="expression"/>] <xref linkend='loc'/><xref
	    linkend="xpath"/>
	</usage>
	<shortdesc>create a node in on a given target location</shortdesc>
	<description>
	  <para>
	    Works just like xadd, except that the new node is attached
	    only the first node matched.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="xinsert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xinsert_command" type="command" name="xinsert"
    inline="yes">
      <aliases>
	<alias name="xadd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],1]</action>
      </production>
      <documentation sections="manipulation">
	<usage>xinsert <xref linkend="nodetype"/> <xref
	    linkend="expression"/> [namespace <xref linkend="expression"/>] <xref linkend='loc'/><xref
	    linkend="xpath"/>
	</usage>
	<shortdesc>create nodes on all target locations</shortdesc>
	<description>
	  <para>
	    Use the <xref linkend='expression'/> to create a new node of a given
	    <xref linkend='nodetype'/> in the <xref linkend='loc'/> relative to the given
	    <xref linkend='xpath'/>.
	  </para>
	  <para>
	    For element nodes, the format of the <xref
	      linkend='expression'/> should look like "&lt;element-name
	    att-name='attvalue' ...&gt;".  The `&lt;' and `&gt;'
	    characters are optional. If no attributes are used, the
	    expression may simply consist the element name. Note, that
	    in the first case, the quotes are required since the
	    expression contains spaces.
	  </para>
	  <para>
	    Attribute nodes use the following syntax:
	    "att-name='attvalue' [...]".
	  </para>
	  <para>
	    For the other types of nodes (text, cdata, comments) the
	    expression should contain the node's literal content. Again,
	    it is necessary to quote all whitespace and special
	    characters as in any expression argument.
	  </para>
	  <para>
	    The <xref linkend='loc'/> argument should be one of:
	    `after', `before', `into' and `replace'. You may use `into'
	    location also to attach an attribute to an element or to
	    append some data to a text, cdata or comment node. Note
	    also, that `after' and `before' locations may be used to
	    append or prepend a string to a value of an existing
	    attribute. In that case, attribute name is ignored.
	  </para>
	  <para>
	    The namespace <xref linkend='expression'/> is only valid for
	    elements and attributes and must evaluate to the namespace
	    URI. In that case, the element or attribute name must have a
	    prefix. The created node is associated with the given
	    namespace.
	  </para>
	  <example>
	    <title>Append a new Hobbit element to the list of
	      middle-earth creatures and name him Bilbo.</title>
	    <code>
	      xsh> xadd element "&lt;creature race='hobbit' manner='good'> \
	      into /middle-earth/creatures
	      xsh> xadd attribute "name='Bilbo'" \
	      into /middle-earth/creatures/creature[@race='hobbit'][last()]
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodetype" name="node-type" type="argtype">
      <production>
	<regexp>element|attribute|attributes|text|cdata|pi|comment|chunk|entity_reference</regexp>
      </production>
      <documentation sections="argtypes">
	<title>Node-type argument type</title>
	<shortdesc>node type specification (such as element, attribute, etc.)</shortdesc>
	<description>
	  <para>
	    One of: element, attribute, text, cdata, comment, chunk
	    and (EXPERIMENTALLY!) entity_reference.  A
	    chunk is a character string which forms a well-balanced
	    peace of XML.
	  </para>
	  <example>
	    <code>
	      add element hobbit into //middle-earth/creatures;
	      add attribute 'name="Bilbo"' into //middle-earth/creatures/hobbit[last()];
	      add chunk '&lt;hobbit name="Frodo">A small guy from &lt;place>Shire&lt;/place>.&lt;/hobbit>' \
	      into //middle-earth/creatures;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="namespace">
      <production>
	<regexp>namespace\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="loc" type="argtype" name="location">
      <production><regexp>after\s</regexp>
	<action>"after"</action>
</production>
      <production><regexp>before\s</regexp>
	<action>"before"</action>
</production>
      <production><regexp>(to|into|as child( of)?)\s</regexp>
	<action>"as_child"</action>
      </production>
      <production><regexp>(replace|instead( of)?)\s</regexp>
	<action>"replace"</action>
      </production>
      <documentation sections="argtypes">
	<title>Location argument type</title>
	<shortdesc>relative location specification (such as after, before, etc.)</shortdesc>
	<description>
	  <para>One of: 
	    after, 
	    before, 
	    into/to/as child/as child of, 
	    replace/instead/instead of.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="move_command" type="command" name="move" inline="yes">
      <aliases>
	<alias name="mv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4]]</action>
      </production>
      <documentation sections="manipulation">
	<usage>move <xref linkend="xpath"/> <xref linkend="loc"/> <xref
	    linkend="xpath"/></usage>
	<shortdesc>move nodes (in the one-to-one mode)</shortdesc>
	<description>
	  <para>Like copy, except that move removes the source nodes
	    after a succesfull copy. See copy for more detail.</para>
	</description>
	<see-also>
	  <ruleref ref="copy_command"/>
	  <ruleref ref="xmove_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xmove_command" type="command" name="xmove" inline="yes">
      <aliases>
	<alias name="xmv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4],1]</action>
      </production>
      <documentation sections="manipulation">
	<usage>xmove <xref linkend="xpath"/> <xref linkend="loc"/> <xref
	    linkend="xpath"/></usage>
	<shortdesc>move nodes (in the all-to-every mode)</shortdesc>
	<description>
	  <para>Like xcopy, except that xmove removes the source nodes
	    after a succesfull copy. See copy for more detail.</para>
	</description>
	<see-also>
	  <ruleref ref="xcopy_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="clone_command" type="command" name="clone" inline="yes">
      <aliases>
	<alias name="dup"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::clone,@item[3,5]]</action>
      </production>
      <documentation sections="manipulation documents">
	<usage>clone <xref linkend='ID'/>=<xref linkend='ID'/></usage>
	<shortdesc>clone a given document</shortdesc>
	<description>
	  <para>
	    Make a copy of the document identified by the <xref
	      linkend='ID'/> following the equal sign assigning it the
	    identifier of the first <xref linkend='ID'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="list_command" type="command" name="ls" inline="yes">
      <aliases>
	<alias name="list"/>
      </aliases>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],$item[3]]</action>
      </production>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],-1]</action>
      </production>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::list,[undef,'.'],1]</action>
      </production>
      <documentation sections="navigation information">
	<usage>list <xref linkend="xpath"/> [<xref linkend="expression"/>]</usage>
	<shortdesc>list given part of the document as XML</shortdesc>
	<description>
	  <para>
	    List the XML representation of all nodes matching <xref
	      linkend='xpath'/>. The optional expression argument may be
	    provided to specify the depth of XML tree listing. If
	    negative, the tree will be listed to arbitrary depth.
	    Unless in quiet mode, this command prints number of nodes
	    matched on stderr.	   
	  </para>
	  <para>
	    If the <xref linkend="xpath"/> parameter is omitted,
	    current context node is listed to the depth of 1.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	</see-also>
      </documentation>    
    </rule>
    <rule id="count_command" type="command" name="count" inline="yes">
      <aliases>
	<alias name="print_value"/>
	<alias name="get"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::print_count,$item[3]]</action>
      </production>
      <documentation sections="information">
	<usage>count <xref linkend="xpath"/></usage>
	<shortdesc>calculate given XPath expression and enumerate node-lists</shortdesc>
	<description>
	  <para>
	    Calculate the given <xref linkend='xpath'/> expression. If
	    the result is a node-list, return number of nodes in the
	    node-list.  If the <xref linkend='xpath'/> results in a
	    boolean, numeric or literal value, return the value.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="perl_code" type="argtype" name="perl-code">
      <production>
	<directive type="perl_codeblock"></directive>
      </production>
      <production>
	<ruleref ref="perl_expression"/>
      </production>
      <documentation sections="argtypes">
	<title>Perl-code argument type</title>
	<shortdesc>in-line code in Perl programming language</shortdesc>
	<description>
	  <para>
	    A block of perl code enclosed in curly brackets or an
	    expression which interpolates to a perl
	    expression. Variables defined in XSH are visible in perl
	    code as well. Since XSH redirects output to the terminal,
	    you cannot simply use perl print function for output if you
	    want to filter the result with a shell command. Instead use
	    predefined perl routine `echo ...'  which is equivalent to
	    `print $::OUT ...'. The $::OUT perl-variable stores the
	    referenc to the terminal file handle.
	  </para>
	  <example>
	    <code>
	      $i="foo";

	      eval { echo "$i-bar\n"; } # prints foo-bar

	      eval 'echo "\$i-bar\n";'  # exactly the same as above

	      eval 'echo "$i-bar\n";'   # prints foo-bar too, but $i is
	      # interpolated by XSH, so perl
	      # actually evaluates
	      #  echo "foo-bar\n";
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="eval_command" type="command" name="eval" inline="yes">
      <aliases>
	<alias name="perl"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="perl_code"/>
	<action>[\&amp;XML::XSH::Functions::print_eval,$item[3]]</action>
      </production>
      <documentation sections="binding">
	<usage>eval <xref linkend="perl_code"/></usage>
	<shortdesc>evaluate in-line perl code</shortdesc>
	<description>
	  <para>Evaluate the given perl expression and print the return value.</para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="prune_command" type="command" name="remove" inline="yes">
      <aliases>
	<alias name="rm"/>
	<alias name="prune"/>
	<alias name="delete"/>
	<alias name="del"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::prune,$item[3]]</action>
      </production>
      <documentation sections="manipulation">
	<usage>remove <xref linkend="xpath"/></usage>
	<shortdesc>remove given nodes</shortdesc>
	<description>
	  <para>Remove all nodes matching <xref
	      linkend='xpath'/>.</para>
	  <example>
	    <title>Get rid of all evil creatures.</title>
	    <code>xsh> del //creature[@manner='evil']</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="print_command" type="command" name="print" inline="yes">
      <aliases>
	<alias name="echo"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression" rep="s?"/>
	<action>[\&amp;XML::XSH::Functions::echo,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>print <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<shortdesc>print given stuff on standard console output</shortdesc>
	<description>
	  <para>Interpolate and print given expression(s).</para>
	</description>
      </documentation>
    </rule>
    <rule id="sort_command" type="command" name="sort" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="block"/>
	<ruleref ref="block"/>
	<ruleref ref="perl_code"/>
	<ruleref ref="nodelistvariable"/>
	<action>[\&amp;XML::XSH::Functions::perlsort,@item[3..6]]</action>
      </production>
      <documentation>
	<usage>sort <xref linkend="block"/> <xref linkend="block"/> <xref linkend="perl_code"/> %<xref linkend="ID"/></usage>
	<shortdesc>sort given node-list using xsh and perl commands</shortdesc>
	<description>
	  <para>
	    EXPERIMENTAL! This command is not yet guaranteed to remain in the 
	    future releases.
	  </para>
	  <para>
	    This command may be used to sort the node-list stored in
	    the node-list variable <xref linkend="ID"/>. On each
	    comparizon, first the two <xref linkend="block"/> are
	    evaluated, each in a context of one of the nodes to
	    compare. These <xref linkend="block"/> are supposed to
	    prepair any variables needed for later order comparizon in
	    the <xref linkend="perl_code"/>.  The nodes to be compared
	    are available in %a and %b node-lists. It is the <xref
	    linkend="perl_code"/> that is responsible for deciding
	    which node comes first. Therefore it should return either
	    -1, 0, or 1.
	  </para>
	  <example>
	    <title>Sort creatures by name</title>
	    <code>xsh> %c=//creatures
                  xsh> sort { $a=string(@name) }{ $b=string(@name) }{ $a cmp $b } %c
                  xsh> ls %c/@name</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="map_command" type="command" name="map" inline="yes">
      <aliases>
	<alias name="sed"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="perl_code"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::perlmap,@item[4,3]]</action>
      </production>
      <documentation sections="perlbinding">
	<usage>map <xref linkend="perl_code"/> <xref
	    linkend="xpath"/></usage>
	<shortdesc>quickly rename/modify nodes with in-line Perl code</shortdesc>
	<description>
	  <para>
	    Each of the nodes matching <xref linkend='xpath'/> is
	    processed with the <xref linkend='perl_code'/> in the
	    following way: if the node is an element, its name is
	    processed, if it is an attribute, its value is used, if it
	    is a cdata section, text node, comment or processing
	    instruction, its data is used.  The expression should expect
	    the data in the $_ variable and should use the same variable
	    to store the modified data.
	  </para>
	  <example>
	    <title>Renames all hobbits to halflings</title>
	    <code>xsh> map $_='halfling' //hobbit</code>
	  </example>
	  <example>
	    <title>Capitalises all hobbit names</title>
	    <code>xsh> map { $_=ucfirst($_) } //hobbit/@name</code>	  
	  </example>
	  <example>
	    <title>Changes goblins to orcs in all hobbit tales.</title>
	    <code>xsh> on s/goblin/orc/gi //hobbit/tale/text()</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="close_command" type="command" name="close" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::close_doc,$item[3]]</action>
      </production>
      <documentation sections="documents">
	<usage>close <xref linkend='ID'/></usage>
	<shortdesc>close document (do not save it, though)</shortdesc>
	<description>
	  <para>
	    Close the document identified by <xref linkend='ID'/>, removing its
	    parse-tree from memory.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="select_command" type="command" name="select"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,[$item[3],"/"]]</action>
      </production>
      <documentation sections="documents navigation">
	<usage>select <xref linkend='ID'/></usage>
	<shortdesc>make given document the current one</shortdesc>
	<description>
	  <para>
	    Make <xref linkend='ID'/> the document identifier to be used in the next
	    xpath evaluation without identifier prefix.
	  </para>
	  <example>
	    <code>
	      xsh> a=mydoc1.xml       # opens and selects a
	      xsh> list /             # lists a
	      xsh> b=mydoc2.xml       # opens and selects b
	      xsh> list /             # lists b
	      xsh> list a:/           # lists and selects a
	      xsh> select b           # does nothing except selecting b
	      xsh> list /             # lists b
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="open_command" type="command" name="open" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5]]</action>
      </production>
      <production>
	<ruleref ref="ID"/>
	<regexp>\s*=\s*</regexp>
	<directive type="commit"></directive>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[1,4]]</action>
      </production>
      <documentation sections="documents">
	<usage>[open] <xref linkend='ID'/>=<xref
	    linkend='filename'/></usage>
	<shortdesc>load an XML document form a file or URI</shortdesc>
	<description>
	  <para>
	    Open a new document assigning it a symbolic name of <xref linkend='ID'/>.
	    To identify the document, use simply <xref linkend='ID'/> in commands like
	    close, save, validate, dtd or enc. In commands which work on
	    document nodes, use <xref linkend='ID'/>: prefix is XPath expressions to
	    point the XPath into the document.
	  </para>
	  <example>
	    <code>
	      xsh> open x=mydoc.xml # open a document

	      # quote file name if it contains whitespace
	      xsh> open y="document with a long name with spaces.xml"

	      # you may omit the word open (I'm clever enough to find out).
	      xsh> z=mybook.xml

	      # use z: prefix to identify the document opened with the
	      # previous comand in an XPath expression.
	      xsh> list z://chapter/title	    
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="openhtml_command" type="command" name="open-HTML"
    inline="yes">
      <aliases>
	<alias name="open_HTML"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5],'html']</action>
      </production>
      <documentation sections="documents">
	<usage>open_HTML <xref linkend='ID'/>=<xref
	    linkend='filename'/></usage>
	<shortdesc>load an HTML document from a file or URI</shortdesc>
	<description>
	  <para>
	    Open a new HTML document assigning it a symbolic name of
	    <xref linkend='ID'/>. To save it as HTML, use save_HTML
	    command (use of just save or saveas would change it to
	    XHTML without changing the DOCTYPE declaration).
	  </para>
	</description>
	<see-also>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="openpipe_command" type="command" name="open-PIPE"
    inline="yes">
      <aliases>
	<alias name="open_PIPE"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5],'pipe']</action>
      </production>
      <documentation sections="documents">
	<usage>open_PIPE <xref linkend='ID'/>=<xref
	    linkend='expression'/></usage>
	<shortdesc>read a document piped by a system command</shortdesc>
	<description>
	  <para>
	    Run the system command resluting from interpoation of the <xref
	    linkend='expression'/> and parse its output as XML,
	    associating the resulting DOM tree with the given <xref
	    linkend="ID"/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="openhtml_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="create_command" type="command" name="create"
    inline="yes">
      <aliases>
	<alias name="new"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::create_doc,@item[3,4]]</action>
      </production>
      <documentation sections="documents">
	<usage>create <xref linkend='ID'/> <xref
	    linkend="expression"/></usage>
	<shortdesc>make a new document from given XML fragment</shortdesc>
	<description>
	  <para>
	    Create a new document using <xref linkend='expression'/> to
	    form the root element and associate it with the given
	    identifier.
	  </para>
	  <example>
	    <code>
	      xsh> create t1 root
	      xsh> ls /
	      &lt;?xml version="1.0" encoding="utf-8"?>
	      &lt;root/>

	      xsh> create t2 "&lt;root id='r0'>Just a &lt;b>test&lt;/b>&lt;/root>"
	      xsh> ls /
	      &lt;?xml version="1.0" encoding="utf-8"?>
	      &lt;root id='r0'>Just a &lt;b>test&lt;/b>&lt;/root>
	      xsh> files
	      scratch = new_document.xml
	      t1 = new_document1.xml
	      t2 = new_document2.xml
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="clone_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="encoding_param">
      <production>
	<regexp>encoding\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="save_command" type="command" name="save" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as,$item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="documents">
	<usage>save <xref linkend='ID'/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<shortdesc>save a document as XML</shortdesc>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> to its
	    original XML file, optionally converting it from its original
	    encoding to <xref linkend='enc_string'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="saveas_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="savehtml_command" type="command" name="save-HTML"
    inline="yes">
      <aliases>
	<alias name="save_HTML"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as_html,@item[3,4],@{$item[5]}]</action>
      </production>
      <documentation sections="documents">
	<usage>save_HTML <xref linkend='ID'/> <xref linkend="filename"/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<shortdesc>store a document in a local file as HTML</shortdesc>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> as a
	    HTML file named <xref linkend='filename'/>, optionally
	    converting it from its original encoding to <xref
	      linkend='enc_string'/> Note, that this does just
	    the character conversion, so you
	    must specify the correct encoding in the META tag yourself.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="openhtml_command"/>
	  <ruleref ref="saveas_command"/>
	  <ruleref ref="save_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="saveas_command" type="command" name="saveas"
    inline="yes">
      <aliases>
	<alias name="save-as"/>
	<alias name="save_as"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_as,@item[3,4],@{$item[5]}]</action>
      </production>
      <documentation sections="documents">
	<usage>saveas <xref linkend='ID'/> <xref linkend="filename"/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<shortdesc>store a document as a given file in XML format</shortdesc>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> as a
	    XML file named <xref linkend='filename'/>, optionally
	    converting it from its original encoding to <xref
	      linkend='enc_string'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="save_command"/>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="savexinclude_command" type="command"
    name="save-xinclude" inline="yes">
      <aliases>
	<alias name="save_xinclude"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_xinclude,@item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="documents">
	<usage>save_xinclude <xref linkend='ID'/> [encoding <xref
	    linkend='enc_string'/>]</usage>
	<shortdesc>save an XML document and all XIncluded parts separately</shortdesc>
	<description>
	  <para>
	    Save the document identified by <xref linkend='ID'/> while
	    saving all expanded XInclude sections to the original
	    files (optionally converting it from its original encoding
	    to <xref linkend='enc_string'/>).  Once expanded, sections
	    included with XInclude mechanism cannot be normally
	    distinguished from other parts of the DOM tree by any
	    XPath expression or XSH command. Internally, however, they
	    are marked with special DOM nodes. This command uses these
	    nodes to find the sections and save them to their original
	    documents while restoring the &lt;xi:include&gt; tags in
	    the root document. More over, this command may be used to
	    split the document to new fragments included back by means
	    of XInclude, since all non-empty fragments containded
	    within
	  </para>
	  <para>
	    &lt;xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
   	    href='output-file'&gt;&lt;xi:include/&gt;
	  </para>
	  <para>
	    elements are saved to separate files too, leaving only
	    empty xi:include element in the root file.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="save_command"/>
	  <ruleref ref="savehtml_command"/>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="list_dtd_command" type="command" name="dtd" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::list_dtd,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>dtd [<xref linkend='ID'/>]</usage>
	<shortdesc>show document's DTD</shortdesc>
	<description>
	  <para>
	    Print external or internal DTD for the given document.  If
	    no document identifier is given, the current document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="validate_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="print_enc_command" type="command"
    name="enc" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::print_enc,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>enc [<xref linkend='ID'/>]</usage>
	<shortdesc>show document's original character encoding</shortdesc>
	<description>
	  <para>
	    Print the original document encoding string.
	    If no document identifier is given, the current document is
	    used.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="validate_command" type="command" name="validate"
    inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>validate [<xref linkend='ID'/>]</usage>
	<shortdesc>validate a document against its DTD</shortdesc>
	<description>
	  <para>
	    Try to validate the document identified with <xref
	      linkend='ID'/> according to its DTD, report all validity
	    errors.  If no document identifier is given, the current
	    document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="valid_command" type="command" name="valid" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::valid_doc,@{$item[3]}]</action>
      </production>
      <documentation sections="information">
	<usage>valid [<xref linkend='ID'/>]</usage>
	<shortdesc>check if the document is valid (according to its DTD)</shortdesc>
	<description>
	  <para>
	    Check and report the validity of a document.  Prints "yes"
	    if the document is valid and "no" otherwise.  If no document
	    identifier is given, the current document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="validate_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="exit_command" type="command" name="exit" inline="yes">
      <aliases>
	<alias name="quit"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::quit,@{$item[3]}]</action>
      </production>
      <documentation sections="flow">
	<usage>exit [<xref linkend='expression'/>]</usage>
	<shortdesc>exit XSH shell</shortdesc>
	<description>
	  <para>
	    Exit xsh immediately, optionally with the exit-code
	    resulting from the given expression.
	  </para>
	  <para>
	    WARNING: No files are saved on exit.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="process_xinclude_command" type="command"
    name="process-xinclude" inline="yes">
      <aliases>
	<alias name="process_xinclude"/>
	<alias name="process-xincludes"/>
	<alias name="process_xincludes"/>
	<alias name="xinclude"/>
	<alias name="xincludes"/>
	<alias name="load_xincludes"/>
	<alias name="load-xincludes"/>
	<alias name="load_xinclude"/>
	<alias name="load-xinclude"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>	
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::process_xinclude,@{$item[3]}]</action>
      </production>
      <documentation sections="manipulation documents">
	<usage>process_xinclude [<xref linkend='ID'/>]</usage>
	<shortdesc>load and insert XInclude sections</shortdesc>
	<description>
	  <para>
	    Process any xinclude tags in the document <xref linkend='ID'/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="parser_expands_xinclude"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="chxpath_command" type="command" name="cd" inline="yes">
      <aliases>
	<alias name="chxpath"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,@{$item[3]}]</action>
      </production>
      <documentation sections="navigation">
	<usage>cd [<xref linkend="xpath"/>]</usage>
	<shortdesc>change current context node</shortdesc>
	<description>
	  <para>Change current context node (and current document) to
	    the first node matching the given <xref linkend="xpath"/>
	    argument.
          </para>
	</description>
      </documentation>
    </rule>
    <rule id="pwd_command" type="command" name="pwd" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_pwd]</action>
      </production>
      <documentation sections="navigation information">
	<usage>pwd</usage>
	<shortdesc>show current context node location (as a cannonical XPath)</shortdesc>
	<description>
	  <para>Print XPath leading to the current context node.
	    This is equivalent to `locate .'.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="locate_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="locate_command" type="command" name="locate"
    inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"></directive>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::locate,@{$item[3]}]</action>
      </production>
      <documentation sections="navigation information">
	<usage>locate <xref linkend="xpath"/></usage>
	<shortdesc>show given node location (as a cannonical XPath)</shortdesc>
	<description>
	  <para>Print canonical XPaths leading to nodes matched by
	    the <xref linkend="xpath"/> given.</para>
	</description>
	<see-also>
	  <ruleref ref="pwd_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="xupdate_command" type="command" name="xupdate"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<ruleref ref="expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xupdate,$item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="manipulation">
	<usage>xupdate <xref linkend="ID"/> [<xref linkend="ID"/>]</usage>
	<shortdesc>apply XUpdate commands on a document</shortdesc>
	<description>
	  <para>Modify the current document or the document specified
	    by the second <xref linkend="ID"/> argument according to
	    XUpdate commands of the first <xref linkend="ID"/>
	    document. XUpdate is a XML Update Language which aims to
	    be a language for updating XML documents.
	  </para>
	  <para>
	    XUpdate langauge is described in XUpdate Working Draft at
            http://www.xmldb.org/xupdate/xupdate-wd.html.	    	    
	  </para>
	  <para>XUpdate output can be generated for example by
            Python xmldiff utility from
	    http://www.logilab.org/xmldiff/. Unfortunatelly,
	    there are few bugs (or, as I tend to say In case of
            Python, white-space problems) in their code, so its 
            XUpdate output is not always correct.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="verbose" type="command" name="verbose" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_q,0]</action>
      </production>
      <documentation sections="configuration">
	<usage>verbose</usage>
	<shortdesc>make XSH print many messages</shortdesc>
	<description>
	  <para>Turn on verbose messages (default).</para>
	</description>
	<see-also>
	  <ruleref ref="quiet"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="test_mode" type="command" name="test-mode" inline="yes">
      <aliases>
	<alias name="test_mode"/>
      </aliases>
      <production>
	<selfref/>
	<action>["test-mode"]</action>
      </production>
      <documentation sections="flow configuration">
	<usage>test-mode</usage>
	<shortdesc>do not execute any command, only check the syntax</shortdesc>
	<description>
	  <para>
	    Switch into test mode in which no commands are actually
	    executed and only command syntax is checked.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="run_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="run_mode" type="command" name="run-mode" inline="yes">
      <aliases>
	<alias name="run_mode"/>
      </aliases>
      <production>
	<selfref/>
	<action>["run-mode"]</action>
      </production>
      <documentation sections="flow configuration">
	<usage>run-mode</usage>
	<shortdesc>switch into normal execution mode (quit <xref linkend="test_mode"/>)</shortdesc>
	<description>
	  <para>
	    Switch into normal XSH mode in which all commands are
	    executed.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="test_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="debug" type="command" name="debug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_d,1]</action>
      </production>
      <documentation sections="configuration">
	<usage>debug</usage>
	<shortdesc>display many annoying debugging messages</shortdesc>
	<description>
	  <para>Turn on debugging messages.</para>
	</description>
	<see-also>
	  <ruleref ref="nodebug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodebug" type="command" name="nodebug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_d,0]</action>
      </production>
      <documentation sections="configuration">
	<usage>nodebug</usage>
	<shortdesc>turn off debugging messages</shortdesc>
	<description>
	  <para>Turn off debugging messages.</para>
	</description>
	<see-also>
	  <ruleref ref="debug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="version" type="command" name="version" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_version,0]</action>
      </production>
      <documentation sections="information">
	<usage>version</usage>
	<shortdesc>show version information</shortdesc>
	<description>
	  <para>
	    Prints program version as well as versions of
	    XML::XSH::Functions, XML::LibXML, and XML::LibXSLT modules
	    used.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="validation" type="command" name="validation"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_validation,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>validation <xref linkend="expression"/></usage>
	<shortdesc>turn on/off validation in XML parser</shortdesc>
	<description>
	  <para>
	    Turn on validation during the parse process if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    Defaults to on.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="recovering" type="command" name="recovering"
    inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_recovering,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>recovering <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's ability to fix broken XML</shortdesc>
	<description>
	  <para>
	    Turn on recovering parser mode if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    Defaults to off. Note, that the in the recovering mode,
            validation is not performed by the parser even if
	    the validation flag is on and that recovering mode flag
            only influences parsing of XML documents (not HTML).
	  </para>
	  <para>The recover mode helps to efficiently recover
	  documents that are almost well-formed. This for example
	  includes documents without a close tag for the document
	  element (or any other element inside the document).</para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_entities" type="command"
    name="parser-expands-entities" inline="yes">
      <aliases>
	<alias name="parser_expands_entities"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_entities,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>parser_expands_entities <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's tendency to expand entities</shortdesc>
	<description>
	  <para>
	    Turn on the entity expansion during the parse process if the
	    <xref linkend="expression"/> is non-zero on or off otherwise.  If entity
	    expansion is off, any external parsed entities in the
	    document are left as entities. Defaults to on.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="keep_blanks" type="command" name="keep-blanks"
    inline="yes">
      <aliases>
	<alias name="keep_blanks"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_keep_blanks,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>keep_blanks <xref linkend="expression"/></usage>
	<shortdesc>turn on/off ignorable whitespace preservation</shortdesc>
	<description>
	  <para>
	    Allows you to turn off XML::LibXML's default behaviour of
	    maintaining whitespace in the document. Non-zero expression
	    forces the XML parser to preserve all whitespace.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="pedantic_parser" type="command" name="pedantic-parser"
    inline="yes">
      <aliases>
	<alias name="pedantic_parser"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_pedantic_parser,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>pedantic_parser <xref linkend="expression"/></usage>
	<shortdesc>make the parser more pedantic</shortdesc>
	<description>
	  <para>
	    If you wish, you can make XML::LibXML more pedantic by passing
	    a non-zero <xref linkend="expression"/> to this command.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="complete_attributes" type="command"
    name="complete-attributes" inline="yes">
      <aliases>
	<alias name="complete_attributes"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_complete_attributes,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>complete_attributes <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's ability to fill default attribute values</shortdesc>
	<description>
	  <para>
	    If the expression is non-zero, this command allows XML parser
	    to complete the elements attributes lists with the ones
	    defaulted from the DTDs.  By default, this option is enabled.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="indent" type="command" name="indent" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_indent,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>indent <xref linkend="expression"/></usage>
	<shortdesc>turn on/off pretty-printing</shortdesc>
	<description>
	  <para>If the <xref linkend="expression"/> is non-zero,
	    format the XML output while saving a document
	    by adding some nice ignorable whitespace.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_xinclude" type="command"
    name="parser-expands-xinclude" inline="yes">
      <aliases>
	<alias name="parser_expands_xinclude"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_xinclude,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>parser_expands_xinclude <xref
	    linkend="expression"/></usage>
	<shortdesc>turn on/off transparent XInclude insertion by parser</shortdesc>
	<description>
	  <para>
	    If the <xref linkend="expression"/> is non-zero, the parser is
	    allowed to expand XIinclude tags imidiatly while parsing the
	    document.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="process_xinclude_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="load_ext_dtd" type="command" name="load-ext-dtd"
    inline="yes">
      <aliases>
	<alias name="load_ext_dtd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_load_ext_dtd,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>load_ext_dtd <xref linkend="expression"/></usage>
	<shortdesc>turn on/off external DTD fetching</shortdesc>
	<description>
	  <para>
	    If the expression is non-zero, XML parser loads external DTD
	    subsets while parsing. By default, this option is enabled.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="encoding" type="command" name="encoding" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_encoding,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>encoding <xref linkend="enc_string"/></usage>
	<shortdesc>choose output charset</shortdesc>
	<description>
	  <para>Set the default output character encoding.</para>
	</description>
      </documentation>
    </rule>
    <rule id="query_encoding" type="command" name="query-encoding"
    inline="yes">
      <aliases>
	<alias name="query_encoding"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"></directive>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_qencoding,$item[3]]</action>
      </production>
      <documentation sections="configuration">
	<usage>query-encoding <xref linkend="enc_string"/></usage>
	<shortdesc>declare the charset of XSH source files and terminal input</shortdesc>
	<description>
	  <para>Set the default query character encoding.</para>
	</description>
      </documentation>
    </rule>
    <rule id="quiet" type="command" name="quiet" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_opt_q,1]</action>
      </production>
      <documentation sections="configuration">
	<usage>quiet</usage>
	<shortdesc>turn off many XSH messages</shortdesc>
	<description>
	  <para>Turn off verbose messages.</para>
	</description>
	<see-also>
	  <ruleref ref="verbose"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="backups" type="command" name="backups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,1]</action>
      </production>
      <documentation sections="configuration documents">
	<usage>backups</usage>
	<shortdesc>turn on backup file creation</shortdesc>
	<description>
	  <para>Enable creating backup files on save (default).</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nobackups" type="command" name="nobackups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,0]</action>
      </production>
      <documentation sections="configuration documents">
	<usage>nobackups</usage>
	<shortdesc>turn off backup file creation</shortdesc>
	<description>
	  <para>Disable creating backup files on save.</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
  </rules>  
</recdescent-xml>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml-tools/dtd/catalog /home/pajas/lib/sgml/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/docbook/3.1/docbook.cat /home/pajas/share/sgml/stylesheets/docbook/catalog /home/pajas/share/sgml/entities/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/jade/dsssl.cat /home/pajas/share/sgml/stylesheets/sgmltools/sgmltools.cat /home/pajas/share/sgml/dtd/sgmltools/catalog")
sgml-local-ecat-files:nil
End:
-->
