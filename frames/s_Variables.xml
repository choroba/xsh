<?xml version="1.0" encoding="utf-8"?>
<section id="Variables">
      <title>Variables</title>
      <para>
	In XSH2, like in Perl and XPath, 
	<ulink url="s_varname.html">variable names</ulink> are are prefixed
        with a dollar sign ($). 
        Variables can
        contain arbitrary Perl Scalar (string, number, array
        reference, hash reference or an object reference).  XPath
        objects are transparently mapped to Perl objects via
        XML::LibXML objects. 
        Values can be assigned to variables
        either by simple <ulink url="s_assign_command.html">assignments</ulink> of the form
	<literal>$variable = <ulink url="s_exp.html">expression</ulink></literal>,
        where the right hand side is an expression, or by command 
        <ulink url="s_assign_command.html">assignments</ulink> of the form
	<literal>$variable := <ulink url="s_command.html">command</ulink></literal>,
        where the right hand side is a XSH2 command, or by
	capturing the output of some command with a variable
	redirection of the following form:</para>
      <programlisting>command |&gt; $variable;</programlisting>
      <para>
	XSH2 expressions are evaluated either by XPath
	engine or by Perl (the latter only happens if the entire
	expression is enclosed with braces
	<literal>{...}</literal>), and
	both Perl and XPath can access all XSH2 variables
	transparently (Perl expressions may even assign to them).
      </para>
      <para>
	A simple simple expression consisting of a variable name
        (e.g. <literal>$variable</literal>) is always evaluated by the
        XPath engine and the result is the content of the variable as
        it appears to the XPath data model.  Since in XPath object
        cannot be void (undefined), XPath engine complains, if the
        value of the variable is undefined. On the other hand,
        expressions like <literal>{$variable}</literal> are evaluated by
        Perl, which results in the value of the variable as seen
	by Perl.
      </para>
      <para>
	Variables can also be used as macros for complicated XPath
	expressions. Any occurrence of a substring of the form
	<literal>${variable}</literal> in an XPath expression is
	interpolated to the value of <literal>$variable</literal> (if
	<literal>$variable</literal> contains an object rather than a
	string or number, then the object is cast to string first) before the
	entire expression is evaluated.  So, for example, if
	<literal>${variable}</literal> contains string
	"<literal>chapter[title]</literal>" (without the quotes), then
	the XPath expression
	<literal>//sect1/${variable}/para</literal> interpolates to 
	<literal>//sect1/chapter[title]/para</literal> prior
	to evaluation. 
      </para>
      <para>
	To display the current value of a variable, use either
	<ulink url="s_print_command.html">print</ulink>
	or (in case of a global variables - the distinction is discussed below)
	the command <ulink url="s_var_command.html">variables</ulink>:
      </para>
      <example id="gen-000">
	  <programlisting>xsh&gt; <userinput>$b="my_document";</userinput>
xsh&gt; <userinput>$file="${b}s.xml";</userinput>
xsh&gt; <userinput>$f := open $file;</userinput>
xsh&gt; <userinput>ls //$b[count(descendant::para)&gt;10]</userinput>
xsh&gt; <userinput>print $b</userinput>
my_document
xsh&gt; <userinput>variables</userinput>
...
$b='my_document';
...
$file='my_documents.xml';
...
</programlisting>
	</example>
      <para>
	Variables can also serve as containers for documents and can be used to
	store lists of nodes that result from evaluating an XPath
	expression (a.k.a. XPath node-sets). This is especially useful
	when a sequence of commands is to be performed on some fixed
        set of nodes and repetitive evaluation of the same XPath 
	expression would be lengthy.  XPath
	node-sets are represented by
	<literal>XML::LibXML::NodeList</literal> Perl objects (which
	is simply a array reference blessed to the above class, which
	provides some simple operator overloading). In XPath, by a
	node-set by definition can only contain a single copy of each
	node and the nodes within a node-set are processed in the same
	order as they appear in the XML document. Having XPath
	node-sets represented by a list gives us the advantage of having
	the possibility to process the list in a different order than
	the one implied by the document (which is what happens
	if a variable containing a node-list is evaluated by Perl 
	rather than XPath), see an example below.
      </para>
      <example id="gen-001">
	<programlisting>xsh&gt; <userinput>$creatures = //creature[@status='alive']</userinput>
# process creatures in the document order: 
xsh&gt; <userinput>foreach $creature print @name;</userinput>
# process creatures in the reverse document order: 
xsh&gt; <userinput>foreach { reverse @$creature } print @name;</userinput>
# append some more nodes to a node-list (using a variant of
# a simple assignment)
xsh&gt; <userinput>$creatures += //creature[@status='dead'];</userinput>
# again, we can process creatures in order implied by the document:
xsh&gt; <userinput>foreach $creature print @name;</userinput>
# but we can also process first living and then dead creatures,
# since this is how they are listed in $creature
xsh&gt; <userinput>foreach {$creature} print @name;</userinput>
# same as the above is
xsh&gt; <userinput>foreach {@$creature} print @name;</userinput>
</programlisting>
      </example>
      <para>
	XSH2 variables are either globally or lexically scoped.
	Global variables need not to be declared (they can be directly
	assigned to), whereas lexical variables must be declared
	using the command <ulink url="s_my_command.html">my</ulink>. Global variable
	assignment may also be made temporal for the enclosing block,
	using <ulink url="s_local_command.html">local</ulink>.
      </para>
      <example id="gen-002">
	<programlisting>$var1 = "foo";           # a global variable requires no declaration
local $var1 $var2 $var3; # localizes global variables
$var1 = "bar";           # assignment to a localized variable is temporary
local $var4 = "foo";     # localized assignment
my $var1 $var $var3;     # declares lexical variables
my $var1 = "foo";        # lexical variable declaration with assignment
</programlisting>
      </example>
      <para>
	Lexical variables are only defined in the scope of current
	block or subroutine. There is no way to refer to a lexical
	variable form outside of the block it was declared in, nor
	from within a nested subroutine call. Of course, lexical
	variables can be referred to from nested blocks or Perl
	expressions (where they behave just like Perl's lexical
	variables).
      </para>
      <para>
	On the other hand, global or localized XSH2 variables are just
	Perl Scalar variables belonging to the
	<literal>XML::XSH2::Map</literal> namespace, which is also the
	default namespace for any Perl code evaluated from XSH2 (so
	there's no need to use this prefix explicitly in Perl expressions,
	unless of course there is a lexical variable in the current
	scope with the same).
      </para>
      <para>Localizing a variable using the <literal>local</literal>
	keyword makes all assignments to it occurring in the enclosing block
	temporary. The variable itself remains global, only its
	original value is restored at the end of the block that localized it.
      </para>
      <para> 
	In all above cases, it is possible to arbitrarily
	intermix XSH2 and Perl assignments:
      </para>
      <example id="gen-003">
	  <programlisting>xsh&gt; <userinput>ls //chapter[1]/title</userinput>
&lt;title&gt;Introduction&lt;/title&gt;
xsh&gt; <userinput>$a=string(//chapter[1]/title)</userinput>
xsh&gt; <userinput>perl { $b="CHAPTER 1: ".uc($a); }</userinput>
xsh&gt; <userinput>print $b</userinput>
CHAPTER 1: INTRODUCTION
</programlisting>
      </example>
      <para>
	Although all XSH2 variables are in fact Perl Scalars, it is
	still possible to store Perl Array or Hash value to a XSH2
	variable via reference. The following example demonstrates
	using Perl Hashes to collect and print some simple racial
	statistics about the population of Middle-Earth:
      </para>
      <example id="gen-004">
	<programlisting>my $races;
foreach a:/middle-earth/creature { 
  my $race=string(@race);
  perl { $races-&gt;{$race}++ };
}
print "Middle-Earth Population (race/number of creatures)"
print { map "$_/$races-&gt;{$_}\n" keys(%$races); };
</programlisting>
      </example>
    <simplesect role="related" id="gen-005">
                 <title>Related Topics</title>
                 <variablelist><varlistentry>
      <term><ulink url="s_assign_command.html">assign</ulink></term>
      <listitem>variable assignment</listitem>
    </varlistentry><varlistentry>
      <term><ulink url="s_document.html">document</ulink></term>
      <listitem>specifying documents</listitem>
    </varlistentry><varlistentry>
      <term><ulink url="s_exp.html">expression</ulink></term>
      <listitem>expression argument type</listitem>
    </varlistentry><varlistentry>
      <term><ulink url="s_local_command.html">local</ulink></term>
      <listitem>temporarily assign new value to a variable</listitem>
    </varlistentry><varlistentry>
      <term><ulink url="s_subname.html">subroutine</ulink></term>
      <listitem>name of a sub-routine</listitem>
    </varlistentry><varlistentry>
      <term><ulink url="s_varname.html">$variable</ulink></term>
      <listitem/>
    </varlistentry><varlistentry>
      <term><ulink url="s_xpath.html">xpath</ulink></term>
      <listitem>XPath expression</listitem>
    </varlistentry></variablelist>
               </simplesect></section>
